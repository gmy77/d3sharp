// Generated by ProtoGen, Version=2.4.1.473, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace D3.GameMessage {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public static partial class GameMessage {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_HeroDigestList__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.HeroDigestList, global::D3.GameMessage.HeroDigestList.Builder> internal__static_D3_GameMessage_HeroDigestList__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_ClientToonSettings__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.ClientToonSettings, global::D3.GameMessage.ClientToonSettings.Builder> internal__static_D3_GameMessage_ClientToonSettings__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_HeroDigestListRequest__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.HeroDigestListRequest, global::D3.GameMessage.HeroDigestListRequest.Builder> internal__static_D3_GameMessage_HeroDigestListRequest__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_HeroDigestResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.HeroDigestResponse, global::D3.GameMessage.HeroDigestResponse.Builder> internal__static_D3_GameMessage_HeroDigestResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_HeroDigestListResponse__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.HeroDigestListResponse, global::D3.GameMessage.HeroDigestListResponse.Builder> internal__static_D3_GameMessage_HeroDigestListResponse__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_PlayerBanner__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.PlayerBanner, global::D3.GameMessage.PlayerBanner.Builder> internal__static_D3_GameMessage_PlayerBanner__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_SaveBannerConfiguration__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.SaveBannerConfiguration, global::D3.GameMessage.SaveBannerConfiguration.Builder> internal__static_D3_GameMessage_SaveBannerConfiguration__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_HeroDigestBanner__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.HeroDigestBanner, global::D3.GameMessage.HeroDigestBanner.Builder> internal__static_D3_GameMessage_HeroDigestBanner__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_GameCurrentPlayers__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.GameCurrentPlayers, global::D3.GameMessage.GameCurrentPlayers.Builder> internal__static_D3_GameMessage_GameCurrentPlayers__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_AccountVersionList__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.AccountVersionList, global::D3.GameMessage.AccountVersionList.Builder> internal__static_D3_GameMessage_AccountVersionList__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_AccountVersionSync__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.AccountVersionSync, global::D3.GameMessage.AccountVersionSync.Builder> internal__static_D3_GameMessage_AccountVersionSync__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_TooltipIds__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.TooltipIds, global::D3.GameMessage.TooltipIds.Builder> internal__static_D3_GameMessage_TooltipIds__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_TooltipGenerators__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.TooltipGenerators, global::D3.GameMessage.TooltipGenerators.Builder> internal__static_D3_GameMessage_TooltipGenerators__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_TutorialMessage__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.TutorialMessage, global::D3.GameMessage.TutorialMessage.Builder> internal__static_D3_GameMessage_TutorialMessage__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_D3_GameMessage_SetAchievementShowcase__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.SetAchievementShowcase, global::D3.GameMessage.SetAchievementShowcase.Builder> internal__static_D3_GameMessage_SetAchievementShowcase__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static GameMessage() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "ChFHYW1lTWVzc2FnZS5wcm90bxIORDMuR2FtZU1lc3NhZ2UaCkhlcm8ucHJv" + 
          "dG8aE09ubGluZVNlcnZpY2UucHJvdG8aDlNldHRpbmdzLnByb3RvGg1BY2Nv" + 
          "dW50LnByb3RvGgtJdGVtcy5wcm90byJmCg5IZXJvRGlnZXN0TGlzdBIuCgph" + 
          "Y2NvdW50X2lkGAEgAigLMhouRDMuT25saW5lU2VydmljZS5FbnRpdHlJZBIk" + 
          "CgtkaWdlc3RfbGlzdBgCIAMoCzIPLkQzLkhlcm8uRGlnZXN0IngKEkNsaWVu" + 
          "dFRvb25TZXR0aW5ncxIrCgd0b29uX2lkGAEgAigLMhouRDMuT25saW5lU2Vy" + 
          "dmljZS5FbnRpdHlJZBI1ChRjbGllbnRfdG9vbl9zZXR0aW5ncxgCIAIoCzIX" + 
          "LkQzLkNsaWVudC5Ub29uU2V0dGluZ3MiRAoVSGVyb0RpZ2VzdExpc3RSZXF1" + 
          "ZXN0EisKB3Rvb25faWQYASADKAsyGi5EMy5PbmxpbmVTZXJ2aWNlLkVudGl0" + 
          "eUlkIngKEkhlcm9EaWdlc3RSZXNwb25zZRIrCgd0b29uX2lkGAEgAigLMhou" + 
          "RDMuT25saW5lU2VydmljZS5FbnRpdHlJZBIPCgdzdWNjZXNzGAIgAigIEiQK" + 
          "C2hlcm9fZGlnZXN0GAMgASgLMg8uRDMuSGVyby5EaWdlc3QiUQoWSGVyb0Rp" + 
          "Z2VzdExpc3RSZXNwb25zZRI3CgtkaWdlc3RfbGlzdBgBIAMoCzIiLkQzLkdh" + 
          "bWVNZXNzYWdlLkhlcm9EaWdlc3RSZXNwb25zZSJVCgxQbGF5ZXJCYW5uZXIS" + 
          "FAoMcGxheWVyX2luZGV4GAEgAigNEi8KBmJhbm5lchgCIAIoCzIfLkQzLkFj" + 
          "Y291bnQuQmFubmVyQ29uZmlndXJhdGlvbiJ8ChdTYXZlQmFubmVyQ29uZmln" + 
          "dXJhdGlvbhIvCgZiYW5uZXIYASACKAsyHy5EMy5BY2NvdW50LkJhbm5lckNv" + 
          "bmZpZ3VyYXRpb24SFQoKc2xvdF9pbmRleBgCIAEoDToBMBIZCgttYWtlX2Fj" + 
          "dGl2ZRgDIAEoCDoEdHJ1ZSJpChBIZXJvRGlnZXN0QmFubmVyEiQKC2hlcm9f" + 
          "ZGlnZXN0GAEgAigLMg8uRDMuSGVyby5EaWdlc3QSLwoGYmFubmVyGAIgAigL" + 
          "Mh8uRDMuQWNjb3VudC5CYW5uZXJDb25maWd1cmF0aW9uIkcKEkdhbWVDdXJy" + 
          "ZW50UGxheWVycxIxCgdwbGF5ZXJzGAEgAygLMiAuRDMuR2FtZU1lc3NhZ2Uu" + 
          "SGVyb0RpZ2VzdEJhbm5lciJEChJBY2NvdW50VmVyc2lvbkxpc3QSLgoKYWNj" + 
          "b3VudF9pZBgBIAIoCzIaLkQzLk9ubGluZVNlcnZpY2UuRW50aXR5SWQiVQoS" + 
          "QWNjb3VudFZlcnNpb25TeW5jEi4KCmFjY291bnRfaWQYASACKAsyGi5EMy5P" + 
          "bmxpbmVTZXJ2aWNlLkVudGl0eUlkEg8KB3ZlcnNpb24YAiACKAQiQwoKVG9v" + 
          "bHRpcElkcxIOCgZsb2NhbGUYASACKA0SJQoDaWRzGAIgAygLMhguRDMuT25s" + 
          "aW5lU2VydmljZS5JdGVtSWQiRgoRVG9vbHRpcEdlbmVyYXRvcnMSDgoGbG9j" + 
          "YWxlGAEgAigNEiEKBWl0ZW1zGAIgAigLMhIuRDMuSXRlbXMuSXRlbUxpc3Qi" + 
          "PwoPVHV0b3JpYWxNZXNzYWdlEhQKDHR1dG9yaWFsX3NubxgBIAIoDRIWCg51" + 
          "aV9hbmNob3JfbmFtZRgCIAEoCSI+ChZTZXRBY2hpZXZlbWVudFNob3djYXNl" + 
          "EhYKDmFjaGlldmVtZW50X2lkGAEgAigEEgwKBHNsb3QYAiACKA0=");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_D3_GameMessage_HeroDigestList__Descriptor = Descriptor.MessageTypes[0];
        internal__static_D3_GameMessage_HeroDigestList__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.HeroDigestList, global::D3.GameMessage.HeroDigestList.Builder>(internal__static_D3_GameMessage_HeroDigestList__Descriptor,
                new string[] { "AccountId", "DigestList", });
        internal__static_D3_GameMessage_ClientToonSettings__Descriptor = Descriptor.MessageTypes[1];
        internal__static_D3_GameMessage_ClientToonSettings__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.ClientToonSettings, global::D3.GameMessage.ClientToonSettings.Builder>(internal__static_D3_GameMessage_ClientToonSettings__Descriptor,
                new string[] { "ToonId", "ClientToonSettings_", });
        internal__static_D3_GameMessage_HeroDigestListRequest__Descriptor = Descriptor.MessageTypes[2];
        internal__static_D3_GameMessage_HeroDigestListRequest__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.HeroDigestListRequest, global::D3.GameMessage.HeroDigestListRequest.Builder>(internal__static_D3_GameMessage_HeroDigestListRequest__Descriptor,
                new string[] { "ToonId", });
        internal__static_D3_GameMessage_HeroDigestResponse__Descriptor = Descriptor.MessageTypes[3];
        internal__static_D3_GameMessage_HeroDigestResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.HeroDigestResponse, global::D3.GameMessage.HeroDigestResponse.Builder>(internal__static_D3_GameMessage_HeroDigestResponse__Descriptor,
                new string[] { "ToonId", "Success", "HeroDigest", });
        internal__static_D3_GameMessage_HeroDigestListResponse__Descriptor = Descriptor.MessageTypes[4];
        internal__static_D3_GameMessage_HeroDigestListResponse__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.HeroDigestListResponse, global::D3.GameMessage.HeroDigestListResponse.Builder>(internal__static_D3_GameMessage_HeroDigestListResponse__Descriptor,
                new string[] { "DigestList", });
        internal__static_D3_GameMessage_PlayerBanner__Descriptor = Descriptor.MessageTypes[5];
        internal__static_D3_GameMessage_PlayerBanner__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.PlayerBanner, global::D3.GameMessage.PlayerBanner.Builder>(internal__static_D3_GameMessage_PlayerBanner__Descriptor,
                new string[] { "PlayerIndex", "Banner", });
        internal__static_D3_GameMessage_SaveBannerConfiguration__Descriptor = Descriptor.MessageTypes[6];
        internal__static_D3_GameMessage_SaveBannerConfiguration__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.SaveBannerConfiguration, global::D3.GameMessage.SaveBannerConfiguration.Builder>(internal__static_D3_GameMessage_SaveBannerConfiguration__Descriptor,
                new string[] { "Banner", "SlotIndex", "MakeActive", });
        internal__static_D3_GameMessage_HeroDigestBanner__Descriptor = Descriptor.MessageTypes[7];
        internal__static_D3_GameMessage_HeroDigestBanner__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.HeroDigestBanner, global::D3.GameMessage.HeroDigestBanner.Builder>(internal__static_D3_GameMessage_HeroDigestBanner__Descriptor,
                new string[] { "HeroDigest", "Banner", });
        internal__static_D3_GameMessage_GameCurrentPlayers__Descriptor = Descriptor.MessageTypes[8];
        internal__static_D3_GameMessage_GameCurrentPlayers__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.GameCurrentPlayers, global::D3.GameMessage.GameCurrentPlayers.Builder>(internal__static_D3_GameMessage_GameCurrentPlayers__Descriptor,
                new string[] { "Players", });
        internal__static_D3_GameMessage_AccountVersionList__Descriptor = Descriptor.MessageTypes[9];
        internal__static_D3_GameMessage_AccountVersionList__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.AccountVersionList, global::D3.GameMessage.AccountVersionList.Builder>(internal__static_D3_GameMessage_AccountVersionList__Descriptor,
                new string[] { "AccountId", });
        internal__static_D3_GameMessage_AccountVersionSync__Descriptor = Descriptor.MessageTypes[10];
        internal__static_D3_GameMessage_AccountVersionSync__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.AccountVersionSync, global::D3.GameMessage.AccountVersionSync.Builder>(internal__static_D3_GameMessage_AccountVersionSync__Descriptor,
                new string[] { "AccountId", "Version", });
        internal__static_D3_GameMessage_TooltipIds__Descriptor = Descriptor.MessageTypes[11];
        internal__static_D3_GameMessage_TooltipIds__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.TooltipIds, global::D3.GameMessage.TooltipIds.Builder>(internal__static_D3_GameMessage_TooltipIds__Descriptor,
                new string[] { "Locale", "Ids", });
        internal__static_D3_GameMessage_TooltipGenerators__Descriptor = Descriptor.MessageTypes[12];
        internal__static_D3_GameMessage_TooltipGenerators__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.TooltipGenerators, global::D3.GameMessage.TooltipGenerators.Builder>(internal__static_D3_GameMessage_TooltipGenerators__Descriptor,
                new string[] { "Locale", "Items", });
        internal__static_D3_GameMessage_TutorialMessage__Descriptor = Descriptor.MessageTypes[13];
        internal__static_D3_GameMessage_TutorialMessage__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.TutorialMessage, global::D3.GameMessage.TutorialMessage.Builder>(internal__static_D3_GameMessage_TutorialMessage__Descriptor,
                new string[] { "TutorialSno", "UiAnchorName", });
        internal__static_D3_GameMessage_SetAchievementShowcase__Descriptor = Descriptor.MessageTypes[14];
        internal__static_D3_GameMessage_SetAchievementShowcase__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::D3.GameMessage.SetAchievementShowcase, global::D3.GameMessage.SetAchievementShowcase.Builder>(internal__static_D3_GameMessage_SetAchievementShowcase__Descriptor,
                new string[] { "AchievementId", "Slot", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          global::D3.Hero.Hero.Descriptor, 
          global::D3.OnlineService.OnlineService.Descriptor, 
          global::D3.Client.Settings.Descriptor, 
          global::D3.Account.Account.Descriptor, 
          global::D3.Items.Items.Descriptor, 
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class HeroDigestList : pb::GeneratedMessage<HeroDigestList, HeroDigestList.Builder> {
    private HeroDigestList() { }
    private static readonly HeroDigestList defaultInstance = new HeroDigestList().MakeReadOnly();
    private static readonly string[] _heroDigestListFieldNames = new string[] { "account_id", "digest_list" };
    private static readonly uint[] _heroDigestListFieldTags = new uint[] { 10, 18 };
    public static HeroDigestList DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HeroDigestList DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HeroDigestList ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_HeroDigestList__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HeroDigestList, HeroDigestList.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_HeroDigestList__FieldAccessorTable; }
    }
    
    public const int AccountIdFieldNumber = 1;
    private bool hasAccountId;
    private global::D3.OnlineService.EntityId accountId_;
    public bool HasAccountId {
      get { return hasAccountId; }
    }
    public global::D3.OnlineService.EntityId AccountId {
      get { return accountId_ ?? global::D3.OnlineService.EntityId.DefaultInstance; }
    }
    
    public const int DigestListFieldNumber = 2;
    private pbc::PopsicleList<global::D3.Hero.Digest> digestList_ = new pbc::PopsicleList<global::D3.Hero.Digest>();
    public scg::IList<global::D3.Hero.Digest> DigestListList {
      get { return digestList_; }
    }
    public int DigestListCount {
      get { return digestList_.Count; }
    }
    public global::D3.Hero.Digest GetDigestList(int index) {
      return digestList_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasAccountId) return false;
        if (!AccountId.IsInitialized) return false;
        foreach (global::D3.Hero.Digest element in DigestListList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _heroDigestListFieldNames;
      if (hasAccountId) {
        output.WriteMessage(1, field_names[0], AccountId);
      }
      if (digestList_.Count > 0) {
        output.WriteMessageArray(2, field_names[1], digestList_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasAccountId) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, AccountId);
        }
        foreach (global::D3.Hero.Digest element in DigestListList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static HeroDigestList ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroDigestList ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestList ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroDigestList ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestList ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroDigestList ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestList ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HeroDigestList ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HeroDigestList ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroDigestList ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HeroDigestList MakeReadOnly() {
      digestList_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HeroDigestList prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<HeroDigestList, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HeroDigestList cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HeroDigestList result;
      
      private HeroDigestList PrepareBuilder() {
        if (resultIsReadOnly) {
          HeroDigestList original = result;
          result = new HeroDigestList();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HeroDigestList MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.HeroDigestList.Descriptor; }
      }
      
      public override HeroDigestList DefaultInstanceForType {
        get { return global::D3.GameMessage.HeroDigestList.DefaultInstance; }
      }
      
      public override HeroDigestList BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HeroDigestList) {
          return MergeFrom((HeroDigestList) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HeroDigestList other) {
        if (other == global::D3.GameMessage.HeroDigestList.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasAccountId) {
          MergeAccountId(other.AccountId);
        }
        if (other.digestList_.Count != 0) {
          result.digestList_.Add(other.digestList_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_heroDigestListFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _heroDigestListFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.OnlineService.EntityId.Builder subBuilder = global::D3.OnlineService.EntityId.CreateBuilder();
              if (result.hasAccountId) {
                subBuilder.MergeFrom(AccountId);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              AccountId = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.digestList_, global::D3.Hero.Digest.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasAccountId {
       get { return result.hasAccountId; }
      }
      public global::D3.OnlineService.EntityId AccountId {
        get { return result.AccountId; }
        set { SetAccountId(value); }
      }
      public Builder SetAccountId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAccountId = true;
        result.accountId_ = value;
        return this;
      }
      public Builder SetAccountId(global::D3.OnlineService.EntityId.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasAccountId = true;
        result.accountId_ = builderForValue.Build();
        return this;
      }
      public Builder MergeAccountId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasAccountId &&
            result.accountId_ != global::D3.OnlineService.EntityId.DefaultInstance) {
            result.accountId_ = global::D3.OnlineService.EntityId.CreateBuilder(result.accountId_).MergeFrom(value).BuildPartial();
        } else {
          result.accountId_ = value;
        }
        result.hasAccountId = true;
        return this;
      }
      public Builder ClearAccountId() {
        PrepareBuilder();
        result.hasAccountId = false;
        result.accountId_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.Hero.Digest> DigestListList {
        get { return PrepareBuilder().digestList_; }
      }
      public int DigestListCount {
        get { return result.DigestListCount; }
      }
      public global::D3.Hero.Digest GetDigestList(int index) {
        return result.GetDigestList(index);
      }
      public Builder SetDigestList(int index, global::D3.Hero.Digest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.digestList_[index] = value;
        return this;
      }
      public Builder SetDigestList(int index, global::D3.Hero.Digest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.digestList_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddDigestList(global::D3.Hero.Digest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.digestList_.Add(value);
        return this;
      }
      public Builder AddDigestList(global::D3.Hero.Digest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.digestList_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeDigestList(scg::IEnumerable<global::D3.Hero.Digest> values) {
        PrepareBuilder();
        result.digestList_.Add(values);
        return this;
      }
      public Builder ClearDigestList() {
        PrepareBuilder();
        result.digestList_.Clear();
        return this;
      }
    }
    static HeroDigestList() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class ClientToonSettings : pb::GeneratedMessage<ClientToonSettings, ClientToonSettings.Builder> {
    private ClientToonSettings() { }
    private static readonly ClientToonSettings defaultInstance = new ClientToonSettings().MakeReadOnly();
    private static readonly string[] _clientToonSettingsFieldNames = new string[] { "client_toon_settings", "toon_id" };
    private static readonly uint[] _clientToonSettingsFieldTags = new uint[] { 18, 10 };
    public static ClientToonSettings DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override ClientToonSettings DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override ClientToonSettings ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_ClientToonSettings__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<ClientToonSettings, ClientToonSettings.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_ClientToonSettings__FieldAccessorTable; }
    }
    
    public const int ToonIdFieldNumber = 1;
    private bool hasToonId;
    private global::D3.OnlineService.EntityId toonId_;
    public bool HasToonId {
      get { return hasToonId; }
    }
    public global::D3.OnlineService.EntityId ToonId {
      get { return toonId_ ?? global::D3.OnlineService.EntityId.DefaultInstance; }
    }
    
    public const int ClientToonSettings_FieldNumber = 2;
    private bool hasClientToonSettings_;
    private global::D3.Client.ToonSettings clientToonSettings_;
    public bool HasClientToonSettings_ {
      get { return hasClientToonSettings_; }
    }
    public global::D3.Client.ToonSettings ClientToonSettings_ {
      get { return clientToonSettings_ ?? global::D3.Client.ToonSettings.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasToonId) return false;
        if (!hasClientToonSettings_) return false;
        if (!ToonId.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _clientToonSettingsFieldNames;
      if (hasToonId) {
        output.WriteMessage(1, field_names[1], ToonId);
      }
      if (hasClientToonSettings_) {
        output.WriteMessage(2, field_names[0], ClientToonSettings_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasToonId) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, ToonId);
        }
        if (hasClientToonSettings_) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, ClientToonSettings_);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static ClientToonSettings ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ClientToonSettings ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ClientToonSettings ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static ClientToonSettings ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static ClientToonSettings ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ClientToonSettings ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static ClientToonSettings ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static ClientToonSettings ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static ClientToonSettings ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static ClientToonSettings ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private ClientToonSettings MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(ClientToonSettings prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<ClientToonSettings, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(ClientToonSettings cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private ClientToonSettings result;
      
      private ClientToonSettings PrepareBuilder() {
        if (resultIsReadOnly) {
          ClientToonSettings original = result;
          result = new ClientToonSettings();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override ClientToonSettings MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.ClientToonSettings.Descriptor; }
      }
      
      public override ClientToonSettings DefaultInstanceForType {
        get { return global::D3.GameMessage.ClientToonSettings.DefaultInstance; }
      }
      
      public override ClientToonSettings BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is ClientToonSettings) {
          return MergeFrom((ClientToonSettings) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(ClientToonSettings other) {
        if (other == global::D3.GameMessage.ClientToonSettings.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasToonId) {
          MergeToonId(other.ToonId);
        }
        if (other.HasClientToonSettings_) {
          MergeClientToonSettings_(other.ClientToonSettings_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_clientToonSettingsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _clientToonSettingsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.OnlineService.EntityId.Builder subBuilder = global::D3.OnlineService.EntityId.CreateBuilder();
              if (result.hasToonId) {
                subBuilder.MergeFrom(ToonId);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ToonId = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::D3.Client.ToonSettings.Builder subBuilder = global::D3.Client.ToonSettings.CreateBuilder();
              if (result.hasClientToonSettings_) {
                subBuilder.MergeFrom(ClientToonSettings_);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ClientToonSettings_ = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasToonId {
       get { return result.hasToonId; }
      }
      public global::D3.OnlineService.EntityId ToonId {
        get { return result.ToonId; }
        set { SetToonId(value); }
      }
      public Builder SetToonId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasToonId = true;
        result.toonId_ = value;
        return this;
      }
      public Builder SetToonId(global::D3.OnlineService.EntityId.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasToonId = true;
        result.toonId_ = builderForValue.Build();
        return this;
      }
      public Builder MergeToonId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasToonId &&
            result.toonId_ != global::D3.OnlineService.EntityId.DefaultInstance) {
            result.toonId_ = global::D3.OnlineService.EntityId.CreateBuilder(result.toonId_).MergeFrom(value).BuildPartial();
        } else {
          result.toonId_ = value;
        }
        result.hasToonId = true;
        return this;
      }
      public Builder ClearToonId() {
        PrepareBuilder();
        result.hasToonId = false;
        result.toonId_ = null;
        return this;
      }
      
      public bool HasClientToonSettings_ {
       get { return result.hasClientToonSettings_; }
      }
      public global::D3.Client.ToonSettings ClientToonSettings_ {
        get { return result.ClientToonSettings_; }
        set { SetClientToonSettings_(value); }
      }
      public Builder SetClientToonSettings_(global::D3.Client.ToonSettings value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasClientToonSettings_ = true;
        result.clientToonSettings_ = value;
        return this;
      }
      public Builder SetClientToonSettings_(global::D3.Client.ToonSettings.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasClientToonSettings_ = true;
        result.clientToonSettings_ = builderForValue.Build();
        return this;
      }
      public Builder MergeClientToonSettings_(global::D3.Client.ToonSettings value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasClientToonSettings_ &&
            result.clientToonSettings_ != global::D3.Client.ToonSettings.DefaultInstance) {
            result.clientToonSettings_ = global::D3.Client.ToonSettings.CreateBuilder(result.clientToonSettings_).MergeFrom(value).BuildPartial();
        } else {
          result.clientToonSettings_ = value;
        }
        result.hasClientToonSettings_ = true;
        return this;
      }
      public Builder ClearClientToonSettings_() {
        PrepareBuilder();
        result.hasClientToonSettings_ = false;
        result.clientToonSettings_ = null;
        return this;
      }
    }
    static ClientToonSettings() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class HeroDigestListRequest : pb::GeneratedMessage<HeroDigestListRequest, HeroDigestListRequest.Builder> {
    private HeroDigestListRequest() { }
    private static readonly HeroDigestListRequest defaultInstance = new HeroDigestListRequest().MakeReadOnly();
    private static readonly string[] _heroDigestListRequestFieldNames = new string[] { "toon_id" };
    private static readonly uint[] _heroDigestListRequestFieldTags = new uint[] { 10 };
    public static HeroDigestListRequest DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HeroDigestListRequest DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HeroDigestListRequest ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_HeroDigestListRequest__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HeroDigestListRequest, HeroDigestListRequest.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_HeroDigestListRequest__FieldAccessorTable; }
    }
    
    public const int ToonIdFieldNumber = 1;
    private pbc::PopsicleList<global::D3.OnlineService.EntityId> toonId_ = new pbc::PopsicleList<global::D3.OnlineService.EntityId>();
    public scg::IList<global::D3.OnlineService.EntityId> ToonIdList {
      get { return toonId_; }
    }
    public int ToonIdCount {
      get { return toonId_.Count; }
    }
    public global::D3.OnlineService.EntityId GetToonId(int index) {
      return toonId_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::D3.OnlineService.EntityId element in ToonIdList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _heroDigestListRequestFieldNames;
      if (toonId_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], toonId_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.OnlineService.EntityId element in ToonIdList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static HeroDigestListRequest ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroDigestListRequest ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestListRequest ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroDigestListRequest ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestListRequest ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroDigestListRequest ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestListRequest ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HeroDigestListRequest ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HeroDigestListRequest ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroDigestListRequest ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HeroDigestListRequest MakeReadOnly() {
      toonId_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HeroDigestListRequest prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<HeroDigestListRequest, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HeroDigestListRequest cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HeroDigestListRequest result;
      
      private HeroDigestListRequest PrepareBuilder() {
        if (resultIsReadOnly) {
          HeroDigestListRequest original = result;
          result = new HeroDigestListRequest();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HeroDigestListRequest MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.HeroDigestListRequest.Descriptor; }
      }
      
      public override HeroDigestListRequest DefaultInstanceForType {
        get { return global::D3.GameMessage.HeroDigestListRequest.DefaultInstance; }
      }
      
      public override HeroDigestListRequest BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HeroDigestListRequest) {
          return MergeFrom((HeroDigestListRequest) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HeroDigestListRequest other) {
        if (other == global::D3.GameMessage.HeroDigestListRequest.DefaultInstance) return this;
        PrepareBuilder();
        if (other.toonId_.Count != 0) {
          result.toonId_.Add(other.toonId_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_heroDigestListRequestFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _heroDigestListRequestFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.toonId_, global::D3.OnlineService.EntityId.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.OnlineService.EntityId> ToonIdList {
        get { return PrepareBuilder().toonId_; }
      }
      public int ToonIdCount {
        get { return result.ToonIdCount; }
      }
      public global::D3.OnlineService.EntityId GetToonId(int index) {
        return result.GetToonId(index);
      }
      public Builder SetToonId(int index, global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.toonId_[index] = value;
        return this;
      }
      public Builder SetToonId(int index, global::D3.OnlineService.EntityId.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.toonId_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddToonId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.toonId_.Add(value);
        return this;
      }
      public Builder AddToonId(global::D3.OnlineService.EntityId.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.toonId_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeToonId(scg::IEnumerable<global::D3.OnlineService.EntityId> values) {
        PrepareBuilder();
        result.toonId_.Add(values);
        return this;
      }
      public Builder ClearToonId() {
        PrepareBuilder();
        result.toonId_.Clear();
        return this;
      }
    }
    static HeroDigestListRequest() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class HeroDigestResponse : pb::GeneratedMessage<HeroDigestResponse, HeroDigestResponse.Builder> {
    private HeroDigestResponse() { }
    private static readonly HeroDigestResponse defaultInstance = new HeroDigestResponse().MakeReadOnly();
    private static readonly string[] _heroDigestResponseFieldNames = new string[] { "hero_digest", "success", "toon_id" };
    private static readonly uint[] _heroDigestResponseFieldTags = new uint[] { 26, 16, 10 };
    public static HeroDigestResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HeroDigestResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HeroDigestResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_HeroDigestResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HeroDigestResponse, HeroDigestResponse.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_HeroDigestResponse__FieldAccessorTable; }
    }
    
    public const int ToonIdFieldNumber = 1;
    private bool hasToonId;
    private global::D3.OnlineService.EntityId toonId_;
    public bool HasToonId {
      get { return hasToonId; }
    }
    public global::D3.OnlineService.EntityId ToonId {
      get { return toonId_ ?? global::D3.OnlineService.EntityId.DefaultInstance; }
    }
    
    public const int SuccessFieldNumber = 2;
    private bool hasSuccess;
    private bool success_;
    public bool HasSuccess {
      get { return hasSuccess; }
    }
    public bool Success {
      get { return success_; }
    }
    
    public const int HeroDigestFieldNumber = 3;
    private bool hasHeroDigest;
    private global::D3.Hero.Digest heroDigest_;
    public bool HasHeroDigest {
      get { return hasHeroDigest; }
    }
    public global::D3.Hero.Digest HeroDigest {
      get { return heroDigest_ ?? global::D3.Hero.Digest.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasToonId) return false;
        if (!hasSuccess) return false;
        if (!ToonId.IsInitialized) return false;
        if (HasHeroDigest) {
          if (!HeroDigest.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _heroDigestResponseFieldNames;
      if (hasToonId) {
        output.WriteMessage(1, field_names[2], ToonId);
      }
      if (hasSuccess) {
        output.WriteBool(2, field_names[1], Success);
      }
      if (hasHeroDigest) {
        output.WriteMessage(3, field_names[0], HeroDigest);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasToonId) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, ToonId);
        }
        if (hasSuccess) {
          size += pb::CodedOutputStream.ComputeBoolSize(2, Success);
        }
        if (hasHeroDigest) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, HeroDigest);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static HeroDigestResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroDigestResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroDigestResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroDigestResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HeroDigestResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HeroDigestResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroDigestResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HeroDigestResponse MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HeroDigestResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<HeroDigestResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HeroDigestResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HeroDigestResponse result;
      
      private HeroDigestResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          HeroDigestResponse original = result;
          result = new HeroDigestResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HeroDigestResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.HeroDigestResponse.Descriptor; }
      }
      
      public override HeroDigestResponse DefaultInstanceForType {
        get { return global::D3.GameMessage.HeroDigestResponse.DefaultInstance; }
      }
      
      public override HeroDigestResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HeroDigestResponse) {
          return MergeFrom((HeroDigestResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HeroDigestResponse other) {
        if (other == global::D3.GameMessage.HeroDigestResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasToonId) {
          MergeToonId(other.ToonId);
        }
        if (other.HasSuccess) {
          Success = other.Success;
        }
        if (other.HasHeroDigest) {
          MergeHeroDigest(other.HeroDigest);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_heroDigestResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _heroDigestResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.OnlineService.EntityId.Builder subBuilder = global::D3.OnlineService.EntityId.CreateBuilder();
              if (result.hasToonId) {
                subBuilder.MergeFrom(ToonId);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ToonId = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              result.hasSuccess = input.ReadBool(ref result.success_);
              break;
            }
            case 26: {
              global::D3.Hero.Digest.Builder subBuilder = global::D3.Hero.Digest.CreateBuilder();
              if (result.hasHeroDigest) {
                subBuilder.MergeFrom(HeroDigest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              HeroDigest = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasToonId {
       get { return result.hasToonId; }
      }
      public global::D3.OnlineService.EntityId ToonId {
        get { return result.ToonId; }
        set { SetToonId(value); }
      }
      public Builder SetToonId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasToonId = true;
        result.toonId_ = value;
        return this;
      }
      public Builder SetToonId(global::D3.OnlineService.EntityId.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasToonId = true;
        result.toonId_ = builderForValue.Build();
        return this;
      }
      public Builder MergeToonId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasToonId &&
            result.toonId_ != global::D3.OnlineService.EntityId.DefaultInstance) {
            result.toonId_ = global::D3.OnlineService.EntityId.CreateBuilder(result.toonId_).MergeFrom(value).BuildPartial();
        } else {
          result.toonId_ = value;
        }
        result.hasToonId = true;
        return this;
      }
      public Builder ClearToonId() {
        PrepareBuilder();
        result.hasToonId = false;
        result.toonId_ = null;
        return this;
      }
      
      public bool HasSuccess {
        get { return result.hasSuccess; }
      }
      public bool Success {
        get { return result.Success; }
        set { SetSuccess(value); }
      }
      public Builder SetSuccess(bool value) {
        PrepareBuilder();
        result.hasSuccess = true;
        result.success_ = value;
        return this;
      }
      public Builder ClearSuccess() {
        PrepareBuilder();
        result.hasSuccess = false;
        result.success_ = false;
        return this;
      }
      
      public bool HasHeroDigest {
       get { return result.hasHeroDigest; }
      }
      public global::D3.Hero.Digest HeroDigest {
        get { return result.HeroDigest; }
        set { SetHeroDigest(value); }
      }
      public Builder SetHeroDigest(global::D3.Hero.Digest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHeroDigest = true;
        result.heroDigest_ = value;
        return this;
      }
      public Builder SetHeroDigest(global::D3.Hero.Digest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHeroDigest = true;
        result.heroDigest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHeroDigest(global::D3.Hero.Digest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasHeroDigest &&
            result.heroDigest_ != global::D3.Hero.Digest.DefaultInstance) {
            result.heroDigest_ = global::D3.Hero.Digest.CreateBuilder(result.heroDigest_).MergeFrom(value).BuildPartial();
        } else {
          result.heroDigest_ = value;
        }
        result.hasHeroDigest = true;
        return this;
      }
      public Builder ClearHeroDigest() {
        PrepareBuilder();
        result.hasHeroDigest = false;
        result.heroDigest_ = null;
        return this;
      }
    }
    static HeroDigestResponse() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class HeroDigestListResponse : pb::GeneratedMessage<HeroDigestListResponse, HeroDigestListResponse.Builder> {
    private HeroDigestListResponse() { }
    private static readonly HeroDigestListResponse defaultInstance = new HeroDigestListResponse().MakeReadOnly();
    private static readonly string[] _heroDigestListResponseFieldNames = new string[] { "digest_list" };
    private static readonly uint[] _heroDigestListResponseFieldTags = new uint[] { 10 };
    public static HeroDigestListResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HeroDigestListResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HeroDigestListResponse ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_HeroDigestListResponse__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HeroDigestListResponse, HeroDigestListResponse.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_HeroDigestListResponse__FieldAccessorTable; }
    }
    
    public const int DigestListFieldNumber = 1;
    private pbc::PopsicleList<global::D3.GameMessage.HeroDigestResponse> digestList_ = new pbc::PopsicleList<global::D3.GameMessage.HeroDigestResponse>();
    public scg::IList<global::D3.GameMessage.HeroDigestResponse> DigestListList {
      get { return digestList_; }
    }
    public int DigestListCount {
      get { return digestList_.Count; }
    }
    public global::D3.GameMessage.HeroDigestResponse GetDigestList(int index) {
      return digestList_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::D3.GameMessage.HeroDigestResponse element in DigestListList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _heroDigestListResponseFieldNames;
      if (digestList_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], digestList_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.GameMessage.HeroDigestResponse element in DigestListList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static HeroDigestListResponse ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroDigestListResponse ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestListResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroDigestListResponse ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestListResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroDigestListResponse ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestListResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HeroDigestListResponse ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HeroDigestListResponse ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroDigestListResponse ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HeroDigestListResponse MakeReadOnly() {
      digestList_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HeroDigestListResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<HeroDigestListResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HeroDigestListResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HeroDigestListResponse result;
      
      private HeroDigestListResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          HeroDigestListResponse original = result;
          result = new HeroDigestListResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HeroDigestListResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.HeroDigestListResponse.Descriptor; }
      }
      
      public override HeroDigestListResponse DefaultInstanceForType {
        get { return global::D3.GameMessage.HeroDigestListResponse.DefaultInstance; }
      }
      
      public override HeroDigestListResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HeroDigestListResponse) {
          return MergeFrom((HeroDigestListResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HeroDigestListResponse other) {
        if (other == global::D3.GameMessage.HeroDigestListResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.digestList_.Count != 0) {
          result.digestList_.Add(other.digestList_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_heroDigestListResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _heroDigestListResponseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.digestList_, global::D3.GameMessage.HeroDigestResponse.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.GameMessage.HeroDigestResponse> DigestListList {
        get { return PrepareBuilder().digestList_; }
      }
      public int DigestListCount {
        get { return result.DigestListCount; }
      }
      public global::D3.GameMessage.HeroDigestResponse GetDigestList(int index) {
        return result.GetDigestList(index);
      }
      public Builder SetDigestList(int index, global::D3.GameMessage.HeroDigestResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.digestList_[index] = value;
        return this;
      }
      public Builder SetDigestList(int index, global::D3.GameMessage.HeroDigestResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.digestList_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddDigestList(global::D3.GameMessage.HeroDigestResponse value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.digestList_.Add(value);
        return this;
      }
      public Builder AddDigestList(global::D3.GameMessage.HeroDigestResponse.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.digestList_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeDigestList(scg::IEnumerable<global::D3.GameMessage.HeroDigestResponse> values) {
        PrepareBuilder();
        result.digestList_.Add(values);
        return this;
      }
      public Builder ClearDigestList() {
        PrepareBuilder();
        result.digestList_.Clear();
        return this;
      }
    }
    static HeroDigestListResponse() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class PlayerBanner : pb::GeneratedMessage<PlayerBanner, PlayerBanner.Builder> {
    private PlayerBanner() { }
    private static readonly PlayerBanner defaultInstance = new PlayerBanner().MakeReadOnly();
    private static readonly string[] _playerBannerFieldNames = new string[] { "banner", "player_index" };
    private static readonly uint[] _playerBannerFieldTags = new uint[] { 18, 8 };
    public static PlayerBanner DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PlayerBanner DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PlayerBanner ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_PlayerBanner__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PlayerBanner, PlayerBanner.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_PlayerBanner__FieldAccessorTable; }
    }
    
    public const int PlayerIndexFieldNumber = 1;
    private bool hasPlayerIndex;
    private uint playerIndex_;
    public bool HasPlayerIndex {
      get { return hasPlayerIndex; }
    }
    public uint PlayerIndex {
      get { return playerIndex_; }
    }
    
    public const int BannerFieldNumber = 2;
    private bool hasBanner;
    private global::D3.Account.BannerConfiguration banner_;
    public bool HasBanner {
      get { return hasBanner; }
    }
    public global::D3.Account.BannerConfiguration Banner {
      get { return banner_ ?? global::D3.Account.BannerConfiguration.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasPlayerIndex) return false;
        if (!hasBanner) return false;
        if (!Banner.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _playerBannerFieldNames;
      if (hasPlayerIndex) {
        output.WriteUInt32(1, field_names[1], PlayerIndex);
      }
      if (hasBanner) {
        output.WriteMessage(2, field_names[0], Banner);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasPlayerIndex) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, PlayerIndex);
        }
        if (hasBanner) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Banner);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PlayerBanner ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PlayerBanner ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PlayerBanner ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PlayerBanner ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PlayerBanner ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PlayerBanner ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PlayerBanner ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PlayerBanner ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PlayerBanner ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PlayerBanner ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PlayerBanner MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PlayerBanner prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<PlayerBanner, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PlayerBanner cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PlayerBanner result;
      
      private PlayerBanner PrepareBuilder() {
        if (resultIsReadOnly) {
          PlayerBanner original = result;
          result = new PlayerBanner();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PlayerBanner MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.PlayerBanner.Descriptor; }
      }
      
      public override PlayerBanner DefaultInstanceForType {
        get { return global::D3.GameMessage.PlayerBanner.DefaultInstance; }
      }
      
      public override PlayerBanner BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PlayerBanner) {
          return MergeFrom((PlayerBanner) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PlayerBanner other) {
        if (other == global::D3.GameMessage.PlayerBanner.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasPlayerIndex) {
          PlayerIndex = other.PlayerIndex;
        }
        if (other.HasBanner) {
          MergeBanner(other.Banner);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_playerBannerFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _playerBannerFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasPlayerIndex = input.ReadUInt32(ref result.playerIndex_);
              break;
            }
            case 18: {
              global::D3.Account.BannerConfiguration.Builder subBuilder = global::D3.Account.BannerConfiguration.CreateBuilder();
              if (result.hasBanner) {
                subBuilder.MergeFrom(Banner);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Banner = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasPlayerIndex {
        get { return result.hasPlayerIndex; }
      }
      public uint PlayerIndex {
        get { return result.PlayerIndex; }
        set { SetPlayerIndex(value); }
      }
      public Builder SetPlayerIndex(uint value) {
        PrepareBuilder();
        result.hasPlayerIndex = true;
        result.playerIndex_ = value;
        return this;
      }
      public Builder ClearPlayerIndex() {
        PrepareBuilder();
        result.hasPlayerIndex = false;
        result.playerIndex_ = 0;
        return this;
      }
      
      public bool HasBanner {
       get { return result.hasBanner; }
      }
      public global::D3.Account.BannerConfiguration Banner {
        get { return result.Banner; }
        set { SetBanner(value); }
      }
      public Builder SetBanner(global::D3.Account.BannerConfiguration value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBanner = true;
        result.banner_ = value;
        return this;
      }
      public Builder SetBanner(global::D3.Account.BannerConfiguration.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBanner = true;
        result.banner_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBanner(global::D3.Account.BannerConfiguration value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasBanner &&
            result.banner_ != global::D3.Account.BannerConfiguration.DefaultInstance) {
            result.banner_ = global::D3.Account.BannerConfiguration.CreateBuilder(result.banner_).MergeFrom(value).BuildPartial();
        } else {
          result.banner_ = value;
        }
        result.hasBanner = true;
        return this;
      }
      public Builder ClearBanner() {
        PrepareBuilder();
        result.hasBanner = false;
        result.banner_ = null;
        return this;
      }
    }
    static PlayerBanner() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class SaveBannerConfiguration : pb::GeneratedMessage<SaveBannerConfiguration, SaveBannerConfiguration.Builder> {
    private SaveBannerConfiguration() { }
    private static readonly SaveBannerConfiguration defaultInstance = new SaveBannerConfiguration().MakeReadOnly();
    private static readonly string[] _saveBannerConfigurationFieldNames = new string[] { "banner", "make_active", "slot_index" };
    private static readonly uint[] _saveBannerConfigurationFieldTags = new uint[] { 10, 24, 16 };
    public static SaveBannerConfiguration DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SaveBannerConfiguration DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SaveBannerConfiguration ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_SaveBannerConfiguration__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SaveBannerConfiguration, SaveBannerConfiguration.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_SaveBannerConfiguration__FieldAccessorTable; }
    }
    
    public const int BannerFieldNumber = 1;
    private bool hasBanner;
    private global::D3.Account.BannerConfiguration banner_;
    public bool HasBanner {
      get { return hasBanner; }
    }
    public global::D3.Account.BannerConfiguration Banner {
      get { return banner_ ?? global::D3.Account.BannerConfiguration.DefaultInstance; }
    }
    
    public const int SlotIndexFieldNumber = 2;
    private bool hasSlotIndex;
    private uint slotIndex_;
    public bool HasSlotIndex {
      get { return hasSlotIndex; }
    }
    public uint SlotIndex {
      get { return slotIndex_; }
    }
    
    public const int MakeActiveFieldNumber = 3;
    private bool hasMakeActive;
    private bool makeActive_ = true;
    public bool HasMakeActive {
      get { return hasMakeActive; }
    }
    public bool MakeActive {
      get { return makeActive_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasBanner) return false;
        if (!Banner.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _saveBannerConfigurationFieldNames;
      if (hasBanner) {
        output.WriteMessage(1, field_names[0], Banner);
      }
      if (hasSlotIndex) {
        output.WriteUInt32(2, field_names[2], SlotIndex);
      }
      if (hasMakeActive) {
        output.WriteBool(3, field_names[1], MakeActive);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBanner) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Banner);
        }
        if (hasSlotIndex) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, SlotIndex);
        }
        if (hasMakeActive) {
          size += pb::CodedOutputStream.ComputeBoolSize(3, MakeActive);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SaveBannerConfiguration ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SaveBannerConfiguration ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SaveBannerConfiguration ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SaveBannerConfiguration ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SaveBannerConfiguration ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SaveBannerConfiguration ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SaveBannerConfiguration ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SaveBannerConfiguration ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SaveBannerConfiguration ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SaveBannerConfiguration ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SaveBannerConfiguration MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SaveBannerConfiguration prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<SaveBannerConfiguration, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SaveBannerConfiguration cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SaveBannerConfiguration result;
      
      private SaveBannerConfiguration PrepareBuilder() {
        if (resultIsReadOnly) {
          SaveBannerConfiguration original = result;
          result = new SaveBannerConfiguration();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SaveBannerConfiguration MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.SaveBannerConfiguration.Descriptor; }
      }
      
      public override SaveBannerConfiguration DefaultInstanceForType {
        get { return global::D3.GameMessage.SaveBannerConfiguration.DefaultInstance; }
      }
      
      public override SaveBannerConfiguration BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SaveBannerConfiguration) {
          return MergeFrom((SaveBannerConfiguration) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SaveBannerConfiguration other) {
        if (other == global::D3.GameMessage.SaveBannerConfiguration.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBanner) {
          MergeBanner(other.Banner);
        }
        if (other.HasSlotIndex) {
          SlotIndex = other.SlotIndex;
        }
        if (other.HasMakeActive) {
          MakeActive = other.MakeActive;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_saveBannerConfigurationFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _saveBannerConfigurationFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Account.BannerConfiguration.Builder subBuilder = global::D3.Account.BannerConfiguration.CreateBuilder();
              if (result.hasBanner) {
                subBuilder.MergeFrom(Banner);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Banner = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              result.hasSlotIndex = input.ReadUInt32(ref result.slotIndex_);
              break;
            }
            case 24: {
              result.hasMakeActive = input.ReadBool(ref result.makeActive_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasBanner {
       get { return result.hasBanner; }
      }
      public global::D3.Account.BannerConfiguration Banner {
        get { return result.Banner; }
        set { SetBanner(value); }
      }
      public Builder SetBanner(global::D3.Account.BannerConfiguration value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBanner = true;
        result.banner_ = value;
        return this;
      }
      public Builder SetBanner(global::D3.Account.BannerConfiguration.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBanner = true;
        result.banner_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBanner(global::D3.Account.BannerConfiguration value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasBanner &&
            result.banner_ != global::D3.Account.BannerConfiguration.DefaultInstance) {
            result.banner_ = global::D3.Account.BannerConfiguration.CreateBuilder(result.banner_).MergeFrom(value).BuildPartial();
        } else {
          result.banner_ = value;
        }
        result.hasBanner = true;
        return this;
      }
      public Builder ClearBanner() {
        PrepareBuilder();
        result.hasBanner = false;
        result.banner_ = null;
        return this;
      }
      
      public bool HasSlotIndex {
        get { return result.hasSlotIndex; }
      }
      public uint SlotIndex {
        get { return result.SlotIndex; }
        set { SetSlotIndex(value); }
      }
      public Builder SetSlotIndex(uint value) {
        PrepareBuilder();
        result.hasSlotIndex = true;
        result.slotIndex_ = value;
        return this;
      }
      public Builder ClearSlotIndex() {
        PrepareBuilder();
        result.hasSlotIndex = false;
        result.slotIndex_ = 0;
        return this;
      }
      
      public bool HasMakeActive {
        get { return result.hasMakeActive; }
      }
      public bool MakeActive {
        get { return result.MakeActive; }
        set { SetMakeActive(value); }
      }
      public Builder SetMakeActive(bool value) {
        PrepareBuilder();
        result.hasMakeActive = true;
        result.makeActive_ = value;
        return this;
      }
      public Builder ClearMakeActive() {
        PrepareBuilder();
        result.hasMakeActive = false;
        result.makeActive_ = true;
        return this;
      }
    }
    static SaveBannerConfiguration() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class HeroDigestBanner : pb::GeneratedMessage<HeroDigestBanner, HeroDigestBanner.Builder> {
    private HeroDigestBanner() { }
    private static readonly HeroDigestBanner defaultInstance = new HeroDigestBanner().MakeReadOnly();
    private static readonly string[] _heroDigestBannerFieldNames = new string[] { "banner", "hero_digest" };
    private static readonly uint[] _heroDigestBannerFieldTags = new uint[] { 18, 10 };
    public static HeroDigestBanner DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override HeroDigestBanner DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override HeroDigestBanner ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_HeroDigestBanner__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<HeroDigestBanner, HeroDigestBanner.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_HeroDigestBanner__FieldAccessorTable; }
    }
    
    public const int HeroDigestFieldNumber = 1;
    private bool hasHeroDigest;
    private global::D3.Hero.Digest heroDigest_;
    public bool HasHeroDigest {
      get { return hasHeroDigest; }
    }
    public global::D3.Hero.Digest HeroDigest {
      get { return heroDigest_ ?? global::D3.Hero.Digest.DefaultInstance; }
    }
    
    public const int BannerFieldNumber = 2;
    private bool hasBanner;
    private global::D3.Account.BannerConfiguration banner_;
    public bool HasBanner {
      get { return hasBanner; }
    }
    public global::D3.Account.BannerConfiguration Banner {
      get { return banner_ ?? global::D3.Account.BannerConfiguration.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasHeroDigest) return false;
        if (!hasBanner) return false;
        if (!HeroDigest.IsInitialized) return false;
        if (!Banner.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _heroDigestBannerFieldNames;
      if (hasHeroDigest) {
        output.WriteMessage(1, field_names[1], HeroDigest);
      }
      if (hasBanner) {
        output.WriteMessage(2, field_names[0], Banner);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasHeroDigest) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, HeroDigest);
        }
        if (hasBanner) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Banner);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static HeroDigestBanner ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroDigestBanner ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestBanner ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static HeroDigestBanner ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestBanner ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroDigestBanner ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static HeroDigestBanner ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static HeroDigestBanner ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static HeroDigestBanner ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static HeroDigestBanner ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private HeroDigestBanner MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(HeroDigestBanner prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<HeroDigestBanner, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(HeroDigestBanner cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private HeroDigestBanner result;
      
      private HeroDigestBanner PrepareBuilder() {
        if (resultIsReadOnly) {
          HeroDigestBanner original = result;
          result = new HeroDigestBanner();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override HeroDigestBanner MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.HeroDigestBanner.Descriptor; }
      }
      
      public override HeroDigestBanner DefaultInstanceForType {
        get { return global::D3.GameMessage.HeroDigestBanner.DefaultInstance; }
      }
      
      public override HeroDigestBanner BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is HeroDigestBanner) {
          return MergeFrom((HeroDigestBanner) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(HeroDigestBanner other) {
        if (other == global::D3.GameMessage.HeroDigestBanner.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasHeroDigest) {
          MergeHeroDigest(other.HeroDigest);
        }
        if (other.HasBanner) {
          MergeBanner(other.Banner);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_heroDigestBannerFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _heroDigestBannerFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.Hero.Digest.Builder subBuilder = global::D3.Hero.Digest.CreateBuilder();
              if (result.hasHeroDigest) {
                subBuilder.MergeFrom(HeroDigest);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              HeroDigest = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::D3.Account.BannerConfiguration.Builder subBuilder = global::D3.Account.BannerConfiguration.CreateBuilder();
              if (result.hasBanner) {
                subBuilder.MergeFrom(Banner);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Banner = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasHeroDigest {
       get { return result.hasHeroDigest; }
      }
      public global::D3.Hero.Digest HeroDigest {
        get { return result.HeroDigest; }
        set { SetHeroDigest(value); }
      }
      public Builder SetHeroDigest(global::D3.Hero.Digest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHeroDigest = true;
        result.heroDigest_ = value;
        return this;
      }
      public Builder SetHeroDigest(global::D3.Hero.Digest.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHeroDigest = true;
        result.heroDigest_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHeroDigest(global::D3.Hero.Digest value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasHeroDigest &&
            result.heroDigest_ != global::D3.Hero.Digest.DefaultInstance) {
            result.heroDigest_ = global::D3.Hero.Digest.CreateBuilder(result.heroDigest_).MergeFrom(value).BuildPartial();
        } else {
          result.heroDigest_ = value;
        }
        result.hasHeroDigest = true;
        return this;
      }
      public Builder ClearHeroDigest() {
        PrepareBuilder();
        result.hasHeroDigest = false;
        result.heroDigest_ = null;
        return this;
      }
      
      public bool HasBanner {
       get { return result.hasBanner; }
      }
      public global::D3.Account.BannerConfiguration Banner {
        get { return result.Banner; }
        set { SetBanner(value); }
      }
      public Builder SetBanner(global::D3.Account.BannerConfiguration value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBanner = true;
        result.banner_ = value;
        return this;
      }
      public Builder SetBanner(global::D3.Account.BannerConfiguration.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBanner = true;
        result.banner_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBanner(global::D3.Account.BannerConfiguration value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasBanner &&
            result.banner_ != global::D3.Account.BannerConfiguration.DefaultInstance) {
            result.banner_ = global::D3.Account.BannerConfiguration.CreateBuilder(result.banner_).MergeFrom(value).BuildPartial();
        } else {
          result.banner_ = value;
        }
        result.hasBanner = true;
        return this;
      }
      public Builder ClearBanner() {
        PrepareBuilder();
        result.hasBanner = false;
        result.banner_ = null;
        return this;
      }
    }
    static HeroDigestBanner() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GameCurrentPlayers : pb::GeneratedMessage<GameCurrentPlayers, GameCurrentPlayers.Builder> {
    private GameCurrentPlayers() { }
    private static readonly GameCurrentPlayers defaultInstance = new GameCurrentPlayers().MakeReadOnly();
    private static readonly string[] _gameCurrentPlayersFieldNames = new string[] { "players" };
    private static readonly uint[] _gameCurrentPlayersFieldTags = new uint[] { 10 };
    public static GameCurrentPlayers DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GameCurrentPlayers DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GameCurrentPlayers ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_GameCurrentPlayers__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GameCurrentPlayers, GameCurrentPlayers.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_GameCurrentPlayers__FieldAccessorTable; }
    }
    
    public const int PlayersFieldNumber = 1;
    private pbc::PopsicleList<global::D3.GameMessage.HeroDigestBanner> players_ = new pbc::PopsicleList<global::D3.GameMessage.HeroDigestBanner>();
    public scg::IList<global::D3.GameMessage.HeroDigestBanner> PlayersList {
      get { return players_; }
    }
    public int PlayersCount {
      get { return players_.Count; }
    }
    public global::D3.GameMessage.HeroDigestBanner GetPlayers(int index) {
      return players_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::D3.GameMessage.HeroDigestBanner element in PlayersList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _gameCurrentPlayersFieldNames;
      if (players_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], players_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::D3.GameMessage.HeroDigestBanner element in PlayersList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GameCurrentPlayers ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameCurrentPlayers ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameCurrentPlayers ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GameCurrentPlayers ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GameCurrentPlayers ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameCurrentPlayers ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GameCurrentPlayers ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GameCurrentPlayers ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GameCurrentPlayers ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GameCurrentPlayers ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GameCurrentPlayers MakeReadOnly() {
      players_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GameCurrentPlayers prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GameCurrentPlayers, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GameCurrentPlayers cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GameCurrentPlayers result;
      
      private GameCurrentPlayers PrepareBuilder() {
        if (resultIsReadOnly) {
          GameCurrentPlayers original = result;
          result = new GameCurrentPlayers();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GameCurrentPlayers MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.GameCurrentPlayers.Descriptor; }
      }
      
      public override GameCurrentPlayers DefaultInstanceForType {
        get { return global::D3.GameMessage.GameCurrentPlayers.DefaultInstance; }
      }
      
      public override GameCurrentPlayers BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GameCurrentPlayers) {
          return MergeFrom((GameCurrentPlayers) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GameCurrentPlayers other) {
        if (other == global::D3.GameMessage.GameCurrentPlayers.DefaultInstance) return this;
        PrepareBuilder();
        if (other.players_.Count != 0) {
          result.players_.Add(other.players_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gameCurrentPlayersFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gameCurrentPlayersFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.players_, global::D3.GameMessage.HeroDigestBanner.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::D3.GameMessage.HeroDigestBanner> PlayersList {
        get { return PrepareBuilder().players_; }
      }
      public int PlayersCount {
        get { return result.PlayersCount; }
      }
      public global::D3.GameMessage.HeroDigestBanner GetPlayers(int index) {
        return result.GetPlayers(index);
      }
      public Builder SetPlayers(int index, global::D3.GameMessage.HeroDigestBanner value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.players_[index] = value;
        return this;
      }
      public Builder SetPlayers(int index, global::D3.GameMessage.HeroDigestBanner.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.players_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddPlayers(global::D3.GameMessage.HeroDigestBanner value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.players_.Add(value);
        return this;
      }
      public Builder AddPlayers(global::D3.GameMessage.HeroDigestBanner.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.players_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangePlayers(scg::IEnumerable<global::D3.GameMessage.HeroDigestBanner> values) {
        PrepareBuilder();
        result.players_.Add(values);
        return this;
      }
      public Builder ClearPlayers() {
        PrepareBuilder();
        result.players_.Clear();
        return this;
      }
    }
    static GameCurrentPlayers() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class AccountVersionList : pb::GeneratedMessage<AccountVersionList, AccountVersionList.Builder> {
    private AccountVersionList() { }
    private static readonly AccountVersionList defaultInstance = new AccountVersionList().MakeReadOnly();
    private static readonly string[] _accountVersionListFieldNames = new string[] { "account_id" };
    private static readonly uint[] _accountVersionListFieldTags = new uint[] { 10 };
    public static AccountVersionList DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AccountVersionList DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AccountVersionList ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_AccountVersionList__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AccountVersionList, AccountVersionList.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_AccountVersionList__FieldAccessorTable; }
    }
    
    public const int AccountIdFieldNumber = 1;
    private bool hasAccountId;
    private global::D3.OnlineService.EntityId accountId_;
    public bool HasAccountId {
      get { return hasAccountId; }
    }
    public global::D3.OnlineService.EntityId AccountId {
      get { return accountId_ ?? global::D3.OnlineService.EntityId.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasAccountId) return false;
        if (!AccountId.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _accountVersionListFieldNames;
      if (hasAccountId) {
        output.WriteMessage(1, field_names[0], AccountId);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasAccountId) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, AccountId);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static AccountVersionList ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AccountVersionList ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AccountVersionList ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AccountVersionList ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AccountVersionList ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AccountVersionList ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AccountVersionList ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AccountVersionList ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AccountVersionList ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AccountVersionList ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AccountVersionList MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AccountVersionList prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<AccountVersionList, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AccountVersionList cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AccountVersionList result;
      
      private AccountVersionList PrepareBuilder() {
        if (resultIsReadOnly) {
          AccountVersionList original = result;
          result = new AccountVersionList();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AccountVersionList MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.AccountVersionList.Descriptor; }
      }
      
      public override AccountVersionList DefaultInstanceForType {
        get { return global::D3.GameMessage.AccountVersionList.DefaultInstance; }
      }
      
      public override AccountVersionList BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AccountVersionList) {
          return MergeFrom((AccountVersionList) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AccountVersionList other) {
        if (other == global::D3.GameMessage.AccountVersionList.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasAccountId) {
          MergeAccountId(other.AccountId);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_accountVersionListFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _accountVersionListFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.OnlineService.EntityId.Builder subBuilder = global::D3.OnlineService.EntityId.CreateBuilder();
              if (result.hasAccountId) {
                subBuilder.MergeFrom(AccountId);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              AccountId = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasAccountId {
       get { return result.hasAccountId; }
      }
      public global::D3.OnlineService.EntityId AccountId {
        get { return result.AccountId; }
        set { SetAccountId(value); }
      }
      public Builder SetAccountId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAccountId = true;
        result.accountId_ = value;
        return this;
      }
      public Builder SetAccountId(global::D3.OnlineService.EntityId.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasAccountId = true;
        result.accountId_ = builderForValue.Build();
        return this;
      }
      public Builder MergeAccountId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasAccountId &&
            result.accountId_ != global::D3.OnlineService.EntityId.DefaultInstance) {
            result.accountId_ = global::D3.OnlineService.EntityId.CreateBuilder(result.accountId_).MergeFrom(value).BuildPartial();
        } else {
          result.accountId_ = value;
        }
        result.hasAccountId = true;
        return this;
      }
      public Builder ClearAccountId() {
        PrepareBuilder();
        result.hasAccountId = false;
        result.accountId_ = null;
        return this;
      }
    }
    static AccountVersionList() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class AccountVersionSync : pb::GeneratedMessage<AccountVersionSync, AccountVersionSync.Builder> {
    private AccountVersionSync() { }
    private static readonly AccountVersionSync defaultInstance = new AccountVersionSync().MakeReadOnly();
    private static readonly string[] _accountVersionSyncFieldNames = new string[] { "account_id", "version" };
    private static readonly uint[] _accountVersionSyncFieldTags = new uint[] { 10, 16 };
    public static AccountVersionSync DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AccountVersionSync DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AccountVersionSync ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_AccountVersionSync__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AccountVersionSync, AccountVersionSync.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_AccountVersionSync__FieldAccessorTable; }
    }
    
    public const int AccountIdFieldNumber = 1;
    private bool hasAccountId;
    private global::D3.OnlineService.EntityId accountId_;
    public bool HasAccountId {
      get { return hasAccountId; }
    }
    public global::D3.OnlineService.EntityId AccountId {
      get { return accountId_ ?? global::D3.OnlineService.EntityId.DefaultInstance; }
    }
    
    public const int VersionFieldNumber = 2;
    private bool hasVersion;
    private ulong version_;
    public bool HasVersion {
      get { return hasVersion; }
    }
    public ulong Version {
      get { return version_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasAccountId) return false;
        if (!hasVersion) return false;
        if (!AccountId.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _accountVersionSyncFieldNames;
      if (hasAccountId) {
        output.WriteMessage(1, field_names[0], AccountId);
      }
      if (hasVersion) {
        output.WriteUInt64(2, field_names[1], Version);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasAccountId) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, AccountId);
        }
        if (hasVersion) {
          size += pb::CodedOutputStream.ComputeUInt64Size(2, Version);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static AccountVersionSync ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AccountVersionSync ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AccountVersionSync ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AccountVersionSync ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AccountVersionSync ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AccountVersionSync ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AccountVersionSync ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AccountVersionSync ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AccountVersionSync ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AccountVersionSync ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AccountVersionSync MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AccountVersionSync prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<AccountVersionSync, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AccountVersionSync cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AccountVersionSync result;
      
      private AccountVersionSync PrepareBuilder() {
        if (resultIsReadOnly) {
          AccountVersionSync original = result;
          result = new AccountVersionSync();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AccountVersionSync MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.AccountVersionSync.Descriptor; }
      }
      
      public override AccountVersionSync DefaultInstanceForType {
        get { return global::D3.GameMessage.AccountVersionSync.DefaultInstance; }
      }
      
      public override AccountVersionSync BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AccountVersionSync) {
          return MergeFrom((AccountVersionSync) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AccountVersionSync other) {
        if (other == global::D3.GameMessage.AccountVersionSync.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasAccountId) {
          MergeAccountId(other.AccountId);
        }
        if (other.HasVersion) {
          Version = other.Version;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_accountVersionSyncFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _accountVersionSyncFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::D3.OnlineService.EntityId.Builder subBuilder = global::D3.OnlineService.EntityId.CreateBuilder();
              if (result.hasAccountId) {
                subBuilder.MergeFrom(AccountId);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              AccountId = subBuilder.BuildPartial();
              break;
            }
            case 16: {
              result.hasVersion = input.ReadUInt64(ref result.version_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasAccountId {
       get { return result.hasAccountId; }
      }
      public global::D3.OnlineService.EntityId AccountId {
        get { return result.AccountId; }
        set { SetAccountId(value); }
      }
      public Builder SetAccountId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasAccountId = true;
        result.accountId_ = value;
        return this;
      }
      public Builder SetAccountId(global::D3.OnlineService.EntityId.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasAccountId = true;
        result.accountId_ = builderForValue.Build();
        return this;
      }
      public Builder MergeAccountId(global::D3.OnlineService.EntityId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasAccountId &&
            result.accountId_ != global::D3.OnlineService.EntityId.DefaultInstance) {
            result.accountId_ = global::D3.OnlineService.EntityId.CreateBuilder(result.accountId_).MergeFrom(value).BuildPartial();
        } else {
          result.accountId_ = value;
        }
        result.hasAccountId = true;
        return this;
      }
      public Builder ClearAccountId() {
        PrepareBuilder();
        result.hasAccountId = false;
        result.accountId_ = null;
        return this;
      }
      
      public bool HasVersion {
        get { return result.hasVersion; }
      }
      public ulong Version {
        get { return result.Version; }
        set { SetVersion(value); }
      }
      public Builder SetVersion(ulong value) {
        PrepareBuilder();
        result.hasVersion = true;
        result.version_ = value;
        return this;
      }
      public Builder ClearVersion() {
        PrepareBuilder();
        result.hasVersion = false;
        result.version_ = 0UL;
        return this;
      }
    }
    static AccountVersionSync() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class TooltipIds : pb::GeneratedMessage<TooltipIds, TooltipIds.Builder> {
    private TooltipIds() { }
    private static readonly TooltipIds defaultInstance = new TooltipIds().MakeReadOnly();
    private static readonly string[] _tooltipIdsFieldNames = new string[] { "ids", "locale" };
    private static readonly uint[] _tooltipIdsFieldTags = new uint[] { 18, 8 };
    public static TooltipIds DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override TooltipIds DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TooltipIds ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_TooltipIds__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<TooltipIds, TooltipIds.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_TooltipIds__FieldAccessorTable; }
    }
    
    public const int LocaleFieldNumber = 1;
    private bool hasLocale;
    private uint locale_;
    public bool HasLocale {
      get { return hasLocale; }
    }
    public uint Locale {
      get { return locale_; }
    }
    
    public const int IdsFieldNumber = 2;
    private pbc::PopsicleList<global::D3.OnlineService.ItemId> ids_ = new pbc::PopsicleList<global::D3.OnlineService.ItemId>();
    public scg::IList<global::D3.OnlineService.ItemId> IdsList {
      get { return ids_; }
    }
    public int IdsCount {
      get { return ids_.Count; }
    }
    public global::D3.OnlineService.ItemId GetIds(int index) {
      return ids_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasLocale) return false;
        foreach (global::D3.OnlineService.ItemId element in IdsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tooltipIdsFieldNames;
      if (hasLocale) {
        output.WriteUInt32(1, field_names[1], Locale);
      }
      if (ids_.Count > 0) {
        output.WriteMessageArray(2, field_names[0], ids_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasLocale) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Locale);
        }
        foreach (global::D3.OnlineService.ItemId element in IdsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static TooltipIds ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TooltipIds ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TooltipIds ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TooltipIds ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TooltipIds ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TooltipIds ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static TooltipIds ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static TooltipIds ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static TooltipIds ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TooltipIds ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TooltipIds MakeReadOnly() {
      ids_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(TooltipIds prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<TooltipIds, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TooltipIds cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TooltipIds result;
      
      private TooltipIds PrepareBuilder() {
        if (resultIsReadOnly) {
          TooltipIds original = result;
          result = new TooltipIds();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TooltipIds MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.TooltipIds.Descriptor; }
      }
      
      public override TooltipIds DefaultInstanceForType {
        get { return global::D3.GameMessage.TooltipIds.DefaultInstance; }
      }
      
      public override TooltipIds BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is TooltipIds) {
          return MergeFrom((TooltipIds) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TooltipIds other) {
        if (other == global::D3.GameMessage.TooltipIds.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasLocale) {
          Locale = other.Locale;
        }
        if (other.ids_.Count != 0) {
          result.ids_.Add(other.ids_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tooltipIdsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tooltipIdsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasLocale = input.ReadUInt32(ref result.locale_);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.ids_, global::D3.OnlineService.ItemId.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasLocale {
        get { return result.hasLocale; }
      }
      public uint Locale {
        get { return result.Locale; }
        set { SetLocale(value); }
      }
      public Builder SetLocale(uint value) {
        PrepareBuilder();
        result.hasLocale = true;
        result.locale_ = value;
        return this;
      }
      public Builder ClearLocale() {
        PrepareBuilder();
        result.hasLocale = false;
        result.locale_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<global::D3.OnlineService.ItemId> IdsList {
        get { return PrepareBuilder().ids_; }
      }
      public int IdsCount {
        get { return result.IdsCount; }
      }
      public global::D3.OnlineService.ItemId GetIds(int index) {
        return result.GetIds(index);
      }
      public Builder SetIds(int index, global::D3.OnlineService.ItemId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.ids_[index] = value;
        return this;
      }
      public Builder SetIds(int index, global::D3.OnlineService.ItemId.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.ids_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddIds(global::D3.OnlineService.ItemId value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.ids_.Add(value);
        return this;
      }
      public Builder AddIds(global::D3.OnlineService.ItemId.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.ids_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeIds(scg::IEnumerable<global::D3.OnlineService.ItemId> values) {
        PrepareBuilder();
        result.ids_.Add(values);
        return this;
      }
      public Builder ClearIds() {
        PrepareBuilder();
        result.ids_.Clear();
        return this;
      }
    }
    static TooltipIds() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class TooltipGenerators : pb::GeneratedMessage<TooltipGenerators, TooltipGenerators.Builder> {
    private TooltipGenerators() { }
    private static readonly TooltipGenerators defaultInstance = new TooltipGenerators().MakeReadOnly();
    private static readonly string[] _tooltipGeneratorsFieldNames = new string[] { "items", "locale" };
    private static readonly uint[] _tooltipGeneratorsFieldTags = new uint[] { 18, 8 };
    public static TooltipGenerators DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override TooltipGenerators DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TooltipGenerators ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_TooltipGenerators__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<TooltipGenerators, TooltipGenerators.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_TooltipGenerators__FieldAccessorTable; }
    }
    
    public const int LocaleFieldNumber = 1;
    private bool hasLocale;
    private uint locale_;
    public bool HasLocale {
      get { return hasLocale; }
    }
    public uint Locale {
      get { return locale_; }
    }
    
    public const int ItemsFieldNumber = 2;
    private bool hasItems;
    private global::D3.Items.ItemList items_;
    public bool HasItems {
      get { return hasItems; }
    }
    public global::D3.Items.ItemList Items {
      get { return items_ ?? global::D3.Items.ItemList.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasLocale) return false;
        if (!hasItems) return false;
        if (!Items.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tooltipGeneratorsFieldNames;
      if (hasLocale) {
        output.WriteUInt32(1, field_names[1], Locale);
      }
      if (hasItems) {
        output.WriteMessage(2, field_names[0], Items);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasLocale) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, Locale);
        }
        if (hasItems) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, Items);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static TooltipGenerators ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TooltipGenerators ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TooltipGenerators ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TooltipGenerators ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TooltipGenerators ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TooltipGenerators ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static TooltipGenerators ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static TooltipGenerators ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static TooltipGenerators ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TooltipGenerators ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TooltipGenerators MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(TooltipGenerators prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<TooltipGenerators, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TooltipGenerators cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TooltipGenerators result;
      
      private TooltipGenerators PrepareBuilder() {
        if (resultIsReadOnly) {
          TooltipGenerators original = result;
          result = new TooltipGenerators();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TooltipGenerators MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.TooltipGenerators.Descriptor; }
      }
      
      public override TooltipGenerators DefaultInstanceForType {
        get { return global::D3.GameMessage.TooltipGenerators.DefaultInstance; }
      }
      
      public override TooltipGenerators BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is TooltipGenerators) {
          return MergeFrom((TooltipGenerators) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TooltipGenerators other) {
        if (other == global::D3.GameMessage.TooltipGenerators.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasLocale) {
          Locale = other.Locale;
        }
        if (other.HasItems) {
          MergeItems(other.Items);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tooltipGeneratorsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tooltipGeneratorsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasLocale = input.ReadUInt32(ref result.locale_);
              break;
            }
            case 18: {
              global::D3.Items.ItemList.Builder subBuilder = global::D3.Items.ItemList.CreateBuilder();
              if (result.hasItems) {
                subBuilder.MergeFrom(Items);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Items = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasLocale {
        get { return result.hasLocale; }
      }
      public uint Locale {
        get { return result.Locale; }
        set { SetLocale(value); }
      }
      public Builder SetLocale(uint value) {
        PrepareBuilder();
        result.hasLocale = true;
        result.locale_ = value;
        return this;
      }
      public Builder ClearLocale() {
        PrepareBuilder();
        result.hasLocale = false;
        result.locale_ = 0;
        return this;
      }
      
      public bool HasItems {
       get { return result.hasItems; }
      }
      public global::D3.Items.ItemList Items {
        get { return result.Items; }
        set { SetItems(value); }
      }
      public Builder SetItems(global::D3.Items.ItemList value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasItems = true;
        result.items_ = value;
        return this;
      }
      public Builder SetItems(global::D3.Items.ItemList.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasItems = true;
        result.items_ = builderForValue.Build();
        return this;
      }
      public Builder MergeItems(global::D3.Items.ItemList value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasItems &&
            result.items_ != global::D3.Items.ItemList.DefaultInstance) {
            result.items_ = global::D3.Items.ItemList.CreateBuilder(result.items_).MergeFrom(value).BuildPartial();
        } else {
          result.items_ = value;
        }
        result.hasItems = true;
        return this;
      }
      public Builder ClearItems() {
        PrepareBuilder();
        result.hasItems = false;
        result.items_ = null;
        return this;
      }
    }
    static TooltipGenerators() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class TutorialMessage : pb::GeneratedMessage<TutorialMessage, TutorialMessage.Builder> {
    private TutorialMessage() { }
    private static readonly TutorialMessage defaultInstance = new TutorialMessage().MakeReadOnly();
    private static readonly string[] _tutorialMessageFieldNames = new string[] { "tutorial_sno", "ui_anchor_name" };
    private static readonly uint[] _tutorialMessageFieldTags = new uint[] { 8, 18 };
    public static TutorialMessage DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override TutorialMessage DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override TutorialMessage ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_TutorialMessage__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<TutorialMessage, TutorialMessage.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_TutorialMessage__FieldAccessorTable; }
    }
    
    public const int TutorialSnoFieldNumber = 1;
    private bool hasTutorialSno;
    private uint tutorialSno_;
    public bool HasTutorialSno {
      get { return hasTutorialSno; }
    }
    public uint TutorialSno {
      get { return tutorialSno_; }
    }
    
    public const int UiAnchorNameFieldNumber = 2;
    private bool hasUiAnchorName;
    private string uiAnchorName_ = "";
    public bool HasUiAnchorName {
      get { return hasUiAnchorName; }
    }
    public string UiAnchorName {
      get { return uiAnchorName_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasTutorialSno) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _tutorialMessageFieldNames;
      if (hasTutorialSno) {
        output.WriteUInt32(1, field_names[0], TutorialSno);
      }
      if (hasUiAnchorName) {
        output.WriteString(2, field_names[1], UiAnchorName);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasTutorialSno) {
          size += pb::CodedOutputStream.ComputeUInt32Size(1, TutorialSno);
        }
        if (hasUiAnchorName) {
          size += pb::CodedOutputStream.ComputeStringSize(2, UiAnchorName);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static TutorialMessage ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TutorialMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TutorialMessage ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static TutorialMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static TutorialMessage ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TutorialMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static TutorialMessage ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static TutorialMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static TutorialMessage ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static TutorialMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private TutorialMessage MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(TutorialMessage prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<TutorialMessage, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(TutorialMessage cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private TutorialMessage result;
      
      private TutorialMessage PrepareBuilder() {
        if (resultIsReadOnly) {
          TutorialMessage original = result;
          result = new TutorialMessage();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override TutorialMessage MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.TutorialMessage.Descriptor; }
      }
      
      public override TutorialMessage DefaultInstanceForType {
        get { return global::D3.GameMessage.TutorialMessage.DefaultInstance; }
      }
      
      public override TutorialMessage BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is TutorialMessage) {
          return MergeFrom((TutorialMessage) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(TutorialMessage other) {
        if (other == global::D3.GameMessage.TutorialMessage.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasTutorialSno) {
          TutorialSno = other.TutorialSno;
        }
        if (other.HasUiAnchorName) {
          UiAnchorName = other.UiAnchorName;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_tutorialMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _tutorialMessageFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasTutorialSno = input.ReadUInt32(ref result.tutorialSno_);
              break;
            }
            case 18: {
              result.hasUiAnchorName = input.ReadString(ref result.uiAnchorName_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasTutorialSno {
        get { return result.hasTutorialSno; }
      }
      public uint TutorialSno {
        get { return result.TutorialSno; }
        set { SetTutorialSno(value); }
      }
      public Builder SetTutorialSno(uint value) {
        PrepareBuilder();
        result.hasTutorialSno = true;
        result.tutorialSno_ = value;
        return this;
      }
      public Builder ClearTutorialSno() {
        PrepareBuilder();
        result.hasTutorialSno = false;
        result.tutorialSno_ = 0;
        return this;
      }
      
      public bool HasUiAnchorName {
        get { return result.hasUiAnchorName; }
      }
      public string UiAnchorName {
        get { return result.UiAnchorName; }
        set { SetUiAnchorName(value); }
      }
      public Builder SetUiAnchorName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasUiAnchorName = true;
        result.uiAnchorName_ = value;
        return this;
      }
      public Builder ClearUiAnchorName() {
        PrepareBuilder();
        result.hasUiAnchorName = false;
        result.uiAnchorName_ = "";
        return this;
      }
    }
    static TutorialMessage() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class SetAchievementShowcase : pb::GeneratedMessage<SetAchievementShowcase, SetAchievementShowcase.Builder> {
    private SetAchievementShowcase() { }
    private static readonly SetAchievementShowcase defaultInstance = new SetAchievementShowcase().MakeReadOnly();
    private static readonly string[] _setAchievementShowcaseFieldNames = new string[] { "achievement_id", "slot" };
    private static readonly uint[] _setAchievementShowcaseFieldTags = new uint[] { 8, 16 };
    public static SetAchievementShowcase DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SetAchievementShowcase DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SetAchievementShowcase ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_SetAchievementShowcase__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SetAchievementShowcase, SetAchievementShowcase.Builder> InternalFieldAccessors {
      get { return global::D3.GameMessage.GameMessage.internal__static_D3_GameMessage_SetAchievementShowcase__FieldAccessorTable; }
    }
    
    public const int AchievementIdFieldNumber = 1;
    private bool hasAchievementId;
    private ulong achievementId_;
    public bool HasAchievementId {
      get { return hasAchievementId; }
    }
    public ulong AchievementId {
      get { return achievementId_; }
    }
    
    public const int SlotFieldNumber = 2;
    private bool hasSlot;
    private uint slot_;
    public bool HasSlot {
      get { return hasSlot; }
    }
    public uint Slot {
      get { return slot_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasAchievementId) return false;
        if (!hasSlot) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _setAchievementShowcaseFieldNames;
      if (hasAchievementId) {
        output.WriteUInt64(1, field_names[0], AchievementId);
      }
      if (hasSlot) {
        output.WriteUInt32(2, field_names[1], Slot);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasAchievementId) {
          size += pb::CodedOutputStream.ComputeUInt64Size(1, AchievementId);
        }
        if (hasSlot) {
          size += pb::CodedOutputStream.ComputeUInt32Size(2, Slot);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static SetAchievementShowcase ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SetAchievementShowcase ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SetAchievementShowcase ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SetAchievementShowcase ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SetAchievementShowcase ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SetAchievementShowcase ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SetAchievementShowcase ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SetAchievementShowcase ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SetAchievementShowcase ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SetAchievementShowcase ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SetAchievementShowcase MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SetAchievementShowcase prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<SetAchievementShowcase, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SetAchievementShowcase cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SetAchievementShowcase result;
      
      private SetAchievementShowcase PrepareBuilder() {
        if (resultIsReadOnly) {
          SetAchievementShowcase original = result;
          result = new SetAchievementShowcase();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SetAchievementShowcase MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::D3.GameMessage.SetAchievementShowcase.Descriptor; }
      }
      
      public override SetAchievementShowcase DefaultInstanceForType {
        get { return global::D3.GameMessage.SetAchievementShowcase.DefaultInstance; }
      }
      
      public override SetAchievementShowcase BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SetAchievementShowcase) {
          return MergeFrom((SetAchievementShowcase) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SetAchievementShowcase other) {
        if (other == global::D3.GameMessage.SetAchievementShowcase.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasAchievementId) {
          AchievementId = other.AchievementId;
        }
        if (other.HasSlot) {
          Slot = other.Slot;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_setAchievementShowcaseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _setAchievementShowcaseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasAchievementId = input.ReadUInt64(ref result.achievementId_);
              break;
            }
            case 16: {
              result.hasSlot = input.ReadUInt32(ref result.slot_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasAchievementId {
        get { return result.hasAchievementId; }
      }
      public ulong AchievementId {
        get { return result.AchievementId; }
        set { SetAchievementId(value); }
      }
      public Builder SetAchievementId(ulong value) {
        PrepareBuilder();
        result.hasAchievementId = true;
        result.achievementId_ = value;
        return this;
      }
      public Builder ClearAchievementId() {
        PrepareBuilder();
        result.hasAchievementId = false;
        result.achievementId_ = 0UL;
        return this;
      }
      
      public bool HasSlot {
        get { return result.hasSlot; }
      }
      public uint Slot {
        get { return result.Slot; }
        set { SetSlot(value); }
      }
      public Builder SetSlot(uint value) {
        PrepareBuilder();
        result.hasSlot = true;
        result.slot_ = value;
        return this;
      }
      public Builder ClearSlot() {
        PrepareBuilder();
        result.hasSlot = false;
        result.slot_ = 0;
        return this;
      }
    }
    static SetAchievementShowcase() {
      object.ReferenceEquals(global::D3.GameMessage.GameMessage.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
