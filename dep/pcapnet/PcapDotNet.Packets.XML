<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PcapDotNet.Packets</name>
    </assembly>
    <members>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionType">
            <summary>
            An enum for all the different tcp option types.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.EndOfOptionList">
            <summary>
            End of Option List (RFC793)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.NoOperation">
            <summary>
            No-Operation (RFC793)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.MaximumSegmentSize">
            <summary>
            Maximum Segment Size (RFC793)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.WindowScale">
            <summary>
            WSOPT - Window Scale (RFC1323)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.SelectiveAcknowledgmentPermitted">
            <summary>
            SACK Permitted (RFC2018)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.SelectiveAcknowledgment">
            <summary>
            SACK (RFC2018)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.Echo">
            <summary>
            Echo (obsoleted by option 8) (RFC1072)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.EchoReply">
            <summary>
            Echo Reply (obsoleted by option 8) (RFC1072)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.Timestamp">
            <summary>
            TSOPT - Time Stamp Option (RFC1323)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.PartialOrderConnectionPermitted">
            <summary>
            Partial Order Connection Permitted (RFC1693)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.PartialOrderServiceProfile">
            <summary>
            Partial Order Service Profile (RFC1693)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.ConnectionCount">
            <summary>
            CC (RFC1644)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.ConnectionCountNew">
            <summary>
            CC.NEW (RFC1644)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.ConnectionCountEcho">
            <summary>
            CC.ECHO (RFC1644)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.AlternateChecksumRequest">
            <summary>
            TCP Alternate Checksum Request (RFC1146)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.AlternateChecksumData">
            <summary>
            TCP Alternate Checksum Data (RFC1146)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.Md5Signature">
            <summary>
            MD5 Signature Option (RFC2385)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.Mood">
            <summary>
            Denote Packet Mood (RFC5841)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.QuickStartResponse">
            <summary>
            Quick-Start Response (RFC4782)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionType.UserTimeout">
            <summary>
            User Timeout Option (RFC5482)
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel">
            <summary>
            This field specifies the (U.S.) classification level at which the datagram must be protected.  
            The information in the datagram must be protected at this level.  
            The bit string values in this table were chosen to achieve a minimum Hamming distance of four (4) between any two valid values.  
            This specific assignment of classification level names to values has been defined for compatibility 
            with security devices which have already been developed and deployed.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel.None">
            <summary>
            An invalid value for a classification level.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel.TopSecret">
            <summary>
            Top Secret
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel.Secret">
            <summary>
            Secret
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel.Confidential">
            <summary>
            Confidential
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel.Unclassified">
            <summary>
            Unclassified
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionRecordRoute">
            <summary>
            Record Route
            <pre>
            +--------+--------+--------+---------//--------+
            |00000111| length | pointer|     route data    |
            +--------+--------+--------+---------//--------+
             Type=7
            </pre>
            
            <para>
            The record route option provides a means to record the route of an internet datagram.
            </para>
            
            <para>
            The option begins with the option type code.  
            The second octet is the option length which includes the option type code and the length octet, 
            the pointer octet, and length-3 octets of route data.  
            The third octet is the pointer into the route data indicating the octet which begins the next area to store a route address.  
            The pointer is relative to this option, and the smallest legal value for the pointer is 4.
            </para>
            
            <para>
            A recorded route is composed of a series of internet addresses.
            Each internet address is 32 bits or 4 octets.  
            If the pointer is greater than the length, the recorded route data area is full.
            The originating host must compose this option with a large enough route data area to hold all the address expected.  
            The size of the option does not change due to adding addresses.  
            The intitial contents of the route data area must be zero.
            </para>
            
            <para>
            When an internet module routes a datagram it checks to see if the record route option is present.  
            If it is, it inserts its own internet address as known in the environment into which this datagram is being forwarded 
            into the recorded route begining at the octet indicated by the pointer, 
            and increments the pointer by four.
            </para>
            
            <para>
            If the route data area is already full (the pointer exceeds the length) 
            the datagram is forwarded without inserting the address into the recorded route.  
            If there is some room but not enough room for a full address to be inserted, 
            the original datagram is considered to be in error and is discarded.  
            In either case an ICMP parameter problem message may be sent to the source host.
            </para>
            
            <para>
            Not copied on fragmentation, goes in first fragment only.
            Appears at most once in a datagram.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionRoute">
            <summary>
            The base class for route tracking options (loose, strict, record).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionComplex">
            <summary>
            Represents a complex IPv4 option.
            Complex option means that it contains data and not just the type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Option">
            <summary>
            Represents an ip option according to rfc 791. 
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Option">
            <summary>
            A generic option (for IPv4 and TCP).
            The option is read from buffer and can be of different length.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Option.Equivalent(PcapDotNet.Packets.Option)">
            <summary>
            Checks whether two options have equivalent type.
            Useful to check if an option that must appear at most once appears in the list.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Option.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Option.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.Equivalent(PcapDotNet.Packets.Option)">
            <summary>
            Checks whether two options have equivalent type.
            Useful to check if an option that must appear at most once appears in the list.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Checks if the two options are exactly the same - including type and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.Equals(System.Object)">
            <summary>
            Checks if the two options are exactly the same - including type and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.GetHashCode">
            <summary>
            The hash code of the option is the hash code of the option type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.ToString">
            <summary>
            The string of the option is the string of the option type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Option.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionType)">
            <summary>
            Constructs the option by type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Option.End">
            <summary>
             This option indicates the end of the option list.<br/>
             This might not coincide with the end of the internet header according to the internet header length.
             This is used at the end of all options, not the end of each option, and need only be used if the end of the options would not otherwise coincide with the end of the internet header.
             May be copied, introduced, or deleted on fragmentation, or for any other reason.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Option.Nop">
            <summary>
            This option may be used between options, for example, to align the beginning of a subsequent option on a 32 bit boundary.
            May be copied, introduced, or deleted on fragmentation, or for any other reason.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Option.OptionType">
            <summary>
            The type of the ip option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionComplex.OptionHeaderLength">
            <summary>
            The header length in bytes for the option (type and size).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionComplex.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionType)">
            <summary>
            Constructs the option by type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionRoute.OptionMinimumLength">
            <summary>
            The minimum option length in bytes (type, length, pointer).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionRoute.OptionValueMinimumLength">
            <summary>
            The minimum option value length in bytes (pointer).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionRoute.PointedAddressIndexMaxValue">
            <summary>
            The maximum value for the index pointed the route.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRoute.Equals(PcapDotNet.Packets.IpV4.IpV4OptionRoute)">
            <summary>
            Two routes options are equal iff they have the same type, same pointed address index and same route.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRoute.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two routes options are equal iff they have the same type, same pointed address index and same route.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRoute.GetHashCode">
            <summary>
            The hash code of the route option is the xor of the following hash codes: base class, pointed address index and all the addresses in the route.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRoute.TryRead(PcapDotNet.Packets.IpV4.IpV4Address[]@,System.Byte@,System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the value of the route option from the given buffer.
            </summary>
            <param name="addresses">The route read from the buffer.</param>
            <param name="pointedAddressIndex">The index pointed in the route read from the buffer.</param>
            <param name="buffer">The buffer to read the value from.</param>
            <param name="offset">The offset in the buffer to start reading the value from.</param>
            <param name="valueLength">The number of bytes that the value should be.</param>
            <returns>True iff the read was successful.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRoute.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionType,System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Address},System.Byte)">
            <summary>
            Construct a route option from the given values.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRoute.PointedAddressIndex">
            <summary>
            The pointed index in the route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRoute.Route">
            <summary>
            The route tracked - the collection of addresses written.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRoute.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRoute.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IOptionComplexFactory">
            <summary>
            This interface is used to create all complex options.
            Every complex option should implement such a factory to create itself from a buffer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IOptionComplexFactory.CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRecordRoute.#ctor(System.Byte,System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Address})">
            <summary>
            Constructs the option from the given values.
            </summary>
            <param name="route">The route addresses values.</param>
            <param name="pointedAddressIndex">The pointed index in the route.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRecordRoute.#ctor(System.Byte,PcapDotNet.Packets.IpV4.IpV4Address[])">
            <summary>
            Constructs the option from the given values.
            </summary>
            <param name="route">The route addresses values.</param>
            <param name="pointedAddressIndex">The pointed index in the route.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRecordRoute.#ctor">
            <summary>
            Constructs an empty record route option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRecordRoute.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer">
            <summary>
            RFC 2521.
            Represents an ICMP Security Failures layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpLayer">
            <summary>
            Represents an ICMP layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpDatagram"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.SimpleLayer">
            <summary>
            A simple layer is a layer that doesn't care what is the length of its payload, what layer comes after it and what layer comes before it.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Layer">
            <summary>
            The base class of a layer used to build a Packet.
            Each layer represents the part of the packet relevant to a specific protocol.
            A sequence of layers can represent a packet.
            A packet can be according to a sequence of layers.
            <seealso cref="T:PcapDotNet.Packets.PacketBuilder"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.ILayer">
            <summary>
            The interface of a layer used to build a Packet.
            Each layer represents the part of the packet relevant to a specific protocol.
            A sequence of layers can represent a packet.
            A packet can be according to a sequence of layers.
            <seealso cref="T:PcapDotNet.Packets.PacketBuilder"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.ILayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ILayer.Finalize(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer)">
            <summary>
            Finalizes the layer data in the buffer.
            Used for fields that must be calculated according to the layer's payload (like checksum).
            </summary>
            <param name="buffer">The buffer to finalize the layer in.</param>
            <param name="offset">The offset in the buffer the layer starts.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="P:PcapDotNet.Packets.ILayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.ILayer.DataLink">
            <summary>
            The kind of the data link of the layer.
            Can be null if this is not the first layer in the packet.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Layer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Layer.Finalize(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer)">
            <summary>
            Finalizes the layer data in the buffer.
            Used for fields that must be calculated according to the layer's payload (like checksum).
            </summary>
            <param name="buffer">The buffer to finalize the layer in.</param>
            <param name="offset">The offset in the buffer the layer starts.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Layer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            True iff the two objects are equal Layers.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Layer.Equals(System.Object)">
            <summary>
            True iff the two objects are equal Layers.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Layer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code base is a XOR of the hash codes of the layer length and data link.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Layer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Layer.DataLink">
            <summary>
            The kind of the data link of the layer.
            Can be null if this is not the first layer in the packet.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.SimpleLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.SimpleLayer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IIpV4NextLayer">
            <summary>
            A layer under an IPv4 layer.
            Must provide the IPv4 Protocol.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IIpV4NextLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.Finalize(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer)">
            <summary>
            Finalizes the layer data in the buffer.
            Used for the ICMP checksum.
            </summary>
            <param name="buffer">The buffer to finalize the layer in.</param>
            <param name="offset">The offset in the buffer the layer starts.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.Equals(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            ICMP layers are equal if they have the same message type, code, checksum, variable and payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            ICMP layers are equal if they have the same message type, code, checksum, variable and payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code is a XOR of the layer length, data link, message type and code, checksum and variable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.ToString">
            <summary>
            Returns a string containing the message type, code and variable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            True iff the ICMP payload is equal to the other ICMP payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.MessageTypeAndCode">
            <summary>
            A combination of the ICMP Message Type and Code.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.Checksum">
            <summary>
            The checksum is the 16-bit ones's complement of the one's complement sum of the ICMP message starting with the ICMP Type.
            For computing the checksum, the checksum field should be zero.
            This checksum may be replaced in the future.
            null means that this checksum should be calculated to be correct.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer.Pointer">
            <summary>
            An offset into the Original Internet Headers that locates the most significant octet of the offending SPI.  
            Will be zero when no SPI is present.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpInformationRequestLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpIdentifiedLayer">
            <summary>
            Represents an ICMP layer with an Identifier and a Sequence Number.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIdentifiedLayer.Identifier">
            <summary>
            An identifier to aid in matching requests and replies, may be zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIdentifiedLayer.SequenceNumber">
            <summary>
            A sequence number to aid in matching requests and replies, may be zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIdentifiedLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpInformationRequestLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpInformationReplyLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpInformationReplyLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram">
            <summary>
            RFC 792 and RFC 1191.
            <pre>
            +-----+------+------+--------------+
            | Bit | 0-7  | 8-15 | 16-31        |
            +-----+------+------+--------------+
            | 0   | Type | Code | Checksum     |
            +-----+------+------+--------------+
            | 32  | unused      | Next-Hop MTU |
            +-----+-------------+--------------+
            | 64  | Internet Header            |
            |     | + 64 bits of               |
            |     | Original Data Datagram     |
            +-----+----------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpIpV4HeaderPlus64BitsPayloadDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | unused                  |
            +-----+-------------------------+
            | 64  | Internet Header         |
            |     | + 64 bits of            |
            |     | Original Data Datagram  |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpIpV4PayloadDatagram">
            <summary>
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | unused                  |
            +-----+-------------------------+
            | 64  | IpV4 datagram           |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpDatagram">
            <summary>
            Generic
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | Value according to Type |
            +-----+-------------------------+
            | 64  | Payload                 |
            | ... |                         |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Datagram">
            <summary>
            Represents a packet datagram.
            A datagram is part of the packet bytes that can be treated as a specific protocol data (usually header + payload).
            Never copies the given buffer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.#ctor(System.Byte[])">
            <summary>
            Take all the bytes as a datagram.
            </summary>
            <param name="buffer">The buffer to take as a datagram.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Take only part of the bytes as a datagarm.
            </summary>
            <param name="buffer">The bytes to take the datagram from.</param>
            <param name="offset">The offset in the buffer to start taking the bytes from.</param>
            <param name="length">The number of bytes to take.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ToMemoryStream">
            <summary>
            Returns the Datagram's bytes as a read only MemoryStream with a non-public buffer.
            </summary>
            <returns>A read only MemoryStream containing the bytes of the Datagram.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.GetEnumerator">
            <summary>
            Iterate through all the bytes in the datagram.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.Equals(PcapDotNet.Packets.Datagram)">
            <summary>
            Two datagrams are equal if the have the same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.Equals(System.Object)">
            <summary>
            Two datagrams are equal if the have the same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.GetHashCode">
            <summary>
            The hash code of a datagram is the hash code of its length xored with all its bytes (each byte is xored with the next byte in the integer).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ToString">
            <summary>
            Converts the datagram to a hexadecimal string representing every bytes as two hexadecimal digits.
            </summary>
            <returns>A hexadecimal string representing every bytes as two hexadecimal digits.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ToString(System.Text.Encoding)">
            <summary>
            Converts the datagram to a string using the given encoding.
            </summary>
            <param name="encoding">The encoding to use to convert the bytes sequence in the Datagram to a string.</param>
            <returns>A string of the bytes in the Datagram converted using the given encoding.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.CalculateIsValid">
            <summary>
            The default validity check always returns true.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ReadBytes(System.Int32,System.Int32)">
            <summary>
            Reads a requested number of bytes from a specific offset in the datagram.
            </summary>
            <param name="offset">The offset in the datagram to start reading.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>The bytes read from the datagram starting from the given offset and in the given length.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ReadUShort(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 2 bytes from a specific offset in the datagram as a ushort with a given endianity.
            </summary>
            <param name="offset">The offset in the datagram to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ReadInt(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset in the datagram as an int with a given endianity.
            </summary>
            <param name="offset">The offset in the datagram to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ReadUInt(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset in the datagram as a uint with a given endianity.
            </summary>
            <param name="offset">The offset in the datagram to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ReadMacAddress(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 6 bytes from a specific offset in the datagram as a MacAddress with a given endianity.
            </summary>
            <param name="offset">The offset in the datagram to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ReadIpV4Address(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset in the datagram as an IpV4Address with a given endianity.
            </summary>
            <param name="offset">The offset in the datagram to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.ReadIpV4TimeOfDay(System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset in the datagram as an IpV4TimeOfDay with a given endianity.
            </summary>
            <param name="offset">The offset in the datagram to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.Sum16BitsToChecksum(System.UInt32)">
            <summary>
            Converts the given 16 bits sum to a checksum.
            Sums the two 16 bits in the 32 bits value and if the result is bigger than a 16 bits value repeat.
            The result is one's complemented and the least significant 16 bits are taken.
            </summary>
            <param name="sum"></param>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.Datagram.Sum16Bits(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sums bytes in a buffer as 16 bits big endian values.
            If the number of bytes is odd then a 0x00 value is assumed after the last byte.
            Used to calculate checksum.
            </summary>
            <param name="buffer">The buffer to take the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading the bytes.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>A value equals to the sum of all 16 bits big endian values of the given bytes.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Datagram.Empty">
            <summary>
            An empty datagram.
            Useful for empty payloads.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Datagram.Length">
            <summary>
            The number of bytes in this datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Datagram.Item(System.Int32)">
            <summary>
            The value of the byte in the given offset in the datagram.
            </summary>
            <param name="offset">The offset in the datagram to take the byte from.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Datagram.IsValid">
            <summary>
            A datagram is checked for validity according to the protocol.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Datagram.Buffer">
            <summary>
            The original buffer that holds all the data for the datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Datagram.StartOffset">
            <summary>
            The offset of the first byte of the datagram in the buffer.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpDatagram.HeaderLength">
            <summary>
            The number of bytes the ICMP header takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDatagram.CalculateIsValid">
            <summary>
            ICMP is valid if the datagram's length is OK, the checksum is correct and the code is in the expected range.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDatagram.CreateDatagram(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates an IcmpDatagram from a buffer according to the message type.
            </summary>
            <param name="buffer">The buffer of the datagram.</param>
            <param name="offset">The offset where the datagram starts.</param>
            <param name="length">The length of the datagram in the buffer.</param>
            <returns>An IcmpDatagram according to the Icmp message type.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.MessageTypeAndCode">
            <summary>
            A combination of the ICMP Message Type and Code.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.Checksum">
            <summary>
            The checksum is the 16-bit ones's complement of the one's complement sum of the ICMP message starting with the ICMP Type.
            For computing the checksum, the checksum field should be zero.
            This checksum may be replaced in the future.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.IsChecksumCorrect">
            <summary>
            True iff the checksum value is correct according to the datagram data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.Payload">
            <summary>
            The payload of the ICMP.
            All the data without the header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpIpV4PayloadDatagram.CalculateIsValid">
            <summary>
            ICMP with IPv4 payload is valid if the datagram's length is OK, the checksum is correct, the code is in the expected range,
            and the IPv4 payload contains at least an IPv4 header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIpV4PayloadDatagram.IpV4">
            <summary>
            The ICMP payload as an IPv4 datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpIpV4HeaderPlus64BitsPayloadDatagram.OriginalDatagramPayloadLength">
            <summary>
            The number of bytes this payload includes from the original data datagram.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpIpV4HeaderPlus64BitsPayloadDatagram.CalculateIsValid">
            <summary>
            ICMP with IPv4 payload and 64 bits IPv4 payload is valid if the datagram's length is OK, the checksum is correct, the code is in the expected range,
            the IPv4 payload contains at least an IPv4 header and the IPv4's payload is in the expected size.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.MinimumMaximumTransmissionUnit">
            <summary>
            The minimum value of the maximum transmission unit for FragmentationNeededAndDoNotFragmentSet code.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct, the code is in the expected range,
            the IPv4 payload contains at least an IPv4 header, the IPv4's payload is in the expected size
            and if the NextHopMaximumTransmissionUnit is at least 68 for FragmentationNeededAndDoNotFragmentSet code or exactly 0 for other codes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.NextHopMaximumTransmissionUnit">
            <summary>
            The size in octets of the largest datagram that could be forwarded, 
            along the path of the original datagram, without being fragmented at this router.  
            The size includes the IP header and IP data, and does not include any lower-level headers.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeTimeExceeded">
            <summary>
            The different ICMP code values for Time Exceeded ICMP type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeTimeExceeded.TimeToLive">
            <summary>
            RFC 792.
            If the gateway processing a datagram finds the time to live field is zero it must discard the datagram.  
            The gateway may also notify the source host via the time exceeded message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeTimeExceeded.FragmentReassembly">
            <summary>
            RFC 792.
            If a host reassembling a fragmented datagram cannot complete the reassembly due to missing fragments within its time limit it discards the datagram, 
            and it may send a time exceeded message.
            If fragment zero is not available then no time exceeded need be sent at all.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpLayer">
            <summary>
            RFC 2616.
            Represents an HTTP layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            Two HTTP layers are equal iff they have the same version, header and body.
            Extended by specific HTTP layers types for more checks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpLayer.Equals(PcapDotNet.Packets.Http.HttpLayer)">
            <summary>
            Two HTTP layers are equal iff they have the same version, header and body.
            Extended by specific HTTP layers types for more checks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpLayer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the HTTP layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.IsRequest">
            <summary>
            True iff the message is a request and iff the message is not a response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.IsResponse">
            <summary>
            True iff the message is a response and iff the message is not a request.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.Version">
            <summary>
            The version of this HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.Header">
            <summary>
            The header of the HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.Body">
            <summary>
            Message Body.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionUnknown">
            <summary>
            An unknown TCP option.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionComplex">
            <summary>
            Represents a complex TCP option.
            Complex option means that it contains data and not just the type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOption">
            <summary>
            Represents a TCP option according to rfc 793. 
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.Equivalent(PcapDotNet.Packets.Option)">
            <summary>
            Checks whether two options have equivalent type.
            Useful to check if an option that must appear at most once appears in the list.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Checks if the two options are exactly the same - including type and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.Equals(System.Object)">
            <summary>
            Checks if the two options are exactly the same - including type and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.GetHashCode">
            <summary>
            The hash code for a tcp option is the hash code for the option type.
            This should be overridden by tcp options with data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.ToString">
            <summary>
            The string that represents the option type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOption.#ctor(PcapDotNet.Packets.Transport.TcpOptionType)">
            <summary>
            Initializes the option type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOption.End">
            <summary>
            This option code indicates the end of the option list.  
            This might not coincide with the end of the TCP header according to the Data Offset field.  
            This is used at the end of all options, not the end of each option, 
            and need only be used if the end of the options would not otherwise coincide with the end of the TCP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOption.Nop">
            <summary>
            This option code may be used between options, 
            for example, to align the beginning of a subsequent option on a word boundary.
            There is no guarantee that senders will use this option, 
            so receivers must be prepared to process options even if they do not begin on a word boundary.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOption.OptionType">
            <summary>
            The type of the TCP option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionComplex.OptionHeaderLength">
            <summary>
            The number of bytes this option header take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionComplex.#ctor(PcapDotNet.Packets.Transport.TcpOptionType)">
            <summary>
            Creates a complex option using the given option type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IOptionUnknownFactory`1">
            <summary>
            A factory interface for an unknown option.
            </summary>
            <typeparam name="TOptionType">The option type enum type.</typeparam>
        </member>
        <member name="M:PcapDotNet.Packets.IOptionUnknownFactory`1.CreateInstance(`0,System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Creates an unknown option from its type and by reading a buffer for its value.
            </summary>
            <param name="optionType">The type of the unknown option.</param>
            <param name="buffer">The buffer of bytes to read the value of the unknown option.</param>
            <param name="offset">The offset in the buffer to start reading the bytes.</param>
            <param name="valueLength">The number of bytes to read from the buffer.</param>
            <returns>An option created from the given type and buffer.</returns>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionUnknown.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionUnknown.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.#ctor(PcapDotNet.Packets.Transport.TcpOptionType,System.Collections.Generic.IList{System.Byte})">
            <summary>
            Creates an unknown TCP option by the given type and data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.#ctor">
            <summary>
            The default unknown option is with type 255 and no data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.Equals(PcapDotNet.Packets.Transport.TcpOptionUnknown)">
            <summary>
            Two unknown options are equal iff they are of equal type and equal data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two unknown options are equal iff they are of equal type and equal data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.GetHashCode">
            <summary>
            The hash code for an unknown option is the hash code for the option type xored with the hash code of the data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionUnknown.CreateInstance(PcapDotNet.Packets.Transport.TcpOptionType,System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Creates an unknown option from its type and by reading a buffer for its value.
            </summary>
            <param name="optionType">The type of the unknown option.</param>
            <param name="buffer">The buffer of bytes to read the value of the unknown option.</param>
            <param name="offset">The offset in the buffer to start reading the bytes.</param>
            <param name="valueLength">The number of bytes to read from the buffer.</param>
            <returns>An option created from the given type and buffer.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionUnknown.Data">
            <summary>
            The data of the unknown option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionUnknown.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionUnknown.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.OptionComplexFactory`1.OptionHeaderLength">
            <summary>
            The header length in bytes for the option (type and size).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Address">
            <summary>
            Represents an IPv4 address.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Address.SizeOf">
            <summary>
            The number of bytes the address take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.#ctor(System.UInt32)">
            <summary>
            Create an address from a 32 bit integer.
            0 -> 0.0.0.0
            1 -> 0.0.0.1
            256 -> 0.0.1.0
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.#ctor(System.String)">
            <summary>
            Creates an address from an address string (1.2.3.4).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.ToValue">
            <summary>
            Gets the address value as a 32 bit integer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.Equals(PcapDotNet.Packets.IpV4.IpV4Address)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.Equals(System.Object)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.op_Equality(PcapDotNet.Packets.IpV4.IpV4Address,PcapDotNet.Packets.IpV4.IpV4Address)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.op_Inequality(PcapDotNet.Packets.IpV4.IpV4Address,PcapDotNet.Packets.IpV4.IpV4Address)">
            <summary>
            Two addresses are different if the have different values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.GetHashCode">
            <summary>
            The hash code of an address is the hash code of its 32 bit integer value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Address.ToString">
            <summary>
            Translates the address to a string (1.2.3.4).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Address.Zero">
            <summary>
            The zero address (0.0.0.0).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Address.AllHostsGroupAddress">
            <summary>
            The all-hosts group. 
            If you ping that group, all multicast capable hosts on the network should answer, 
            as every multicast capable host must join that group at start-up on all it's multicast capable interfaces. 
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IIpV4NextTransportLayer">
            <summary>
            A Transport layer under an IPv4 layer.
            Must supply information about the Transport layer checksum.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IIpV4NextTransportLayer.Checksum">
            <summary>
            Checksum is the 16-bit one's complement of the one's complement sum of a pseudo header of information from the IP header, 
            the Transport header, and the data, padded with zero octets at the end (if necessary) to make a multiple of two octets.
            If null is given, the Checksum will be calculated to be correct according to the data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IIpV4NextTransportLayer.CalculateChecksum">
            <summary>
            Whether the checksum should be calculated.
            Can be false in UDP because the checksum is optional. false means that the checksum will be left zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IIpV4NextTransportLayer.ChecksumOffset">
            <summary>
            The offset in the layer where the checksum should be written.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IIpV4NextTransportLayer.IsChecksumOptional">
            <summary>
            Whether the checksum is optional in the layer.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer">
            <summary>
            RFC 3376.
            Represents an IGMP Report version 3 layer.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpLayer">
            <summary>
            The base of all IGMP layers.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpLayer.Equals(PcapDotNet.Packets.Igmp.IgmpLayer)">
            <summary>
            IGMP layers are equal if they have the same message type, query version, similar max response time and the same specific type fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            IGMP layers are equal if they have the same message type, query version, similar max response time and the same specific type fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpLayer.GetHashCode">
            <summary>
            Xor of the hash codes of the layer length, datalink, message type and query version.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpLayer.EqualFields(PcapDotNet.Packets.Igmp.IgmpLayer)">
            <summary>
            true iff the fields that are not mutual to all IGMP layers are equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpLayer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpLayer.QueryVersion">
            <summary>
            The IGMP version of a Membership Query message.
            If the type is not a query, None will be returned.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpLayer.MaxResponseTimeValue">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.#ctor">
            <summary>
            Creates an instance of an IGMP Report Version 3 Layer with a default of no Group Records.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.GetHashCode">
            <summary>
            Xor of the hash codes of the layer length, datalink, message type, query version and the group records.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.EqualFields(PcapDotNet.Packets.Igmp.IgmpLayer)">
            <summary>
            true iff the group records are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.EqualFields(PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer)">
            <summary>
            true iff the group records are equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.GroupRecords">
            <summary>
            Each Group Record is a block of fields containing information pertaining to the sender's membership in a single multicast group on the interface from which the Report is sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion3Layer.MaxResponseTimeValue">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpUnknownDatagram">
            <summary>
            Used to represent an ICMP datagram with an unknown message type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpUnknownDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpUnknownDatagram.CalculateIsValid">
            <summary>
            Unknown ICMP datagrams are always invalid.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpUnknownDatagram.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Take only part of the bytes as a datagarm.
            </summary>
            <param name="buffer">The bytes to take the datagram from.</param>
            <param name="offset">The offset in the buffer to start taking the bytes from.</param>
            <param name="length">The number of bytes to take.</param>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpParameterProblemDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+---------+------+-----------+
            | Bit | 0-7     | 8-15 | 16-31     |
            +-----+---------+------+-----------+
            | 0   | Type    | Code | Checksum  |
            +-----+---------+------+-----------+
            | 32  | Pointer | unused           |
            +-----+---------+------------------+
            | 64  | Internet Header            |
            |     | + 64 bits of               |
            |     | Original Data Datagram     |
            +-----+----------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpParameterProblemDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpParameterProblemDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct, the code is in the expected range,
            the IPv4 payload contains at least an IPv4 header, the IPv4's payload is in the expected size
            and the pointer points to a byte within the IPv4 header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpParameterProblemDatagram.Pointer">
            <summary>
            The pointer identifies the octet of the original datagram's header where the error was detected (it may be in the middle of an option).  
            For example, 1 indicates something is wrong with the Type of Service, and (if there are options present) 20 indicates something is wrong with the type code of the first option.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpSourceQuenchLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSourceQuenchLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpSourceQuenchDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | unused                  |
            +-----+-------------------------+
            | 64  | Internet Header         |
            |     | + 64 bits of            |
            |     | Original Data Datagram  |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpSourceQuenchDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpEchoReplyDatagram">
            <summary>
            Echo Reply
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 0   | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 32  | Data...                       |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpIdentifiedDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            </pre>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIdentifiedDatagram.Identifier">
            <summary>
            An identifier to aid in matching requests and replies, may be zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpIdentifiedDatagram.SequenceNumber">
            <summary>
            A sequence number to aid in matching requests and replies, may be zero.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpEchoReplyDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpDomainNameRequestLayer">
            <summary>
            RFC 1788.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDomainNameRequestLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown">
            <summary>
            Represents a source route entry consisting of an unknown data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreSourceRouteEntry">
            <summary>
            RFC 1701.
            SRE.
            <pre>
            +-----+----------------+------------+------------+
            | Bit | 0-15           | 16-23      | 24-31      |
            +-----+----------------+------------+------------+
            | 0   | Address Family | SRE Offset | SRE Length |
            +-----+----------------+------------+------------+
            | 32  | Routing Information ...                  |
            +-----+------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreSourceRouteEntry.HeaderLength">
            <summary>
            The number of bytes the entry header takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntry.Equals(PcapDotNet.Packets.Gre.GreSourceRouteEntry)">
            <summary>
            Two entries are equal iff they have the same address family, length, payload offset and payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntry.Equals(System.Object)">
            <summary>
            Two entries are equal iff they have the same address family, length, payload offset and payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntry.GetHashCode">
            <summary>
            The hash code of an entry is a xor of the hash code of the address family, length, payload offset and payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntry.EqualsPayloads(PcapDotNet.Packets.Gre.GreSourceRouteEntry)">
            <summary>
            True iff the payloads a are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntry.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the payload to the given buffer in the given offset.
            </summary>
            <param name="buffer">The buffer to write the payload to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntry.AddressFamily">
            <summary>
            The Address Family field contains a two octet value which indicates the syntax and semantics of the Routing Information field.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntry.Length">
            <summary>
            The number of bytes the entry takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntry.PayloadOffset">
            <summary>
            The SRE Offset field indicates the octet offset from the start of the Routing Information field to the first octet of the active entry in Source Route Entry to be examined.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntry.PayloadLength">
            <summary>
            The SRE Length field contains the number of octets in the SRE.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntry.PayloadHashCode">
            <summary>
            The hash code of the payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.#ctor(PcapDotNet.Packets.Gre.GreSourceRouteEntryAddressFamily,PcapDotNet.Packets.Datagram,System.Int32)">
            <summary>
            Initializes using an address family, data, and offset to the first octet of the active entry in Source Route Entry to be examined.
            </summary>
            <param name="addressFamily">The Address Family field contains a two octet value which indicates the syntax and semantics of the Routing Information field.</param>
            <param name="data">The data of the entry source route.</param>
            <param name="offset">The SRE Offset field indicates the octet offset from the start of the Routing Information field to the first octet of the active entry in Source Route Entry to be examined.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.EqualsPayloads(PcapDotNet.Packets.Gre.GreSourceRouteEntry)">
            <summary>
            True iff the payloads a are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the payload to the given buffer in the given offset.
            </summary>
            <param name="buffer">The buffer to write the payload to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.AddressFamily">
            <summary>
            The Address Family field contains a two octet value which indicates the syntax and semantics of the Routing Information field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.PayloadLength">
            <summary>
            The SRE Length field contains the number of octets in the SRE.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.PayloadOffset">
            <summary>
            The SRE Offset field indicates the octet offset from the start of the Routing Information field to the first octet of the active entry in Source Route Entry to be examined.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.Data">
            <summary>
            The data of the entry source route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryUnknown.PayloadHashCode">
            <summary>
            The hash code of the payload.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Endianity">
            <summary>
            The two possible endianities.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Endianity.Small">
            <summary>
            Small endianity - bytes are read from the high offset to the low offset.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Endianity.Big">
            <summary>
            Big endianity - bytes are read from the low offset to the high offset.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.DataLinkKind">
            <summary>
            Represents the different data links kinds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.DataLinkKind.Ethernet">
            <summary>
            Ethernet data link kind.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.DataLinkKind.Docsis">
            <summary>
            Data Over Cable Service Interface Specification.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Arp.ArpLayer">
            <summary>
            Represents an ARP protocol layer.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.IEthernetNextLayer">
            <summary>
            A layer under an Ethernet layer.
            Must provide the Ethernet Type and the default destination MAC address (if any).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.IEthernetNextLayer.PreviousLayerEtherType">
            <summary>
            The Ethernet Type the Ethernet layer should write when this layer is the Ethernet payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.IEthernetNextLayer.PreviousLayerDefaultDestination">
            <summary>
            The default MAC Address value when this layer is the Ethernet payload.
            null means there is no default value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpLayer.Equals(PcapDotNet.Packets.Arp.ArpLayer)">
            <summary>
            True iff the two ARP layers have equal protocol type, operation and addresses.
            </summary>
            <param name="other">The ARP layer to compare the layer to.</param>
            <returns>True iff the two layers are equal.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            True iff the two ARP layers have equal protocol type, operation and addresses.
            </summary>
            <param name="other">The ARP layer to compare the layer to.</param>
            <returns>True iff the two layers are equal.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpLayer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code is a XOR of a combination of the protocol type and operation and the hash codes of the layer length and data link.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.ProtocolType">
            <summary>
            Each protocol is assigned a number used in this field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.Operation">
            <summary>
            Specifies the operation the sender is performing.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.SenderHardwareAddress">
            <summary>
            Hardware address of the sender.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.SenderProtocolAddress">
            <summary>
            Protocol address of the sender.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.TargetHardwareAddress">
            <summary>
            Hardware address of the intended receiver. 
            This field is ignored in requests.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.TargetProtocolAddress">
            <summary>
            Protocol address of the intended receiver.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.PreviousLayerEtherType">
            <summary>
            The Ethernet Type the Ethernet layer should write when this layer is the Ethernet payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.PreviousLayerDefaultDestination">
            <summary>
            The default MAC Address value when this layer is the Ethernet payload.
            null means there is no default value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.UdpLayer">
            <summary>
            RFC 768.
            Represents the UDP layer.
            <seealso cref="T:PcapDotNet.Packets.Transport.UdpDatagram"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TransportLayer">
            <summary>
            Contains the common part of UDP and TCP layers.
            <seealso cref="T:PcapDotNet.Packets.Transport.TransportDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TransportLayer.Equals(PcapDotNet.Packets.Transport.TransportLayer)">
            <summary>
            Two Transport layers are equal if they have they have the same previous layer protocol value, checksum, source and destination ports, 
            and if the specific transport protocol fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TransportLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            Two Transport layers are equal if they have they have the same previous layer protocol value, checksum, source and destination ports, 
            and if the specific transport protocol fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TransportLayer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code is a XOR of the combination of the source and destination ports and the hash codes of the layer length, data link and checksum.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TransportLayer.EqualFields(PcapDotNet.Packets.Transport.TransportLayer)">
            <summary>
            True iff the specific transport layer fields are equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.Checksum">
            <summary>
            Checksum is the 16-bit one's complement of the one's complement sum of a pseudo header of information from the IP header, 
            the Transport header, and the data, padded with zero octets at the end (if necessary) to make a multiple of two octets.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.SourcePort">
            <summary>
            Indicates the port of the sending process.
            In UDP, this field is optional and may only be assumed to be the port 
            to which a reply should be addressed in the absence of any other information.
            If not used in UDP, a value of zero is inserted.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.DestinationPort">
            <summary>
            Destination Port has a meaning within the context of a particular internet destination address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.CalculateChecksum">
            <summary>
            Whether the checksum should be calculated.
            Can be false in UDP because the checksum is optional. false means that the checksum will be left zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.ChecksumOffset">
            <summary>
            The offset in the layer where the checksum should be written.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportLayer.IsChecksumOptional">
            <summary>
            Whether the checksum is optional in the layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.UdpLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.CalculateChecksum">
            <summary>
            Whether the checksum should be calculated.
            Can be false in UDP because the checksum is optional. false means that the checksum will be left zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.CalculateChecksumValue">
            <summary>
            Whether the checksum should be calculated.
            Can be false in UDP because the checksum is optional. false means that the checksum will be left zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.ChecksumOffset">
            <summary>
            The offset in the layer where the checksum should be written.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.IsChecksumOptional">
            <summary>
            Whether the checksum is optional in the layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.PayloadLayer">
            <summary>
            Represents a layer that adds a simple payload.
            Actually can be any buffer of bytes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.PayloadLayer.#ctor">
            <summary>
            Creates an empty payload.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.PayloadLayer.Equals(PcapDotNet.Packets.PayloadLayer)">
            <summary>
            Two payload layers are equal if they have same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.PayloadLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            Two payload layers are equal if they have same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.PayloadLayer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="P:PcapDotNet.Packets.PayloadLayer.Data">
            <summary>
            The Payload data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.PayloadLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionType">
            <summary>
            The option-type octet is viewed as having 3 fields:
            <list type="table">
              <listheader>
                  <term>Bits</term>
                  <description>Description</description>
              </listheader>
              <item><term>1 bit</term>
                <description>
                  Copied flag.
                  <para>
                    The copied flag indicates that this option is copied into all fragments on fragmentation.
                    <list type="bullet">
                      <item>0 = not copied.</item>
                      <item>1 = copied.</item>
                    </list>
                  </para>
                </description>
              </item>
              <item><term>2 bits</term>
                <description>
                  Option class.
                  <para>
                    The option classes are:
                    <list type="bullet">
                      <item>0 = control.</item>
                      <item>1 = reserved for future use.</item>
                      <item>2 = debugging and measurement.</item>
                      <item>3 = reserved for future use.</item>
                    </list>
                  </para>
                </description>
              </item>
              <item><term>5 bits</term><description>Option number.</description></item>
            </list>
            </summary>
            <remarks>
            <list type="bullet">
              <item>DoD Extended Security Option (133), RFC 1108, is not supported because it only defines abstract option and no concrete option RFC is available.</item>
              <item>EIP: The Extended Internet Protocol, RFC 1385, is not supported because according iana.org its option type is 145 but according to the RFC its option type is 138 (0x8A).</item>
            </list>
            </remarks>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.EndOfOptionList">
            <summary>
            End of Option list.  
            This option occupies only 1 octet; it has no length octet.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.NoOperation">
            <summary>
            No Operation.  
            This option occupies only 1 octet; it has no length octet.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.QuickStart">
            <summary>
            Quick Start (QS). RFC 4782.  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.TraceRoute">
            <summary>
            Traceroute Using an IP Option.
            RFC 1393.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.BasicSecurity">
            <summary>
            DoD Basic Security:  
            Used to carry the classification level and protection authority flags.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.LooseSourceRouting">
            <summary>
            Loose Source Routing.
            Used to route the internet datagram based on information supplied by the source.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.StrictSourceRouting">
            <summary>
            Strict Source Routing.  
            Used to route the internet datagram based on information supplied by the source.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.RecordRoute">
            <summary>
            Record Route.  
            Used to trace the route an internet datagram takes.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.StreamIdentifier">
            <summary>
            Stream ID.  
            Used to carry the stream identifier.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.InternetTimestamp">
            <summary>
            Internet Timestamp.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionType.RouterAlert">
            <summary>
            Router Alert Option (RFC 2113).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IIgmpLayerWithGroupAddress">
            <summary>
            Represents an IGMP layer that contains a Group Address.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IIgmpLayerWithGroupAddress.GroupAddress">
            <summary>
            The Group Address field is set to zero when sending a General Query, 
            and set to the IP multicast address being queried when sending a Group-Specific Query or Group-and-Source-Specific Query.
            In a Membership Report of version 1 or 2 or Leave Group message, the group address field holds the IP multicast group address of the group being reported or left.
            In a Membership Report of version 3 this field is meaningless.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpMessageType">
            <summary>
            The type of the IGMP message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.None">
            <summary>
            Illegal type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.CreateGroupRequestVersion0">
            <summary>
            Create Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.CreateGroupReplyVersion0">
            <summary>
            Create Group Reply (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.JoinGroupRequestVersion0">
            <summary>
            Join Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.JoinGroupReplyVersion0">
            <summary>
            Join Group Reply (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.LeaveGroupRequestVersion0">
            <summary>
            Leave Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.LeaveGroupReplyVersion0">
            <summary>
            Leave Group Reply (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.ConfirmGroupRequestVersion0">
            <summary>
            Confirm Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.ConfirmGroupReplyVersion0">
            <summary>
            Confirm Group Reply (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.MembershipQuery">
            <summary>
            Membership Query (RFC3376).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.MembershipReportVersion3">
            <summary>
            Version 3 Membership Report (RFC3376).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.MembershipReportVersion1">
            <summary>
            Version 1 Membership Report (RFC1112).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.MembershipReportVersion2">
            <summary>
            Version 2 Membership Report (RFC2236).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.LeaveGroupVersion2">
            <summary>
            Version 2 Leave Group (RFC2236).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpMessageType.MulticastTraceRouteResponse">
            <summary>
            Multicast Traceroute Response.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpEchoDatagram">
            <summary>
            Echo
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 0   | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 32  | Data...                       |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpEchoDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpEchoLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpEchoLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted">
            <summary>
            Sack-Permitted Option (RFC 2018)
            This two-byte option may be sent in a SYN by a TCP that has been extended to receive (and presumably process) 
            the SACK option once the connection has opened.  
            It MUST NOT be sent on non-SYN segments.
            
            <pre>
            +---------+---------+
            | Kind=4  | Length=2|
            +---------+---------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.#ctor">
            <summary>
            Creates a selective ack permitted option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.Equals(PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted)">
            <summary>
            Two selective ack permitted options are always equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two selective ack permitted options are always equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentPermitted.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment">
            <summary>
            The SACK option is to be used to convey extended acknowledgment information from the receiver to the sender over an established TCP connection.
            
            <pre>
                              +--------+--------+
                              | Kind=5 | Length |
            +--------+--------+--------+--------+
            |      Left Edge of 1st Block       |
            +--------+--------+--------+--------+
            |      Right Edge of 1st Block      |
            +--------+--------+--------+--------+
            |                                   |
            /            . . .                  /
            |                                   |
            +--------+--------+--------+--------+
            |      Left Edge of nth Block       |
            +--------+--------+--------+--------+
            |      Right Edge of nth Block      |
            +--------+--------+--------+--------+
            </pre>
            
            <para>
            The SACK option is to be sent by a data receiver to inform the data sender of non-contiguous blocks of data that have been received and queued.  
            The data receiver awaits the receipt of data (perhaps by means of retransmissions) to fill the gaps in sequence space between received blocks.  
            When missing segments are received, the data receiver acknowledges the data normally by advancing 
            the left window edge in the Acknowledgement Number Field of the TCP header.  
            The SACK option does not change the meaning of the Acknowledgement Number field.
            </para>
            
            <para>
            This option contains a list of some of the blocks of contiguous sequence space occupied by data that has been received and queued within the window.
            Each contiguous block of data queued at the data receiver is defined in the SACK option by two 32-bit unsigned integers in network byte order:
            <list type="bullet">
              <item>Left Edge of Block - This is the first sequence number of this block.</item>
              <item>Right Edge of Block - This is the sequence number immediately following the last sequence number of this block.</item>
            </list>
            </para>
            Each block represents received bytes of data that are contiguous and isolated; 
            that is, the bytes just below the block, (Left Edge of Block - 1), and just above the block, (Right Edge of Block), have not been received.
            
            A SACK option that specifies n blocks will have a length of 8*n+2 bytes, so the 40 bytes available for TCP options can specify a maximum of 4 blocks.
            It is expected that SACK will often be used in conjunction with the Timestamp option used for RTTM [Jacobson92], 
            which takes an additional 10 bytes (plus two bytes of padding); thus a maximum of 3 SACK blocks will be allowed in this case.
            
            The SACK option is advisory, in that, while it notifies the data sender that the data receiver has received the indicated segments,
            the data receiver is permitted to later discard data which have been reported in a SACK option.  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock})">
            <summary>
            Creates the option from the given list of selective ack blocks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.#ctor">
            <summary>
            The default is no blocks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.Equals(PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment)">
            <summary>
            Two selective ack options are equal if they have the same selective ack blocks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two selective ack options are equal if they have the same selective ack blocks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.GetHashCode">
            <summary>
            The hash code of the selective acknowledgement option is the hash code of the option type xored with all the hash codes of the blocks.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.Blocks">
            <summary>
            The collection of selective ack blocks.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgment.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted">
            <summary>
            TCP POC-permitted Option (RFC 1693)
            <pre>
            +-----------+-------------+
            |  Kind=9   |  Length=2   |
            +-----------+-------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.#ctor">
            <summary>
            Creates a partial order connection permitted option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.Equals(PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted)">
            <summary>
            Two partial order connection permitted options are always equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two partial order connection permitted options are always equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderConnectionPermitted.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionConnectionCountEcho">
            <summary>
            CC.ECHO Option (RFC 1644).
            <pre>
            +--------+--------+--------+--------+--------+--------+
            |00001101|00000110|    Connection Count:  SEG.CC      |
            +--------+--------+--------+--------+--------+--------+
             Kind=13  Length=6
            </pre>
            
            <para>
            This option must be sent (in addition to a CC option) in a segment containing both a SYN and an ACK bit, 
            if the initial SYN segment contained a CC or CC.NEW option.  
            Its SEG.CC value is the SEG.CC value from the initial SYN.
            </para>
            
            <para>
            A CC.ECHO option should be sent only in a &lt;SYN,ACK&gt; segment and should be ignored if it is received in any other segment.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase">
            <summary>
            The base class for connection count TCP options.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.Equals(PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase)">
            <summary>
            Two connection count options are equal of they are of the same option type and have the same connection count.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two connection count options are equal of they are of the same option type and have the same connection count.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.GetHashCode">
            <summary>
            The hash code of the connection count option is the hash code of the option type xored with the hash code of the connection count.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.#ctor(PcapDotNet.Packets.Transport.TcpOptionType,System.UInt32)">
            <summary>
            Creates a connection count option according to the given option type and given connection count value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.TryRead(System.UInt32@,System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Reads the connection count value from the buffer.
            </summary>
            <param name="connectionCount">The result connection count.</param>
            <param name="buffer">The buffer to read the connection count from.</param>
            <param name="offset">The offset to start reading the connection byte from.</param>
            <param name="valueLength">The number of bytes available for read in this buffer.</param>
            <returns>True iff the connection count could be read (there were enough bytes to read).</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.ConnectionCount">
            <summary>
            The connection count value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionConnectionCountBase.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountEcho.#ctor(System.UInt32)">
            <summary>
            Creates the option using the given connection count value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountEcho.#ctor">
            <summary>
            The default connection count value is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountEcho.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpDatagram">
            <summary>
            RFC 793.
            TCP Header Format
            <pre>
            +-----+-------------+----------+----+-----+-----+-----+-----+-----+-----+-----+-----+------------------+
            | Bit | 0-3         | 4-6      | 7  | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16-31            |
            +-----+-------------+----------+----+-----+-----+-----+-----+-----+-----+-----+-----+------------------+
            | 0   | Source Port                                                                 | Destination Port |
            +-----+-----------------------------------------------------------------------------+------------------+
            | 32  | Sequence Number                                                                                |
            +-----+------------------------------------------------------------------------------------------------+
            | 64  | Acknowledgment Number                                                                          |
            +-----+-------------+----------+----+-----+-----+-----+-----+-----+-----+-----+-----+------------------+
            | 96  | Data Offset | Reserved | NS | CWR | ECE | URG | ACK | PSH | RST | SYN | FIN | Window           |
            +-----+-------------+----------+----+-----+-----+-----+-----+-----+-----+-----+-----+------------------+
            | 128 | Checksum                                                                    | Urgent Pointer   |
            +-----+-----------------------------------------------------------------------------+------------------+
            | 160 | Options + Padding                                                                              |
            +-----+------------------------------------------------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TransportDatagram">
            <summary>
            Contains the common part of UDP and TCP.
            
            <para>
            Format:
            <pre>
            +-----+-------------+----------+-----+-----+-----+-----+-----+-----+------------------+
            | Bit | 0-4         | 4-9      | 10  | 11  | 12  | 13  | 14  | 15  | 16-31            |
            +-----+-------------+----------+-----+-----+-----+-----+-----+-----+------------------+
            | 0   | Source Port                                                | Destination Port |
            +-----+------------------------------------------------------------+------------------+
            | 32  | Sequence Number                                                               |
            +-----+-------------------------------------------------------------------------------+
            </pre>
            </para>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportDatagram.SourcePort">
            <summary>
            Indicates the port of the sending process.
            In UDP, this field is optional and may only be assumed to be the port 
            to which a reply should be addressed in the absence of any other information.
            If not used in UDP, a value of zero is inserted.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportDatagram.DestinationPort">
            <summary>
            Destination Port has a meaning within the context of a particular internet destination address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportDatagram.Checksum">
            <summary>
            Checksum is the 16-bit one's complement of the one's complement sum of a pseudo header of information from the IP header, 
            the Transport header, and the data, padded with zero octets at the end (if necessary) to make a multiple of two octets.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TransportDatagram.IsChecksumOptional">
            <summary>
            True iff the checksum for the transport type is optional.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpDatagram.HeaderMinimumLength">
            <summary>
            The minimum number of bytes the header takes.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpDatagram.HeaderMaximumLength">
            <summary>
            The maximum number of bytes the header takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpDatagram.CalculateIsValid">
            <summary>
            The datagram is valid if the length is correct according to the header and the options are valid.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.SequenceNumber">
            <summary>
            The sequence number of the first data octet in this segment (except when SYN is present). 
            If SYN is present the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.NextSequenceNumber">
            <summary>
            The sequence number of the data that will come after this data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.AcknowledgmentNumber">
            <summary>
            If the ACK control bit is set this field contains the value of the next sequence number 
            the sender of the segment is expecting to receive.  
            Once a connection is established this is always sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.HeaderLength">
            <summary>
            The number of bytes in the TCP Header.
            This indicates where the data begins.
            The TCP header (even one including options) is an integral number of 32 bits (4 bytes) long.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.RealHeaderLength">
            <summary>
            Returns the actual header length.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.ControlBits">
            <summary>
            A collection of bits for the TCP control.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.Window">
            <summary>
            The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.Checksum">
            <summary>
            The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header and text.  
            If a segment contains an odd number of header and text octets to be checksummed, 
            the last octet is padded on the right with zeros to form a 16 bit word for checksum purposes.  
            The pad is not transmitted as part of the segment.  
            While computing the checksum, the checksum field itself is replaced with zeros.
            
            The checksum also covers a 96 bit pseudo header conceptually prefixed to the TCP header.  
            This pseudo header contains the Source Address, the Destination Address, the Protocol, and TCP length.
            This gives the TCP protection against misrouted segments.  
            This information is carried in the Internet Protocol and is transferred across the TCP/Network interface in the arguments or results of calls 
            by the TCP on the IP.
            
            +--------+--------+--------+--------+
            |           Source Address          |
            +--------+--------+--------+--------+
            |         Destination Address       |
            +--------+--------+--------+--------+
            |  zero  |  PTCL  |    TCP Length   |
            +--------+--------+--------+--------+
            
            The TCP Length is the TCP header length plus the data length in octets (this is not an explicitly transmitted quantity, but is computed), 
            and it does not count the 12 octets of the pseudo header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsChecksumOptional">
            <summary>
            True iff the checksum for the transport type is optional.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.UrgentPointer">
            <summary>
            This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.  
            The urgent pointer points to the sequence number of the octet following the urgent data.  
            This field is only be interpreted in segments with the URG control bit set.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.Options">
            <summary>
            Returns the TCP options contained in this TCP Datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.PayloadLength">
            <summary>
            The length of the TCP payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsCongestionWindowReduced">
            <summary>
            True iff the CongestionWindowReduced control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsExplicitCongestionNotificationEcho">
            <summary>
            True iff the ExplicitCongestionNotificationEcho control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsUrgent">
            <summary>
            True iff the Urgent control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsAcknowledgment">
            <summary>
            True iff the Acknowledgment control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsPush">
            <summary>
            True iff the Push control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsReset">
            <summary>
            True iff the Reset control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsSynchronize">
            <summary>
            True iff the Synchronize control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.IsFin">
            <summary>
            True iff the Fin control bit is turned on.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.Http">
            <summary>
            The first HTTP message in this TCP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.HttpCollection">
            <summary>
            All of the available HTTP messages in this TCP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpDatagram.Payload">
            <summary>
            The payload of the TCP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpLayer">
            <summary>
            RFC 793.
            Represents the TCP layer.
            <seealso cref="T:PcapDotNet.Packets.Transport.TcpDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpLayer.#ctor">
            <summary>
            Default constructor.
            No TCP options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpLayer.EqualFields(PcapDotNet.Packets.Transport.TransportLayer)">
            <summary>
            True iff the SequenceNumber, AcknowledgmentNumber, ControlBits, Window, UrgentPointer and Options fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpLayer.EqualFields(PcapDotNet.Packets.Transport.TcpLayer)">
            <summary>
            True iff the SequenceNumber, AcknowledgmentNumber, ControlBits, Window, UrgentPointer and Options fields are equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.SequenceNumber">
            <summary>
            The sequence number of the first data octet in this segment (except when SYN is present). 
            If SYN is present the sequence number is the initial sequence number (ISN) and the first data octet is ISN+1.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.AcknowledgmentNumber">
            <summary>
            If the ACK control bit is set this field contains the value of the next sequence number 
            the sender of the segment is expecting to receive.  
            Once a connection is established this is always sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.ControlBits">
            <summary>
            A collection of bits for the TCP control.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.Window">
            <summary>
            The number of data octets beginning with the one indicated in the acknowledgment field which the sender of this segment is willing to accept.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.UrgentPointer">
            <summary>
            This field communicates the current value of the urgent pointer as a positive offset from the sequence number in this segment.  
            The urgent pointer points to the sequence number of the octet following the urgent data.  
            This field is only be interpreted in segments with the URG control bit set.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.Options">
            <summary>
            The TCP options contained in this TCP Datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.ChecksumOffset">
            <summary>
            The offset in the layer where the checksum should be written.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.IsChecksumOptional">
            <summary>
            Whether the checksum is optional in the layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpRecordType">
            <summary>
            Group Record Type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.None">
            <summary>
            Illegal record type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.CurrentStateRecordModeIsInclude">
            <summary>
            A "Current-State Record" is sent by a system in response to a Query received on an interface. 
            It reports the current reception state of that interface, with respect to a single multicast address.
            <para>
            MODE_IS_INCLUDE - indicates that the interface has a filter mode of INCLUDE for the specified multicast address.  
            The Source Address [i] fields in this Group Record contain the interface's source list for the specified multicast address, if it is non-empty.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.CurrentStateRecordModeIsExclude">
            <summary>
            A "Current-State Record" is sent by a system in response to a Query received on an interface. 
            It reports the current reception state of that interface, with respect to a single multicast address.
            <para>
            MODE_IS_EXCLUDE - indicates that the interface has a filter mode of EXCLUDE for the specified multicast address.  
            The Source Address [i] fields in this Group Record contain the interface's source list for the specified multicast address, if it is non-empty.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.FilterModeChangeToInclude">
            <summary>
            A "Filter-Mode-Change Record" is sent by a system whenever a local invocation of IPMulticastListen causes a change of the filter mode
            (i.e., a change from INCLUDE to EXCLUDE, or from EXCLUDE to INCLUDE), 
            of the interface-level state entry for a particular multicast address.  
            The Record is included in a Report sent from the interface on which the change occurred.
            <para>
            CHANGE_TO_INCLUDE_MODE - indicates that the interface has changed to INCLUDE filter mode for the specified multicast address.  
            The Source Address [i] fields in this Group Record contain the interface's new source list for the specified multicast address, if it is non-empty.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.FilterModeChangeToExclude">
            <summary>
            A "Filter-Mode-Change Record" is sent by a system whenever a local invocation of IPMulticastListen causes a change of the filter mode
            (i.e., a change from INCLUDE to EXCLUDE, or from EXCLUDE to INCLUDE), 
            of the interface-level state entry for a particular multicast address.  
            The Record is included in a Report sent from the interface on which the change occurred.
            <para>
            CHANGE_TO_EXCLUDE_MODE - indicates that the interface has changed to EXCLUDE filter mode for the specified multicast address.  
            The Source Address [i] fields in this Group Record contain the interface's new source list for the specified multicast address, if it is non-empty.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.SourceListChangeAllowNewSources">
            <summary>
            A "Source-List-Change Record" is sent by a system whenever a local invocation of IPMulticastListen causes a change of source list 
            that is *not* coincident with a change of filter mode, of the interface-level state entry for a particular multicast address.
            The Record is included in a Report sent from the interface on which the change occurred.
            <para>
            ALLOW_NEW_SOURCES - indicates that the Source Address [i] fields in this Group Record contain a list of the additional sources 
            that the system wishes to hear from, for packets sent to the specified multicast address.  
            If the change was to an INCLUDE source list, these are the addresses that were added to the list; if the change was to an EXCLUDE source list, 
            these are the addresses that were deleted from the list.
            </para>
            <para>
            If a change of source list results in both allowing new sources and blocking old sources, 
            then two Group Records are sent for the same multicast address, one of type ALLOW_NEW_SOURCES and one of type BLOCK_OLD_SOURCES.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpRecordType.SourceListChangeBlockOldSources">
            <summary>
            A "Source-List-Change Record" is sent by a system whenever a local invocation of IPMulticastListen causes a change of source list 
            that is *not* coincident with a change of filter mode, of the interface-level state entry for a particular multicast address.
            The Record is included in a Report sent from the interface on which the change occurred.
            <para>
            BLOCK_OLD_SOURCES - indicates that the Source Address [i] fields in this Group Record contain a list of the sources 
            that the system no longer wishes to hear from, for packets sent to the specified multicast address.  
            If the change was to an INCLUDE source list, these are the addresses that were deleted from  the list; if the change was to an EXCLUDE source list, 
            these are the addresses that were added to the list.
            </para>
            <para>
            If a change of source list results in both allowing new sources and blocking old sources, 
            then two Group Records are sent for the same multicast address, one of type ALLOW_NEW_SOURCES and one of type BLOCK_OLD_SOURCES.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpQueryVersion1Layer">
            <summary>
            RFC 1112.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpVersion1Layer">
            <summary>
            RFC 1112.
            Represents an IGMP version 1 layer.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpSimpleLayer">
            <summary>
            Represents a Simple IGMP layer.
            A simple layer only has the 8 bytes header without additional fields.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.GetHashCode">
            <summary>
            Xor of the hash codes of the layer length, datalink, message type, query version and group address.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.EqualFields(PcapDotNet.Packets.Igmp.IgmpLayer)">
            <summary>
            true iff the the group address is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.EqualFields(PcapDotNet.Packets.Igmp.IgmpSimpleLayer)">
            <summary>
            true iff the the group address is equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.GroupAddress">
            <summary>
            The Group Address field is set to zero when sending a General Query, 
            and set to the IP multicast address being queried when sending a Group-Specific Query or Group-and-Source-Specific Query.
            In a Membership Report of version 1 or 2 or Leave Group message, the group address field holds the IP multicast group address of the group being reported or left.
            In a Membership Report of version 3 this field is meaningless.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpSimpleLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpVersion1Layer.MaxResponseTimeValue">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion1Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion1Layer.QueryVersion">
            <summary>
            The IGMP version of a Membership Query message.
            If the type is not a query, None will be returned.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram">
            <summary>
            RFC 2521.
            <pre>
            +-----+------+------+----------+
            | Bit | 0-7  | 8-15 | 16-31    |
            +-----+------+------+----------+
            | 0   | Type | Code | Checksum |
            +-----+------+------+----------+
            | 32  | Reserved    | Pointer  |
            +-----+-------------+----------+
            | 64  | Internet Header        |
            |     | + 64 bits of           |
            |     | Original Data Datagram |
            +-----+------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct, the code is in the expected range,
            the IPv4 payload contains at least an IPv4 header, the IPv4's payload is in the expected size and the Pointer points to a byte in the IPv4 payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram.Pointer">
            <summary>
            An offset into the Original Internet Headers that locates the most significant octet of the offending SPI.  
            Will be zero when no SPI is present.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpSecurityFailuresDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRouterSolicitationLayer">
            <summary>
            RFC 1256.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterSolicitationLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRedirectLayer">
            <summary>
            RFC 792.
            Represents an ICMP Redirect message layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram"/>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectLayer.GatewayInternetAddress">
            <summary>
            Address of the gateway to which traffic for the network specified in the internet destination network field of the original datagram's data should be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpEchoReplyLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpEchoReplyLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeRedirect">
            <summary>
            The different ICMP code values for Redirect ICMP type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeRedirect.ForTheNetwork">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeRedirect.ForTheHost">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeRedirect.ForTheTypeOfServiceAndNetwork">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeRedirect.ForTheTypeOfServiceAndHost">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Packet">
            <summary>
            A raw packet.
            Includes all packet layers as taken from an adapter including the type of the datalink.
            Immutable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.FromHexadecimalString(System.String,System.DateTime,PcapDotNet.Packets.DataLinkKind)">
            <summary>
            Creates a packet from a string that represents bytes in a hexadecimal format.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.#ctor(System.Byte[],System.DateTime,PcapDotNet.Packets.DataLinkKind)">
            <summary>
            Create a packet from an array of bytes.
            </summary>
            <param name="data">The bytes of the packet. This array should not be changed after creating the packet until the packet is no longer used.</param>
            <param name="timestamp">A timestamp of the packet - when it was captured.</param>
            <param name="dataLink">The type of the datalink of the packet.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.#ctor(System.Byte[],System.DateTime,PcapDotNet.Packets.IDataLink)">
            <summary>
            Create a packet from an array of bytes.
            </summary>
            <param name="data">The bytes of the packet. This array should not be changed after creating the packet until the packet is no longer used.</param>
            <param name="timestamp">A timestamp of the packet - when it was captured.</param>
            <param name="dataLink">The type of the datalink of the packet.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Equals(PcapDotNet.Packets.Packet)">
            <summary>
            Equals means that the packets have equal data.
            </summary>
            <param name="other">The packet to compare this packet to.</param>
            <returns>True iff the packets have equal data.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Equals(System.Object)">
            <summary>
            Equals means that the packets have equal data.
            </summary>
            <param name="obj">The packet to compare this packet to.</param>
            <returns>True iff the packets have equal data.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.GetHashCode">
            <summary>
            The hash code of a packet is the xor of all its bytes. Each byte is xored with the next 8 bits of the integer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.ToString">
            <summary>
            The Packet string contains the datalink and the length.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the bytes of the packet.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.IndexOf(System.Byte)">
            <summary>
            Returns the first offset in the packet that contains the given byte.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Insert(System.Int32,System.Byte)">
            <summary>
            This operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.RemoveAt(System.Int32)">
            <summary>
            This operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Add(System.Byte)">
            <summary>
            This operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Clear">
            <summary>
            This operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Contains(System.Byte)">
            <summary>
            Determines whether the packet contains a specific byte.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the bytes of the packet to a buffer, starting at a particular offset.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Packet.Remove(System.Byte)">
            <summary>
            This operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Length">
            <summary>
            The number of bytes this packet take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Timestamp">
            <summary>
            The time this packet was captured.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.DataLink">
            <summary>
            The type of the datalink of the device this packet was captured from.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Buffer">
            <summary>
            The underlying array of bytes.
            When taking this array the caller is responsible to make sure this array will not be modified while the packet is still in use.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Item(System.Int32)">
            <summary>
            Returns the value of the byte in the given offset.
            Set operation is invalid because the object is immutable.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Count">
            <summary>
            Returns the number of bytes in this packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.IsReadOnly">
            <summary>
            True since this object is read only.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.IsValid">
            <summary>
             True iff the packet is valid.
             The packet is valid unless an invalid part of it was found.
             Examples for invalid parts:
             * Bad checksum.
             * An illegal value for a field.
             * Length of packet is too short for a header or according to a length field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Packet.Ethernet">
            <summary>
            Takes the entire packet as an Ethernet datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Options">
            <summary>
            Represents IPv4 Options.
            The options may appear or not in datagrams.  
            They must be implemented by all IP modules (host and gateways).  
            What is optional is their transmission in any particular datagram, not their implementation.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Options`1">
            <summary>
            A generic Options class.
            Represents a list of options (either IPv4 options or TCP options).
            </summary>
            <typeparam name="T">The Option type this collection contains.</typeparam>
        </member>
        <member name="M:PcapDotNet.Packets.Options`1.Equals(PcapDotNet.Packets.Options{`0})">
            <summary>
            Two options are equal iff they have the exact same options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Options`1.Equals(System.Object)">
            <summary>
            Two options are equal iff they have the exact same options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Options`1.GetHashCode">
            <summary>
            The hash code is the xor of the following hash codes: number of bytes the options take and all the options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Options`1.ToString">
            <summary>
            A string of all the option type names.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Options`1.OptionsCollection">
            <summary>
            Returns the collection of options.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Options`1.Count">
            <summary>
            Returns the number of options.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Options`1.Item(System.Int32)">
            <summary>
            Returns the option in the given index.
            </summary>
            <param name="index">The zero based index of the option.</param>
            <returns>The option in the given index.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Options`1.BytesLength">
            <summary>
            The number of bytes the options take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Options`1.IsValid">
            <summary>
            Whether or not the options parsed ok.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Options.MaximumBytesLength">
            <summary>
            The maximum number of bytes the options may take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Options.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Option})">
            <summary>
            Creates options from a list of options.
            </summary>
            <param name="options">The list of options.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Options.#ctor(PcapDotNet.Packets.IpV4.IpV4Option[])">
            <summary>
            Creates options from a list of options.
            </summary>
            <param name="options">The list of options.</param>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Options.None">
            <summary>
            No options instance.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart">
            <summary>
            The Quick-Start Option for IPv4
            
            <para>
              The Quick-Start Request for IPv4 is defined as follows:
              <pre>
            +--------+----------+-------+---------+-------+-------+
            | 0-7    | 8-15     | 16-19 | 20-23   | 24-29 | 30-31 |
            +--------+----------+-------+---------+-------+-------+
            | Option | Length=8 | Func. | Rate    | QS TTL        |
            |        |          | 0000  | Request |               |
            +--------+----------+-------+---------+-------+-------+
            | QS Nonce                                    | R     |
            +---------------------------------------------+-------+
              </pre>
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.OptionValueLength">
            <summary>
            The number of bytes this option's value take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.RateMaximumValue">
            <summary>
            The maximum value for the rate field.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionQuickStartFunction,System.Byte,System.Byte,System.UInt32)">
            <summary>
            Create a quick start option according to the given field values.
            </summary>
            <param name="function">The function of this quick start option.</param>
            <param name="rate">Either the rate requested or reported.</param>
            <param name="ttl">
            The Quick-Start TTL (QS TTL) field.  
            The sender MUST set the QS TTL field to a random value.
            Routers that approve the Quick-Start Request decrement the QS TTL (mod 256) by the same amount that they decrement the IP TTL.  
            The QS TTL is used by the sender to detect if all the routers along the path understood and approved the Quick-Start option.
            </param>
            <param name="nonce">
            The QS Nonce gives the Quick-Start sender some protection against receivers lying about the value of the received Rate Request. 
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.#ctor">
            <summary>
            Creates a request with 0 fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Equals(PcapDotNet.Packets.IpV4.IpV4OptionQuickStart)">
            <summary>
            Two quick start options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two trace route options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.GetHashCode">
            <summary>
            The hash code is the xor of the base class hash code with the following values hash code:
            The combination of function, rate and ttl and the nonce.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Function">
            <summary>
            The function of this quick start option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Rate">
            <summary>
            If function is request then this field is the rate request.
            If function is report then this field is the rate report.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.RateKbps">
            <summary>
            The rate translated to KBPS.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Ttl">
            <summary>
            The Quick-Start TTL (QS TTL) field.  
            The sender MUST set the QS TTL field to a random value.
            Routers that approve the Quick-Start Request decrement the QS TTL (mod 256) by the same amount that they decrement the IP TTL.  
            The QS TTL is used by the sender to detect if all the routers along the path understood and approved the Quick-Start option.
            
            <para>
              For a Rate Request, the transport sender MUST calculate and store the TTL Diff, 
              the difference between the IP TTL value, and the QS TTL value in the Quick-Start Request packet, as follows:
              TTL Diff = ( IP TTL - QS TTL ) mod 256                 
            </para>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Nonce">
            <summary>
            The QS Nonce gives the Quick-Start sender some protection against receivers lying about the value of the received Rate Request. 
            This is particularly important if the receiver knows the original value of the Rate Request 
            (e.g., when the sender always requests the same value, and the receiver has a long history of communication with that sender).  
            Without the QS Nonce, there is nothing to prevent the receiver from reporting back to the sender a Rate Request of K, 
            when the received Rate Request was, in fact, less than K.
            
            <para>
              The format for the 30-bit QS Nonce.
              <list type="table">
                <listheader>
                    <term>Bits</term>
                    <description>Purpose</description>
                </listheader>
                <item><term>Bits 0-1</term><description>Rate 15 -> Rate 14</description></item>
                <item><term>Bits 2-3</term><description>Rate 14 -> Rate 13</description></item>
                <item><term>Bits 4-5</term><description>Rate 13 -> Rate 12</description></item>
                <item><term>Bits 6-7</term><description>Rate 12 -> Rate 11</description></item>
                <item><term>Bits 8-9</term><description>Rate 11 -> Rate 10</description></item>
                <item><term>Bits 10-11</term><description>Rate 10 -> Rate 9</description></item>
                <item><term>Bits 12-13</term><description>Rate 9 -> Rate 8</description></item>
                <item><term>Bits 14-15</term><description>Rate 8 -> Rate 7</description></item>
                <item><term>Bits 16-17</term><description>Rate 7 -> Rate 6</description></item>
                <item><term>Bits 18-19</term><description>Rate 6 -> Rate 5</description></item>
                <item><term>Bits 20-21</term><description>Rate 5 -> Rate 4</description></item>
                <item><term>Bits 22-23</term><description>Rate 4 -> Rate 3</description></item>
                <item><term>Bits 24-25</term><description>Rate 3 -> Rate 2</description></item>
                <item><term>Bits 26-27</term><description>Rate 2 -> Rate 1</description></item>
                <item><term>Bits 28-29</term><description>Rate 1 -> Rate 0</description></item>
              </list>
            </para>
            
            <para>
            The transport sender MUST initialize the QS Nonce to a random value. 
            If the router reduces the Rate Request from rate K to rate K-1, 
            then the router MUST set the field in the QS Nonce for "Rate K -> Rate K-1" to a new random value.  
            Similarly, if the router reduces the Rate Request by N steps, 
            the router MUST set the 2N bits in the relevant fields in the QS Nonce to a new random value.  
            The receiver MUST report the QS Nonce back to the sender.
            </para>
            
            <para>
            If the Rate Request was not decremented in the network, then the QS Nonce should have its original value.  
            Similarly, if the Rate Request was decremented by N steps in the network, 
            and the receiver reports back a Rate Request of K, then the last 2K bits of the QS Nonce should have their original value.
            </para>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionQuickStart.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpDatagram">
            <summary>
            RFC 1112.
            Version 1 (query or report):
            <pre>
            +-----+---------+------+--------+----------+
            | Bit | 0-3     | 4-7  | 8-15   | 16-31    |
            +-----+---------+------+--------+----------+
            | 0   | Version | Type | Unused | Checksum |
            +-----+---------+------+--------+----------+
            | 32  | Group Address                      |
            +-----+------------------------------------+
            </pre>
            
            RFC 2236.
            Version 2 (query, report or leave group):
            <pre>
            +-----+------+---------------+----------+
            | Bit | 0-7  | 8-15          | 16-31    |
            +-----+------+---------------+----------+
            | 0   | Type | Max Resp Time | Checksum |
            +-----+------+---------------+----------+
            | 32  | Group Address                   |
            +-----+---------------------------------+
            </pre>
            
            RFC 3376.
            Version 3 query:
            <pre>
            +-----+------+---+-----+---------------+-----------------------+
            | Bit | 0-3  | 4 | 5-7 | 8-15          | 16-31                 |
            +-----+------+---+-----+---------------+-----------------------+
            | 0   | Type = 0x11    | Max Resp Code | Checksum              |
            +-----+----------------+---------------+-----------------------+
            | 32  | Group Address                                          |
            +-----+------+---+-----+---------------+-----------------------+
            | 64  | Resv | S | QRV | QQIC          | Number of Sources (N) |
            +-----+------+---+-----+---------------+-----------------------+
            | 96  | Source Address [1]                                     |
            +-----+--------------------------------------------------------+
            | 128 | Source Address [2]                                     |
            +-----+--------------------------------------------------------+
            .     .                         .                              .
            .     .                         .                              .
            +-----+--------------------------------------------------------+
            | 64  | Source Address [N]                                     |
            | +   |                                                        |
            | 32N |                                                        |
            +-----+--------------------------------------------------------+
            </pre>
            
            RFC 3376.
            Version 3 report:
            <pre>
            +-----+-------------+----------+-----------------------------+
            | Bit | 0-7         | 8-15     | 16-31                       |
            +-----+-------------+----------+-----------------------------+
            | 0   | Type = 0x22 | Reserved | Checksum                    |
            +-----+-------------+----------+-----------------------------+
            | 32  | Reserved               | Number of Group Records (M) |
            +-----+------------------------+-----------------------------+
            | 64  | Group Record [1]                                     |
            .     .                                                      .
            .     .                                                      .
            .     .                                                      .
            |     |                                                      |
            +-----+------------------------------------------------------+
            |     | Group Record [2]                                     |
            .     .                                                      .
            .     .                                                      .
            .     .                                                      .
            |     |                                                      |
            +-----+------------------------------------------------------+
            |     |                         .                            |
            .     .                         .                            .
            |     |                         .                            |
            +-----+------------------------------------------------------+
            |     | Group Record [M]                                     |
            .     .                                                      .
            .     .                                                      .
            .     .                                                      .
            |     |                                                      |
            +-----+------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpDatagram.HeaderLength">
            <summary>
            The number of bytes the IGMP header takes for all messages but query version 3.
            All the bytes but the records of the report version 3.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpDatagram.QueryVersion3HeaderLength">
            <summary>
            The number of bytes the query version 3 IGMP message header takes.
            All the bytes but the source addresses.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxQueryRobustnessVariable">
            <summary>
            The maximum value for the query robustness varialbe.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpDatagram.CalculateIsValid">
            <summary>
            IGMP is valid if the checksum is correct, the length fits the message type and data and the MaxResponseCode is 0 in messages where it is not used.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpDatagram.CodeToValue(System.Byte)">
            <summary>
            Calculates the value from the given code as follows:
            <pre>
             0 1 2 3 4 5 6 7
            +-+-+-+-+-+-+-+-+
            |1| exp | mant  |
            +-+-+-+-+-+-+-+-+
            </pre>
            Value = (mant | 0x10) &lt;&lt; (exp + 3).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxMaxResponseTime">
            <summary>
            The Max Resp Code field specifies the maximum time allowed before sending a responding report.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxVersion3MaxResponseTime">
            <summary>
            The maximum value for the max response time in version 3 messages.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxQueryInterval">
            <summary>
            The maximum value for the query interval.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.Version">
            <summary>
            The version of the IGMP protocol for this datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.QueryVersion">
            <summary>
            The IGMP version of a Membership Query message is determined as follows:
            <list type="bullet">
              <item>IGMPv1 Query: length = 8 octets AND Max Resp Code field is zero.</item>
              <item>IGMPv2 Query: length = 8 octets AND Max Resp Code field is non-zero.</item>
              <item>IGMPv3 Query: length >= 12 octets.</item>
            </list>
            If the type is not a query, None will be returned.
            If the query message do not match any of the above conditions (e.g., a Query of length 10 octets) Unknown will be returned.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxResponseCode">
            <summary>
            The Max Resp Code field specifies the maximum time allowed before sending a responding report.  
            The actual time allowed, called the Max Resp Time, is represented in units of 1/10 second and is derived from the Max Resp Code as follows:
            <list type="bullet">
              <item>If Max Resp Code &lt; 128, Max Resp Time = Max Resp Code.</item>
              <item>
                If Max Resp Code >= 128, Max Resp Code represents a floating-point value as follows:
                <pre>
                0 1 2 3 4 5 6 7
                +-+-+-+-+-+-+-+-+
                |1| exp | mant  |
                +-+-+-+-+-+-+-+-+
                </pre>
                Max Resp Time = (mant | 0x10) &lt;&lt; (exp + 3).
              </item>
            </list>
            
            <para>
            Small values of Max Resp Time allow IGMPv3 routers to tune the "leave latency" 
            (the time between the moment the last host leaves a group and the moment the routing protocol is notified that there are no more members).
            Larger values, especially in the exponential range, allow tuning of the burstiness of IGMP traffic on a network.
            </para>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.MaxResponseTime">
            <summary>
            The actual time allowed, called the Max Resp Time, is represented in units of 1/10 second and is derived from the Max Resp Code as follows:
            <list type="bullet">
              <item>If the query version is 1 or 2 or if Max Resp Code &lt; 128, Max Resp Time = Max Resp Code.</item>
              <item>
                If Max Resp Code >= 128, Max Resp Code represents a floating-point value as follows:
                <pre>
                 0 1 2 3 4 5 6 7
                +-+-+-+-+-+-+-+-+
                |1| exp | mant  |
                +-+-+-+-+-+-+-+-+
                </pre>
                Max Resp Time = (mant | 0x10) &lt;&lt; (exp + 3).
              </item>
            </list>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.Checksum">
            <summary>
            The Checksum is the 16-bit one's complement of the one's complement sum of the whole IGMP message (the entire IP payload).  
            For computing the checksum, the Checksum field is set to zero.  
            When receiving packets, the checksum MUST be verified before processing a packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.IsChecksumCorrect">
            <summary>
            True iff the checksum value is correct according to the datagram data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.GroupAddress">
            <summary>
            The Group Address field is set to zero when sending a General Query, 
            and set to the IP multicast address being queried when sending a Group-Specific Query or Group-and-Source-Specific Query.
            In a Membership Report of version 1 or 2 or Leave Group message, the group address field holds the IP multicast group address of the group being reported or left.
            In a Membership Report of version 3 this field is meaningless.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.IsSuppressRouterSideProcessing">
            <summary>
            When set to one, the S Flag indicates to any receiving multicast routers that they are to suppress the normal timer updates they perform upon hearing a Query.  
            It does not, however, suppress the querier election or the normal "host-side" processing of a Query 
            that a router may be required to perform as a consequence of itself being a group member.
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.QueryRobustnessVariable">
            <summary>
            If non-zero, the QRV field contains the [Robustness Variable] value used by the querier, i.e., the sender of the Query.  
            If the querier's [Robustness Variable] exceeds 7, the maximum value of the QRV field, the QRV is set to zero.  
            Routers adopt the QRV value from the most recently received Query as their own [Robustness Variable] value, 
            unless that most recently received QRV was zero, in which case the receivers use the default [Robustness Variable] value or a statically configured value.
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.QueryIntervalCode">
            <summary>
            The Querier's Query Interval Code field specifies the [Query Interval] used by the querier.  
            The actual interval, called the Querier's Query Interval (QQI), is represented in units of seconds and is derived from the Querier's Query Interval Code as follows:
            <list type="bullet">
              <item>If QQIC &lt; 128, QQI = QQIC</item>
              <item>
                If QQIC >= 128, QQIC represents a floating-point value as follows:
                <pre>
                 0 1 2 3 4 5 6 7
                +-+-+-+-+-+-+-+-+
                |1| exp | mant  |
                +-+-+-+-+-+-+-+-+
                </pre>
                QQI = (mant | 0x10) &lt;&lt; (exp + 3)
              </item>
            </list>
            Multicast routers that are not the current querier adopt the QQI value from the most recently received Query as their own [Query Interval] value, 
            unless that most recently received QQI was zero, in which case the receiving routers use the default [Query Interval] value.
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.QueryInterval">
            <summary>
            The actual interval, called the Querier's Query Interval (QQI), is represented in units of seconds and is derived from the Querier's Query Interval Code as follows:
            <list type="bullet">
              <item>If QQIC &lt; 128, QQI = QQIC</item>
              <item>
                If QQIC >= 128, QQIC represents a floating-point value as follows:
                <pre>
                 0 1 2 3 4 5 6 7
                +-+-+-+-+-+-+-+-+
                |1| exp | mant  |
                +-+-+-+-+-+-+-+-+
                </pre>
                QQI = (mant | 0x10) &lt;&lt; (exp + 3)
              </item>
            </list>
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.NumberOfSources">
            <summary>
            The Number of Sources (N) field specifies how many source addresses are present in the Query.  
            This number is zero in a General Query or a Group-Specific Query, and non-zero in a Group-and-Source-Specific Query.  
            This number is limited by the MTU of the network over which the Query is transmitted.  
            For example, on an Ethernet with an MTU of 1500 octets, the IP header including the Router Alert option consumes 24 octets, 
            and the IGMP fields up to including the Number of Sources (N) field consume 12 octets, leaving 1464 octets for source addresses, 
            which limits the number of source addresses to 366 (1464/4).
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.SourceAddresses">
            <summary>
            The Source Address [i] fields are a vector of n IP unicast addresses,
            where n is the value in the Number of Sources (N) field.
            </summary>
            <remarks>
            Valid only on query of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.NumberOfGroupRecords">
            <summary>
            The Number of Group Records (M) field specifies how many Group Records are present in this Report.
            </summary>
            <remarks>
            Valid only on report of version 3.
            </remarks>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpDatagram.GroupRecords">
            <summary>
            Each Group Record is a block of fields containing information pertaining to the sender's membership in a single multicast group on the interface from which the Report is sent.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimestampLayer">
            <summary>
            RFC 792.
            Represents an ICMP Timestamp layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            True iff the OriginateTimestamp, ReceiveTimestamp and the TransmitTimestamp fields are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpTimestampLayer)">
            <summary>
            True iff the OriginateTimestamp, ReceiveTimestamp and the TransmitTimestamp fields are equal.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.OriginateTimestamp">
            <summary>
            The time the sender last touched the message before sending it.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.ReceiveTimestamp">
            <summary>
            The time the echoer first touched it on receipt.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.TransmitTimestamp">
            <summary>
            The time the echoer last touched the message on sending it.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimeExceededLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimeExceededLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimeExceededLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimeExceededLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer">
            <summary>
            RFC 1256.
            An ICMP Router Advertisement layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            True iff the Entries are equal to the other ICMP entries.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer)">
            <summary>
            True iff the Entries are equal to the other ICMP entries.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.Lifetime">
            <summary>
            The maximum time that the router addresses may be considered valid.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.Entries">
            <summary>
            The pairs of sending router's IP address(es) on the interface from which this message is sent
            and the preferability of each Router Address[i] as a default router address, relative to other router addresses on the same subnet.
            A signed, twos-complement value; higher values mean more preferable.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpDomainNameRequestDatagram">
            <summary>
            RFC 1788.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpDomainNameRequestDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed">
            <summary>
            The ICMP code values for Code Conversion Failed ICMP type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.UnknownOrUnspecifiedError">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.DoNotConvertOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.UnknownMandatoryOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.KnownUnsupportedOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.UnsupportedTransportProtocol">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.OverallLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.IpHeaderLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.TransportProtocolIsBiggerThan255">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.PortConversionOutOfRange">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.TransportHeaderLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.Code32BitRolloverMissingAndAckSet">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeConversionFailed.UnknownMandatoryTransportOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpResponseLayer">
            <summary>
            RFC 2616.
            Represents an HTTP response layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpResponseLayer.Equals(PcapDotNet.Packets.Http.HttpLayer)">
            <summary>
            Two HTTP response layers are equal iff they have the same version, header, body, status code and reason phrase.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpResponseLayer.Equals(PcapDotNet.Packets.Http.HttpResponseLayer)">
            <summary>
            Two HTTP response layers are equal iff they have the same version, header, body, status code and reason phrase.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseLayer.IsRequest">
            <summary>
            false since this is a response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseLayer.StatusCode">
            <summary>
            The status code of the response.
            null if no status code exists.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseLayer.ReasonPhrase">
            <summary>
            The data of the reason phrase.
            Example: OK
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion">
            <summary>
            An emotion that can be set in a TCP mood option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Happy">
            <summary>
            :)  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Sad">
            <summary>
            :(  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Amused">
            <summary>
            :D  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Confused">
            <summary>
            %(  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Bored">
            <summary>
            :o  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Surprised">
            <summary>
            :O  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Silly">
            <summary>
            :P  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Frustrated">
            <summary>
            :@  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Angry">
            <summary>
            >:@ 
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Apathetic">
            <summary>
            :|  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Sneaky">
            <summary>
            ;)  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.Evil">
            <summary>
            >:) 
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMoodEmotion.None">
            <summary>
            An unknown emotion.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionMood">
            <summary>
            TCP Mood Option:
            <pre>
            +---------+--------+------------+
            | Kind=25 | Length | ASCII Mood |
            +---------+--------+------------+
            </pre>
            
            <para>
             It is proposed that option 25 (released 2000-12-18) be used to define packet mood.
            This option would have a length value of 4 or 5 bytes.
            All the simple emotions described as expressible via this mechanism can be displayed with two or three 7-bit, ASCII-encoded characters.
            Multiple mood options may appear in a TCP header, so as to express more complex moods than those defined here (for instance if a packet were happy and surprised).
            </para>
            
            <para>
            It is proposed that common emoticons be used to denote packet mood.
            Packets do not "feel" per se.  The emotions they could be tagged with are a reflection of the user mood expressed through packets.
            So the humanity expressed in a packet would be entirely sourced from humans.
             To this end, it is proposed that simple emotions be used convey mood as follows.
            
            <pre>
            ASCII                Mood
            =====                ====
            :)                   Happy
            :(                   Sad
            :D                   Amused
            %(                   Confused
            :o                   Bored
            :O                   Surprised
            :P                   Silly
            :@                   Frustrated
            >:@                  Angry
            :|                   Apathetic
            ;)                   Sneaky
            >:)                  Evil
            </pre>
            
            Proposed ASCII character encoding
            <pre>
            Binary          Dec  Hex     Character
            ========        ===  ===     =========
            010 0101        37   25      %
            010 1000        40   28      (
            010 1001        41   29      )
            011 1010        58   3A      :
            011 1011        59   3B      ;
            011 1110        62   3E      >
            100 0000        64   40      @
            100 0100        68   44      D
            100 1111        79   4F      O
            101 0000        80   50      P
            110 1111        111  6F      o
            111 1100        124  7C      |
            </pre>
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMood.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMood.OptionMaximumLength">
            <summary>
            The maximum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMood.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option value take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMood.OptionValueMaximumLength">
            <summary>
            The maximum number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.#ctor(PcapDotNet.Packets.Transport.TcpOptionMoodEmotion)">
            <summary>
            Creates the option using the given emotion.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.#ctor">
            <summary>
            The default emotion is confused.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.Equals(PcapDotNet.Packets.Transport.TcpOptionMood)">
            <summary>
            Two mood options are equal if they have the same emotion.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two mood options are equal if they have the same emotion.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.GetHashCode">
            <summary>
            The hash code of the echo option is the hash code of the option type xored with the hash code info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMood.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMood.Emotion">
            <summary>
            The emotion of the option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMood.EmotionString">
            <summary>
            The ASCII string of the emotion.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMood.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMood.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.ByteArrayExtensions">
            <summary>
            Extension methods for byte[].
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Compare(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compares all the bytes in the two ranges of the arrays.
            Returns the first non-zero compare value of the bytes in the ranges or zero if the ranges have the same byte values.
            </summary>
            <param name="array">The first array to compare.</param>
            <param name="offset">The offset of the first byte to compare in the first array.</param>
            <param name="other">The second array to compare.</param>
            <param name="otherOffset">The offset of the first byte to compare in the second array.</param>
            <param name="count">The number of bytes to compare.</param>
            <returns>The first non-zero compare value of the bytes in the ranges or zero if the ranges have the same byte values.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.SequenceEqual(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compares all the bytes in the two ranges of the arrays.
            Returns true iff the ranges have the same byte values.
            </summary>
            <param name="array">The first array to compare.</param>
            <param name="offset">The offset of the first byte to compare in the first array.</param>
            <param name="other">The second array to compare.</param>
            <param name="otherOffset">The offset of the first byte to compare in the second array.</param>
            <param name="count">The number of bytes to compare.</param>
            <returns>True iff the ranges have the same byte values.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Find(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns the first offset in the array where the other array's range sequence of bytes can be found or the length of the array if no match exists.
            </summary>
            <param name="array">The array to search for the sequence of bytes.</param>
            <param name="offset">The offset of the first byte in the array that should be compared to the sequence to find.</param>
            <param name="count">The number of bytes in the array that the sequence can be searched in.</param>
            <param name="other">The array that contains the sequence of bytes to search.</param>
            <param name="otherOffset">The offset in the array containing the sequence of the first byte of the sequence.</param>
            <param name="otherCount">The number of bytes of the sequence.</param>
            <returns>The first offset in the array where the other array's range sequence of bytes can be found or the length of the array if no match exists.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Find(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Returns the first offset in the array where the other array sequence of bytes can be found or the length of the array if no match exists.
            </summary>
            <param name="array">The array to search for the sequence of bytes.</param>
            <param name="offset">The offset of the first byte in the array that should be compared to the sequence to find.</param>
            <param name="count">The number of bytes in the array that the sequence can be searched in.</param>
            <param name="other">The array that contains the sequence of bytes to search.</param>
            <returns>The first offset in the array where the other array sequence of bytes can be found or the length of the array if no match exists.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.BlockCopy(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies a specified number of bytes from a source array starting at a particular offset to a destination array starting at a particular offset.
            </summary>
            <param name="source">The source buffer.</param>
            <param name="sourceOffset">The byte offset into source.</param>
            <param name="destination">The destination buffer.</param>
            <param name="destinationOffset">The byte offset into destination.</param>
            <param name="count">The number of bytes to copy.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadByte(System.Byte[],System.Int32)">
            <summary>
            Reads a byte from a specific offset.
            </summary>
            <param name="buffer">The buffer to read the byte from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <returns>The value read from the buffer.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadByte(System.Byte[],System.Int32@)">
            <summary>
            Reads a byte from a specific offset and increments the offset by 1.
            </summary>
            <param name="buffer">The buffer to read the byte from.</param>
            <param name="offset">The offset in the buffer to start reading and to increment.</param>
            <returns>The value read from the buffer.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from a specific offset.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>The value read from the buffer.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadBytes(System.Byte[],System.Int32@,System.Int32)">
            <summary>
            Reads bytes from a specific offset and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading and to increment.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>The value read from the buffer.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadShort(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 2 bytes from a specific offset as a short with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUShort(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 2 bytes from a specific offset as a ushort with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUShort(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 2 bytes from a specific offset as a ushort with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt24(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 3 bytes from a specific offset as a UInt24 with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt24(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 3 bytes from a specific offset as a UInt24 with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadInt(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as an int with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as a uint with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as a uint with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt48(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 6 bytes from a specific offset as a UInt48 with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadUInt48(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 6 bytes from a specific offset as a UInt48 with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadMacAddress(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 6 bytes from a specific offset as a MacAddress with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadMacAddress(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 6 bytes from a specific offset as a MacAddress with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadIpV4Address(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as an IPv4 address with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadIpV4Address(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as an IPv4 address with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadIpV4TimeOfDay(System.Byte[],System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as an IPv4 time of day with a given endianity.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.ReadIpV4TimeOfDay(System.Byte[],System.Int32@,PcapDotNet.Packets.Endianity)">
            <summary>
            Reads 4 bytes from a specific offset as an IPv4 time of day with a given endianity and increments the offset by the number of bytes read.
            </summary>
            <param name="buffer">The buffer to read the bytes from.</param>
            <param name="offset">The offset in the buffer to start reading.</param>
            <param name="endianity">The endianity to use to translate the bytes to the value.</param>
            <returns>The value converted from the read bytes according to the endianity.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.Byte)">
            <summary>
            Writes the given value to the buffer.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Writes the given value to the buffer and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            Writes the given value to the buffer and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.Int16,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.UInt16,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.UInt16,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Base.UInt24,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Base.UInt24,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.Int32,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,System.UInt32,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.UInt32,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Base.UInt48,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Base.UInt48,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,System.String,System.Text.Encoding)">
            <summary>
            Writes a string to a byte array in a specific offset using the given encoding.
            Increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the string in.</param>
            <param name="offset">The offset in the buffer to start writing the string in. Incremented by the number of bytes written.</param>
            <param name="value">The string to write in the buffer.</param>
            <param name="encoding">The encoding to use to translate the string into a sequence of bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Packets.Datagram)">
            <summary>
            Writes the given value to the buffer.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Packets.Datagram)">
            <summary>
            Writes the given value to the buffer and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Packets.Ethernet.MacAddress,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Packets.Ethernet.MacAddress,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Packets.IpV4.IpV4Address,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Packets.IpV4.IpV4Address,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32,PcapDotNet.Packets.IpV4.IpV4TimeOfDay,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.Write(System.Byte[],System.Int32@,PcapDotNet.Packets.IpV4.IpV4TimeOfDay,PcapDotNet.Packets.Endianity)">
            <summary>
            Writes the given value to the buffer using the given endianity and increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the value to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
            <param name="value">The value to write.</param>
            <param name="endianity">The endianity to use when converting the value to bytes.</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.WriteCarriageReturnLinefeed(System.Byte[],System.Int32@)">
            <summary>
            Writes the endline bytes (CRLF) in the buffer in the given offset.
            Increments the offset by the number of bytes written (2).
            </summary>
            <param name="buffer">The buffer to write the CRLF in.</param>
            <param name="offset">The offset to start writing the CRLF in. Incremented by the number of bytes written (2).</param>
        </member>
        <member name="M:PcapDotNet.Packets.ByteArrayExtensions.WriteDecimal(System.Byte[],System.Int32@,System.UInt32)">
            <summary>
            Writes an integer as a decimal string in ASCII encoding to a buffer of bytes in a specific offset.
            The offset is incremented by the number of bytes (digits) written.
            </summary>
            <param name="buffer">The buffer to write the integer in.</param>
            <param name="offset">The offset in the buffer to start writing the integer. Incremented by the number of bytes (digits) written.</param>
            <param name="value">The integer value to write in the buffer.</param>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionSimple">
            <summary>
            A simple IPv4 option - holds only the type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSimple.OptionLength">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionSimple.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionSimple.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpReportVersion2Layer">
            <summary>
            RFC 2236.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpVersion2Layer">
            <summary>
            RFC 2236.
            Represents a generic IGMP version 2 datagram.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpVersion2Layer.MaxResponseTime">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpVersion2Layer.MaxResponseTimeValue">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion2Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code">
            <summary>
            The code of the IGMP message for Create Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestGranted">
            <summary>
            Request Granted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestDeniedNoResources">
            <summary>
            Request Denied - No Resources.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestDeniedInvalidCode">
            <summary>
            Request Denied - Invalid Code.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestDeniedInvalidGroupAddress">
            <summary>
            Request Denied - Invalid Group Address.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestDeniedInvalidAccessKey">
            <summary>
            Request Denied - Invalid Access Key.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn5Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn6Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn7Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn8Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn9Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn10Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn11Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn12Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn13Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn14Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn15Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn16Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn17Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn18Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn19Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn20Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn21Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn22Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn23Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn24Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn25Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn26Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn27Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn28Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn29Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn30Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn31Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn32Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn33Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn34Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn35Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn36Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn37Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn38Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn39Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn40Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn41Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn42Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn43Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn44Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn45Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn46Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn47Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn48Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn49Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn50Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn51Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn52Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn53Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn54Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn55Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn56Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn57Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn58Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn59Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn60Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn61Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn62Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn63Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn64Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn65Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn66Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn67Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn68Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn69Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn70Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn71Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn72Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn73Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn74Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn75Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn76Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn77Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn78Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn79Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn80Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn81Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn82Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn83Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn84Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn85Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn86Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn87Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn88Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn89Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn90Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn91Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn92Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn93Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn94Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn95Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn96Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn97Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn98Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn99Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn100Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn101Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn102Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn103Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn104Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn105Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn106Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn107Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn108Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn109Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn110Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn111Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn112Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn113Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn114Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn115Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn116Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn117Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn118Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn119Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn120Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn121Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn122Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn123Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn124Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn125Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn126Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn127Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn128Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn129Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn130Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn131Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn132Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn133Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn134Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn135Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn136Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn137Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn138Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn139Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn140Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn141Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn142Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn143Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn144Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn145Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn146Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn147Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn148Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn149Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn150Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn151Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn152Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn153Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn154Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn155Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn156Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn157Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn158Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn159Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn160Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn161Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn162Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn163Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn164Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn165Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn166Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn167Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn168Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn169Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn170Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn171Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn172Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn173Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn174Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn175Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn176Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn177Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn178Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn179Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn180Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn181Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn182Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn183Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn184Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn185Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn186Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn187Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn188Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn189Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn190Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn191Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn192Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn193Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn194Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn195Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn196Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn197Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn198Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn199Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn200Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn201Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn202Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn203Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn204Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn205Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn206Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn207Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn208Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn209Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn210Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn211Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn212Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn213Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn214Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn215Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn216Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn217Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn218Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn219Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn220Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn221Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn222Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn223Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn224Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn225Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn226Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn227Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn228Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn229Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn230Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn231Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn232Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn233Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn234Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn235Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn236Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn237Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn238Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn239Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn240Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn241Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn242Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn243Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn244Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn245Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn246Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn247Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn248Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn249Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn250Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn251Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn252Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn253Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn254Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpReplyVersion0Code.RequestPendingRetryIn255Seconds">
            <summary>
            Request Pending - Retry in this value many seconds.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpCreateGroupRequestVersion0Code">
            <summary>
            The code of the IGMP message for Create Group Request (RFC988).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpCreateGroupRequestVersion0Code.Public">
            <summary>
            Public.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpCreateGroupRequestVersion0Code.Private">
            <summary>
            Private.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode">
            <summary>
            The different ICMP message types and codes.
            Each of the values is a combination of the message type and a code values that is legal with this message type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachableNetUnreachable">
            <summary>
            RFC 792.
            If, according to the information in the gateway's routing tables, 
            the network specified in the internet destination field of a datagram is unreachable, 
            e.g., the distance to the network is infinity, 
            the gateway may send a destination unreachable message to the internet source host of the datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachableHostUnreachable">
            <summary>
            RFC 792.
            In some networks, the gateway may be able to determine if the internet destination host is unreachable.  
            Gateways in these networks may send destination unreachable messages to the source host when the destination host is unreachable.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachableProtocolUnreachable">
            <summary>
            RFC 792.
            If, in the destination host, the IP module cannot deliver the datagram because the indicated protocol module is not active, 
            the destination host may send a destination unreachable message to the source host.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachablePortUnreachable">
            <summary>
            RFC 792.
            If, in the destination host, the IP module cannot deliver the datagram because the indicated process port is not active, 
            the destination host may send a destination unreachable message to the source host.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachableFragmentationNeededAndDoNotFragmentSet">
            <summary>
            RFC 792.
            A datagram must be fragmented to be forwarded by a gateway yet the Don't Fragment flag is on.  
            In this case the gateway must discard the datagram and may return a destination unreachable message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DestinationUnreachableSourceRouteFailed">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.TimeExceededTimeToLive">
            <summary>
            RFC 792.
            If the gateway processing a datagram finds the time to live field is zero it must discard the datagram.  
            The gateway may also notify the source host via the time exceeded message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.TimeExceededFragmentReassembly">
            <summary>
            RFC 792.
            If a host reassembling a fragmented datagram cannot complete the reassembly due to missing fragments within its time limit it discards the datagram, 
            and it may send a time exceeded message.
            If fragment zero is not available then no time exceeded need be sent at all.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ParameterProblemPointerIndicatesTheError">
            <summary>
            RFC 792.
            If the gateway or host processing a datagram finds a problem with the header parameters such that it cannot complete processing the datagram it must discard the datagram.  
            One potential source of such a problem is with incorrect arguments in an option.  
            The gateway or host may also notify the source host via the parameter problem message. 
            This message is only sent if the error caused the datagram to be discarded.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SourceQuench">
            <summary>
            RFC 792.
            
            <para>
            A gateway may discard internet datagrams if it does not have the buffer space needed to queue the datagrams for output to the next network on the route to the destination network.  
            If a gateway discards a datagram, it may send a source quench message to the internet source host of the datagram.  
            A destination host may also send a source quench message if datagrams arrive too fast to be processed.  
            The source quench message is a request to the host to cut back the rate at which it is sending traffic to the internet destination.  
            The gateway may send a source quench message for every message that it discards.  
            On receipt of a source quench message, the source host should cut back the rate at which it is sending traffic to the specified destination 
            until it no longer receives source quench messages from the gateway.  
            The source host can then gradually increase the rate at which it sends traffic to the destination until it again receives source quench messages.
            </para>
            
            <para>
            The gateway or host may send the source quench message when it approaches its capacity limit rather than waiting until the capacity is exceeded.  
            This means that the data datagram which triggered the source quench message may be delivered.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RedirectDatagramsForTheNetwork">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RedirectDatagramsForTheHost">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RedirectDatagramsForTheTypeOfServiceAndNetwork">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RedirectDatagramsForTheTypeOfServiceAndHost">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.Echo">
            <summary>
            RFC 792.
            <para>
            The data received in the echo message must be returned in the echo reply message.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the echo requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each echo request sent.  
            The echoer returns these same values in the echo reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>        
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.EchoReply">
            <summary>
            RFC 792.
            <para>
            The data received in the echo message must be returned in the echo reply message.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the echo requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each echo request sent.  
            The echoer returns these same values in the echo reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>        
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.Timestamp">
            <summary>
            RFC 792
            <para>
            The data received (a timestamp) in the message is returned in the reply together with an additional timestamp.  
            The timestamp is 32 bits of milliseconds since midnight UT.  
            </para>
            
            <para>
            If the time is not available in miliseconds or cannot be provided with respect to midnight UT 
            then any time can be inserted in a timestamp provided the high order bit of the timestamp is also set to indicate this non-standard value.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.TimestampReply">
            <summary>
            RFC 792
            <para>
            The data received (a timestamp) in the message is returned in the reply together with an additional timestamp.  
            The timestamp is 32 bits of milliseconds since midnight UT.  
            </para>
            
            <para>
            If the time is not available in miliseconds or cannot be provided with respect to midnight UT 
            then any time can be inserted in a timestamp provided the high order bit of the timestamp is also set to indicate this non-standard value.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.InformationRequest">
            <summary>
            RFC 792.
            <para>
            This message may be sent with the source network in the IP header source and destination address fields zero (which means "this" network).  
            The replying IP module should send the reply with the addresses fully specified.  
            This message is a way for a host to find out the number of the network it is on.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.InformationReply">
            <summary>
            RFC 792.
            <para>
            This message may be sent with the source network in the IP header source and destination address fields zero (which means "this" network).  
            The replying IP module should send the reply with the addresses fully specified.  
            This message is a way for a host to find out the number of the network it is on.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RouterAdvertisement">
            <summary>
            RFC 1256.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.RouterSolicitation">
            <summary>
            RFC 1256.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.AddressMaskRequest">
            <summary>
            RFC 950.
            
            <para>
            A gateway receiving an address mask request should return it with the address mask field set to the 32-bit mask of the bits identifying the subnet and network, 
            for the subnet on which the request was received.
            </para>
            
            <para>
            If the requesting host does not know its own IP address, it may leave the source field zero; the reply should then be broadcast.  
            However, this approach should be avoided if at all possible, since it increases the superfluous broadcast load on the network.  
            Even when the replies are broadcast, since there is only one possible address mask for a subnet, there is no need to match requests with replies.  
            The "Identifier" and "Sequence Number" fields can be ignored.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.AddressMaskReply">
            <summary>
            RFC 950.
            
            <para>
            A gateway receiving an address mask request should return it with the address mask field set to the 32-bit mask of the bits identifying the subnet and network, 
            for the subnet on which the request was received.
            </para>
            
            <para>
            If the requesting host does not know its own IP address, it may leave the source field zero; the reply should then be broadcast.  
            However, this approach should be avoided if at all possible, since it increases the superfluous broadcast load on the network.  
            Even when the replies are broadcast, since there is only one possible address mask for a subnet, there is no need to match requests with replies.  
            The "Identifier" and "Sequence Number" fields can be ignored.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.TraceRouteOutboundPacketSuccessfullyForwarded">
            <summary>
            RFC 1393.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.TraceRouteNoRouteForOutboundPacketDiscarded">
            <summary>
            RFC 1393.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedUnknownOrUnspecifiedError">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedDoNotConvertOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedUnknownMandatoryOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedKnownUnsupportedOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedUnsupportedTransportProtocol">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedOverallLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedIpHeaderLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedTransportProtocolIsBiggerThan255">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedPortConversionOutOfRange">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedTransportHeaderLengthExceeded">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailed32BitRolloverMissingAndAckSet">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.ConversionFailedUnknownMandatoryTransportOptionPresent">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DomainNameRequest">
            <summary>
            RFC 1788.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.DomainNameReply">
            <summary>
            RFC 1788.
            Parsing of this datagram isn't supported because its parsing is not clear from the RFC.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresBadSecurityParametersIndex">
            <summary>
            RFC 2521.
            Indicates that a received datagram includes a Security Parameters Index (SPI) that is invalid or has expired.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresAuthenticationFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed the authenticity or integrity check for a given SPI.
            
            <para>
            Note that the SPI may indicate an outer Encapsulating Security Protocol when a separate Authentication Header SPI is hidden inside.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresDecompressionFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed a decompression check for a given SPI.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresDecryptionFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed a decryption check for a given SPI.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresNeedAuthentication">
            <summary>
            RFC 2521.
            Indicates that a received datagram will not be accepted without additional authentication.
            
            <para>
            In this case, either no SPI is present, or an unsuitable SPI is present.  
            For example, an encryption SPI without integrity arrives from a secure operating system with mutually suspicious users.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageTypeAndCode.SecurityFailuresNeedAuthorization">
            <summary>
            RFC 2521.
            Indicates that a received datagram will not be accepted because it has insufficient authorization.
            
            <para>
            In this case, an authentication SPI is present that is inappropriate for the target transport or application.  
            The principle party denoted by the SPI does not have proper authorization for the facilities used by the datagram.  
            For example, the party is authorized for Telnet access, but not for FTP access.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer">
            <summary>
            RFC 1393.
            Represents an ICMP Trace Route message layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            True iff the OutboundHopCount, ReturnHopCount, OutputLinkSpeed and OutputLinkMaximumTransmissionUnit fields are equal to the other layer fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer)">
            <summary>
            True iff the OutboundHopCount, ReturnHopCount, OutputLinkSpeed and OutputLinkMaximumTransmissionUnit fields are equal to the other layer fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.Identification">
            <summary>
            The ID Number as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.  
            This is NOT related to the ID number in the IP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.OutboundHopCount">
            <summary>
            The Outbound Hop Count as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.ReturnHopCount">
            <summary>
            The Return Hop Count as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.OutputLinkSpeed">
            <summary>
            The speed, in OCTETS per second, of the link over which the Outbound/Return Packet will be sent.  
            Since it will not be long before network speeds exceed 4.3Gb/s, and since some machines deal poorly with fields longer than 32 bits, octets per second was chosen over bits per second.  
            If this value cannot be determined, the field should be set to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.OutputLinkMaximumTransmissionUnit">
            <summary>
            The MTU, in bytes, of the link over which the Outbound/Return Packet will be sent.  
            MTU refers to the data portion (includes IP header; excludes datalink header/trailer) of the packet.  
            If this value cannot be determined, the field should be set to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimestampReplyDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 64  | Originate Timestamp           |
            +-----+-------------------------------+
            | 96  | Receive Timestamp             |
            +-----+-------------------------------+
            | 128 | Transmit Timestamp            |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 64  | Originate Timestamp           |
            +-----+-------------------------------+
            | 96  | Receive Timestamp             |
            +-----+-------------------------------+
            | 128 | Transmit Timestamp            |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.DatagramLength">
            <summary>
            The number of bytes this datagram should take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.PayloadLength">
            <summary>
            The number of bytes this ICMP payload should take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct and the code is in the expected range.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.OriginateTimestamp">
            <summary>
            The time the sender last touched the message before sending it.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.ReceiveTimestamp">
            <summary>
            The time the echoer first touched it on receipt.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampDatagram.TransmitTimestamp">
            <summary>
            The time the echoer last touched the message on sending it.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimestampReplyDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpAddressMaskReplyLayer">
            <summary>
            RFC 950.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer">
            <summary>
            RFC 950.
            Represents an ICMP Trace Route message layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpLayer)">
            <summary>
            True iff the address mask is equal to the other address mask.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.EqualPayload(PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer)">
            <summary>
            True iff the address mask is equal to the other address mask.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.AddressMask">
            <summary>
            A 32-bit mask.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpAddressMaskReplyLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpRequestDatagram">
            <summary>
            RFC 2616.
            Represents an HTTP request.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpDatagram">
             <summary>
             RFC 2616
             
             Message:
             <pre>
             HTTP-message     = Request | Response
             
             generic-message  = start-line
                                *(message-header CRLF)
                                CRLF
                                [ message-body ]
             
             start-line       = Request-Line | Status-Line
             
             message-header   = field-name ":" [ field-value ]
             field-name       = token
             field-value      = *( field-content | LWS )
             field-content    = &lt;the OCTETs making up the field-value and consisting of either *TEXT or combinations of token, separators, and quoted-string>
             
             message-body     = entity-body
                              | &lt;entity-body encoded as per Transfer-Encoding>
             general-header   = Cache-Control          
                              | Connection             
                              | Date                   
                              | Pragma                 
                              | Trailer                
                              | Transfer-Encoding      
                              | Upgrade                
                              | Via                    
                              | Warning                
             </pre>
             
             Request:
             <pre>
             Request          = Request-Line             
                                *(( general-header       
                                 | request-header        
                                 | entity-header ) CRLF) 
                                CRLF
                                [ message-body ]         
             
             Request-Line     = Method SP Request-URI SP HTTP-Version CRLF
             
             Method           = "OPTIONS"              
                              | "GET"                  
                              | "HEAD"                 
                              | "POST"                 
                              | "PUT"                  
                              | "DELETE"               
                              | "TRACE"                
                              | "CONNECT"              
                              | extension-method
             
             extension-method = token
             
             Request-URI      = "*" | absoluteURI | abs_path | authority
             absoluteURI      = scheme ":" ( hier_part | opaque_part )
             scheme           = alpha *( alpha | digit | "+" | "-" | "." )
             hier_part        = ( net_path | abs_path ) [ "?" query ]
             opaque_part      = uric_no_slash *uric
             net_path         = "//" authority [ abs_path ]
             abs_path         = "/"  path_segments
             query            = *uric
             uric_no_slash    = unreserved | escaped | ";" | "?" | ":" | "@" | "&amp;" | "=" | "+" | "$" | ","
             uric             = reserved | unreserved | escaped
             authority        = server | reg_name
             path_segments    = segment *( "/" segment )
             unreserved       = alphanum | mark
             escaped          = "%" hex hex
             reserved         = ";" | "/" | "?" | ":" | "@" | "&amp;" | "=" | "+" | "$" | ","
             server           = [ [ userinfo "@" ] hostport ]
             reg_name         = 1*( unreserved | escaped | "$" | "," | ";" | ":" | "@" | "&amp;" | "=" | "+" )
             segment          = *pchar *( ";" param )
             mark             = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"
             userinfo         = *( unreserved | escaped | ";" | ":" | "&amp;" | "=" | "+" | "$" | "," )
             hostport         = host [ ":" port ]
             pchar            = unreserved | escaped | ":" | "@" | "&amp;" | "=" | "+" | "$" | ","
             param            = *pchar
             host             = hostname | IPv4address
             port             = *digit
             hostname         = *( domainlabel "." ) toplabel [ "." ]
             IPv4address      = 1*digit "." 1*digit "." 1*digit "." 1*digit
             domainlabel      = alphanum | alphanum *( alphanum | "-" ) alphanum
             toplabel         = alpha | alpha *( alphanum | "-" ) alphanum
             
             request-header   = Accept                  
                              | Accept-Charset          
                              | Accept-Encoding         
                              | Accept-Language         
                              | Authorization           
                              | Expect                  
                              | From                    
                              | Host                    
                              | If-Match                
                              | If-Modified-Since       
                              | If-None-Match           
                              | If-Range                
                              | If-Unmodified-Since     
                              | Max-Forwards            
                              | Proxy-Authorization     
                              | Range                   
                              | Referer                 
                              | TE                      
                              | User-Agent              
             </pre>
             
             Response:
             <pre>
             Response         = Status-Line             
                                *(( general-header      
                                 | response-header      
                                 | entity-header ) CRLF)
                                CRLF
                                [ message-body ]        
             
             Status-Line      = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
             
             Status-Code      = "100"  
                              | "101"  
                              | "200"  
                              | "201"  
                              | "202"  
                              | "203"  
                              | "204"  
                              | "205"  
                              | "206"  
                              | "300"  
                              | "301"  
                              | "302"  
                              | "303"  
                              | "304"  
                              | "305"  
                              | "307"  
                              | "400"  
                              | "401"  
                              | "402"  
                              | "403"  
                              | "404"  
                              | "405"  
                              | "406"  
                              | "407"  
                              | "408"  
                              | "409"  
                              | "410"  
                              | "411"  
                              | "412"  
                              | "413"  
                              | "414"  
                              | "415"  
                              | "416"  
                              | "417"  
                              | "500"  
                              | "501"  
                              | "502"  
                              | "503"  
                              | "504"  
                              | "505"  
                              | extension-code
             
             extension-code   = 3DIGIT
             Reason-Phrase    = *&lt;TEXT, excluding CR, LF>
             
             response-header  = Accept-Ranges       
                              | Age                 
                              | ETag                
                              | Location            
                              | Proxy-Authenticate  
                              | Retry-After         
                              | Server              
                              | Vary                
                              | WWW-Authenticate    
            
             entity-header    = Allow               
                              | Content-Encoding    
                              | Content-Language    
                              | Content-Length      
                              | Content-Location    
                              | Content-MD5         
                              | Content-Range       
                              | Content-Type        
                              | Expires             
                              | Last-Modified       
                              | extension-header
            
             extension-header = message-header
             
             entity-body      = *OCTET
             
             entity-body     := Content-Encoding( Content-Type( data ) )
             </pre>
             </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpDatagram.IsRequest">
            <summary>
            True iff the message is a request and iff the message is not a response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpDatagram.IsResponse">
            <summary>
            True iff the message is a response and iff the message is not a request.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpDatagram.Version">
            <summary>
            The version of this HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpDatagram.Header">
            <summary>
            The header of the HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpDatagram.Body">
            <summary>
            Message Body.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestDatagram.IsRequest">
            <summary>
            True since the message is a request.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestDatagram.Method">
            <summary>
            The HTTP Request Method.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestDatagram.Uri">
            <summary>
            The HTTP Request URI.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpHeader">
            <summary>
            Represents HTTP header.
            The header is a container for HTTP fields.
            Insensitive to the case of HTTP field names.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.#ctor(System.Collections.Generic.IEnumerable{PcapDotNet.Packets.Http.HttpField})">
            <summary>
            Creates a header from an enumerable of fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.#ctor(PcapDotNet.Packets.Http.HttpField[])">
            <summary>
            Creates a header from an array of fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.Equals(PcapDotNet.Packets.Http.HttpHeader)">
            <summary>
            Two HTTP headers are equal if they have the same fields with the same values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.Equals(System.Object)">
            <summary>
            Two HTTP headers are equal if they have the same fields with the same values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.GetHashCode">
            <summary>
            Xor of the hash codes of the fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.ToString">
            <summary>
            Returns a string of all the fields with endline separators.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.GetEnumerator">
            <summary>
            Enumerates over the HTTP fields.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the HTTP header to the given buffer in the given offset.
            </summary>
            <param name="buffer">The buffer to write the header to.</param>
            <param name="offset">The offset in the given buffer to start writing the header.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpHeader.Write(System.Byte[],System.Int32@)">
            <summary>
            Writes the HTTP header to the given buffer in the given offset.
            Increments the offset by the number of bytes written.
            </summary>
            <param name="buffer">The buffer to write the header to.</param>
            <param name="offset">The offset in the given buffer to start writing the header. Incremented by the number of bytes written.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.Empty">
            <summary>
            An empty HTTP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.BytesLength">
            <summary>
            The number of bytes the header takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.Item(System.String)">
            <summary>
            Returns the field with the given field name or null if it doesn't exist.
            Case insensitive.
            </summary>
            <param name="fieldName">The case insensitive name of the field.</param>
            <returns>The field with the matching case insensitive name or null if it doesn't exist.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.TransferEncoding">
            <summary>
            The HTTP Transfer Encoding field if it exists (null otherwise).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.ContentLength">
            <summary>
            The HTTP Content Length field if it exists (null otherwise).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpHeader.ContentType">
            <summary>
            The HTTP Content Type field if it exists (null otherwise).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreSourceRouteEntryAddressFamily">
            <summary>
            A value representing the syntax and semantics of the Routing Information field.  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreSourceRouteEntryAddressFamily.None">
            <summary>
            No address family
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreSourceRouteEntryAddressFamily.IpSourceRoute">
            <summary>
            The Routing Information field will consist of a list of IP addresses and indicates an IP source route.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreSourceRouteEntryAddressFamily.AsSourceRoute">
            <summary>
            the Routing Information field will consist of a list of Autonomous System numbers and indicates an AS source route.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptions">
            <summary>
            A collection of TCP options.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptions.MaximumBytesLength">
            <summary>
            The maximum number of bytes the options can take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptions.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.Transport.TcpOption})">
            <summary>
            Creates the options collection from the given list of options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptions.#ctor(PcapDotNet.Packets.Transport.TcpOption[])">
            <summary>
            Creates options from a list of options.
            </summary>
            <param name="options">The list of options.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptions.None">
            <summary>
            An empty options collection.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress">
            <summary>
             Represents a timestamp IPv4 option with each timestamp preceded with internet address of the registering entity or the internet address fields are prespecified.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp">
            <summary>
            Internet Timestamp
            <pre>
            +--------+--------+--------+--------+
            |01000100| length | pointer|oflw|flg|
            +--------+--------+--------+--------+
            |         internet address          |
            +--------+--------+--------+--------+
            |             timestamp             |
            +--------+--------+--------+--------+
            |                 .                 |
                              .
                              .
             Type = 68
            </pre>
            
            <para>
            The Option Length is the number of octets in the option counting the type, length, pointer, and overflow/flag octets (maximum length 40).
            </para>
            
            <para>
            The Pointer is the number of octets from the beginning of this option to the end of timestamps plus one 
            (i.e., it points to the octet beginning the space for next timestamp).  
            The smallest legal value is 5.  
            The timestamp area is full when the pointer is greater than the length.
            </para>
            
            <para>
            The Overflow (oflw) [4 bits] is the number of IP modules that cannot register timestamps due to lack of space.
            </para>
            
            <para>
            The Flag (flg) [4 bits] values are
            <list type="bullet">
              <item>0 - time stamps only, stored in consecutive 32-bit words.</item>
              <item>1 - each timestamp is preceded with internet address of the registering entity.</item>
              <item>3 - the internet address fields are prespecified.</item>
            </list>
            An IP module only registers its timestamp if it matches its own address with the next specified internet address.
            </para>
            
            <para>
            The Timestamp is a right-justified, 32-bit timestamp in milliseconds since midnight UT.  
            If the time is not available in milliseconds or cannot be provided with respect to midnight UT 
            then any time may be inserted as a timestamp provided the high order bit of the timestamp field is set to one 
            to indicate the use of a non-standard value.
            </para>
            
            <para>
            The originating host must compose this option with a large enough timestamp data area to hold all the timestamp information expected.  
            The size of the option does not change due to adding timestamps.  
            The intitial contents of the timestamp data area must be zero or internet address/zero pairs.
            </para>
            
            <para>
            If the timestamp data area is already full (the pointer exceeds the length) the datagram is forwarded without inserting the timestamp, 
            but the overflow count is incremented by one.
            If there is some room but not enough room for a full timestamp to be inserted, or the overflow count itself overflows, 
            the original datagram is considered to be in error and is discarded.
            In either case an ICMP parameter problem message may be sent to the source host.
            </para>
            
            <para>
            The timestamp option is not copied upon fragmentation.  
            It is carried in the first fragment.  
            Appears at most once in a datagram.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.OptionMinimumLength">
            <summary>
            The minimum length in bytes for the option (type, length, pointer, overflow and flags).
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.OptionValueMinimumLength">
            <summary>
            The minimum length in bytes of the option value.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.OverflowMaxValue">
            <summary>
            The maximum value for the overflow field.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.PointedIndexMaxValue">
            <summary>
            The maximum value for the pointed index field.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.Equals(PcapDotNet.Packets.IpV4.IpV4OptionTimestamp)">
            <summary>
            Two options are equal if they have the same value (timestamp, overflow, pointed equals, addresses and timestamps).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two options are equal if they have the same value (timestamp, overflow, pointed equals and addresses).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.GetHashCode">
            <summary>
            The hash code is the xor of the base class hash code, the timestamp and overflow hash code and the pointed index hash code.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionTimestampType,System.Byte,System.Byte)">
            <summary>
            Create the option by giving it all the data.
            </summary>
            <param name="timestampType">The timestamp option type.</param>
            <param name="overflow">The number of IP modules that cannot register timestamps due to lack of space. Maximum value is 15.</param>
            <param name="pointedIndex">The index in the timestamp to points to the octet beginning the space for next timestamp. The timestamp area is considered full when the index points beyond the timestamps.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.EqualValues(PcapDotNet.Packets.IpV4.IpV4OptionTimestamp)">
            <summary>
            True iff the options values is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.WriteValues(System.Byte[],System.Int32@)">
            <summary>
            Writes the value of the option to the buffer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.TimestampType">
            <summary>
            The timestamp option type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.Overflow">
            <summary>
            The number of IP modules that cannot register timestamps due to lack of space.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.PointedIndex">
            <summary>
            The index in the timestamp that points to the for next timestamp. 
            The timestamp area is considered full when the index points beyond the timestamps.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.CountTimestamps">
            <summary>
            The number of timestamps this option holds (or can hold).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestamp.ValuesLength">
            <summary>
            The number of bytes the value of the option take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionTimestampType,System.Byte,System.Byte,System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress})">
            <summary>
            Create the option by giving it all the data.
            </summary>
            <param name="timestampType">The timestamp option type.</param>
            <param name="overflow">The number of IP modules that cannot register timestamps due to lack of space. Maximum value is 15.</param>
            <param name="pointedIndex">The index in the timestamp that points to the for next timestamp.</param>
            <param name="timedRoute">The pairs of addresses and timestamps where each timestamp time passed since midnight UT.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionTimestampType,System.Byte,System.Byte,PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress[])">
            <summary>
            Create the option by giving it all the data.
            </summary>
            <param name="timestampType">The timestamp option type.</param>
            <param name="overflow">The number of IP modules that cannot register timestamps due to lack of space. Maximum value is 15.</param>
            <param name="pointedIndex">The index in the timestamp that points to the for next timestamp.</param>
            <param name="timedRoute">The pairs of addresses and timestamps where each timestamp time passed since midnight UT.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.GetHashCode">
            <summary>
            The hash of this option is the base class hash xored with the hash of each timestamp.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.EqualValues(PcapDotNet.Packets.IpV4.IpV4OptionTimestamp)">
            <summary>
            True iff the options values is equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.WriteValues(System.Byte[],System.Int32@)">
            <summary>
            Writes the value of the option to the buffer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.CountTimestamps">
            <summary>
            The number of timestamps this option holds (or can hold).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.TimedRoute">
            <summary>
            The pairs of addresses and timestamps where each timestamp time passed since midnight UT.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampAndAddress.ValuesLength">
            <summary>
            The number of bytes the value of the option take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Layer">
            <summary>
            Represents IPv4 layer.
            <seealso cref="T:PcapDotNet.Packets.IpV4.IpV4Datagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.#ctor">
            <summary>
            Creates an IPv4 layer with all zero values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.Finalize(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer)">
            <summary>
            Finalizes the layer data in the buffer.
            Used for fields that must be calculated according to the layer's payload (like checksum).
            </summary>
            <param name="buffer">The buffer to finalize the layer in.</param>
            <param name="offset">The offset in the buffer the layer starts.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.Equals(PcapDotNet.Packets.IpV4.IpV4Layer)">
            <summary>
            True iff the two IPv4 layers have the same TypeOfService, Identification, Fragmentation, Ttl, Protocol, HeaderChecksum, Source, Destination and Options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            True iff the two IPv4 layers have the same TypeOfService, Identification, Fragmentation, Ttl, Protocol, HeaderChecksum, Source, Destination and Options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code is a XOR of the TypeOfService and Identification combined and the hash codes of the layer length, data link, Fragmentation, Protocol, HeaderChecksum, Source, Destination, Options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Layer.ToString">
            <summary>
            Contains the Source, Destination and Protocol.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.TypeOfService">
            <summary>
            Type of Service field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Identification">
            <summary>
            The value of the IPv4 ID field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Fragmentation">
            <summary>
            The fragmentation information field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Ttl">
            <summary>
            The TTL field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Protocol">
            <summary>
            The IPv4 (next) protocol field.
            null means that this value should be calculated according to the next layer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.HeaderChecksum">
            <summary>
            The header checksum value.
            null means that this value should be calculated to be correct according to the data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Source">
            <summary>
            The source address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Destination">
            <summary>
            The destination address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Options">
            <summary>
            The options field with all the parsed options if any exist.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.PreviousLayerEtherType">
            <summary>
            The Ethernet Type the Ethernet layer should write when this layer is the Ethernet payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer (in this case: IP).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.PreviousLayerDefaultDestination">
            <summary>
            The default MAC Address value when this layer is the Ethernet payload.
            null means there is no default value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Layer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpInformationRequestDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpInformationRequestDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure">
            <summary>
            The different ICMP code values for Security Failures ICMP type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.BadSecurityParametersIndex">
            <summary>
            RFC 2521.
            Indicates that a received datagram includes a Security Parameters Index (SPI) that is invalid or has expired.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.AuthenticationFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed the authenticity or integrity check for a given SPI.
            
            <para>
            Note that the SPI may indicate an outer Encapsulating Security Protocol when a separate Authentication Header SPI is hidden inside.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.DecompressionFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed a decompression check for a given SPI.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.DecryptionFailed">
            <summary>
            RFC 2521.
            Indicates that a received datagram failed a decryption check for a given SPI.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.NeedAuthentication">
            <summary>
            RFC 2521.
            Indicates that a received datagram will not be accepted without additional authentication.
            
            <para>
            In this case, either no SPI is present, or an unsuitable SPI is present.  
            For example, an encryption SPI without integrity arrives from a secure operating system with mutually suspicious users.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeSecurityFailure.NeedAuthorization">
            <summary>
            RFC 2521.
            Indicates that a received datagram will not be accepted because it has insufficient authorization.
            
            <para>
            In this case, an authentication SPI is present that is inappropriate for the target transport or application.  
            The principle party denoted by the SPI does not have proper authorization for the facilities used by the datagram.  
            For example, the party is authorized for Telnet access, but not for FTP access.
            </para>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.MacAddress">
            <summary>
            Ethernet MacAddress struct.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.MacAddress.SizeOf">
            <summary>
            The number of bytes the struct takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.#ctor(PcapDotNet.Base.UInt48)">
            <summary>
            Constructs the address from a 48 bit integer.
            </summary>
            <param name="value">The 48 bit integer to create the address from.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.#ctor(System.String)">
            <summary>
            Create the address from a string in the format XX:XX:XX:XX:XX:XX.
            </summary>
            <param name="address">The string value in hexadecimal format. Every two digits are separated by a colon.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.ToValue">
            <summary>
            Converts the address to a 48 bit integer.
            </summary>
            <returns>A 48 bit integer representing the address.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.Equals(PcapDotNet.Packets.Ethernet.MacAddress)">
            <summary>
            Two addresses are equal if they have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.Equals(System.Object)">
            <summary>
            Two addresses are equal if they have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.op_Equality(PcapDotNet.Packets.Ethernet.MacAddress,PcapDotNet.Packets.Ethernet.MacAddress)">
            <summary>
            Two addresses are equal if they have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.op_Inequality(PcapDotNet.Packets.Ethernet.MacAddress,PcapDotNet.Packets.Ethernet.MacAddress)">
            <summary>
            Two addresses are different if they have different values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.GetHashCode">
            <summary>
            The hash code of the address is the hash code of its 48 bit integer value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.MacAddress.ToString">
            <summary>
            Converts the address to a string in the format XX:XX:XX:XX:XX:XX.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.MacAddress.Zero">
            <summary>
            A MAC Address of all zeros (00:00:00:00:00:00).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile">
            <summary>
            TCP POC-service-profile Option (RFC 1693).
            
            <pre>
                                      1 bit        1 bit    6 bits
            +----------+----------+------------+----------+--------+
            |  Kind=10 | Length=3 | Start_flag | End_flag | Filler |
            +----------+----------+------------+----------+--------+
            </pre>
            
            <para>
            Contains two 1-bit flags necessary to handle the case where the service profile does not fit in a single TCP segment.  
            The "Start_flag" indicates that the information in the data section represents the beginning of the service profile 
            and the "End_flag" represents the converse.  
            For service profiles which fit completely in a single segment, both flags will be set to 1. 
            Otherwise, the Start_flag is set in the initial segment and the End_flag in the final segment 
            allowing the peer entity to reconstrcut the entire service profile (using the normal sequence numbers in the segment header).  
            The "Filler" field serves merely to complete the third byte of the option.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Creates the option using the given isStart and isEnd values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.#ctor">
            <summary>
            The default is for service profiles which fit completely in a single segment.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.Equals(PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile)">
            <summary>
            Two partial order service profile options are equal if they agree on both IsStart and IsEnd.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two partial order service profile options are equal if they agree on both IsStart and IsEnd.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.GetHashCode">
            <summary>
            The hash code of the partial order service profile option is the hash code of the option type xored with a combination of the IsStart and IsEnd values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.IsStart">
            <summary>
            Indicates that the information in the data section represents the beginning of the service profile.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.IsEnd">
            <summary>
            Indicates that the information in the data section represents the end of the service profile.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionPartialOrderServiceProfile.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionMd5Signature">
            <summary>
            <pre>
            +---------+---------+-------------------+
            | Kind=19 |Length=18|   MD5 digest...   |
            +---------+---------+-------------------+
            |                                       |
            +---------------------------------------+
            |                                       |
            +---------------------------------------+
            |                                       |
            +-------------------+-------------------+
            |                   |
            +-------------------+
            </pre>
            
            <para>
            The MD5 digest is always 16 bytes in length, and the option would appear in every segment of a connection.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.#ctor(System.Collections.Generic.IList{System.Byte})">
            <summary>
            Creates the option using the given signature data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.#ctor">
            <summary>
            The default signature is all zeroes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.Equals(PcapDotNet.Packets.Transport.TcpOptionMd5Signature)">
            <summary>
            Two MD5 signature options are equal if they have the same signature value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two MD5 signature options are equal if they have the same signature value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.GetHashCode">
            <summary>
            The hash code of the MD5 signature option is the hash code of the option type xored with the hash code of the signature.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.Data">
            <summary>
            The signature value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMd5Signature.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumType">
            <summary>
            The type of the checksum to be used.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumType.TcpChecksum">
            <summary>
            TCP checksum.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumType.FletchersAlgorithm8Bit">
            <summary>
            8-bit Fletcher's algorithm.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumType.FletchersAlgorithm16Bit">
            <summary>
            16-bit Fletcher's algorithm.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities">
            <summary>
            This field identifies the National Access Programs or Special Access Programs 
            which specify protection rules for transmission and processing of the information contained in the datagram. 
            Protection authority flags do NOT represent accreditation authorities, though the semantics are superficially similar.  
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.None">
            <summary>
            No protection authorities.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.Genser">
            <summary>
            Designated Approving Authority per DOD 5200.28
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.SingleIntegrationOptionalPlanExtremelySensitiveInformation">
            <summary>
            Single Integrated Operational Plan - Extremely Sensitive Information (SIOP-ESI).
            Department of Defense Organization of the Joint Chiefs of Staff 
            Attn: J6 Washington, DC  20318-6000
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.SensitiveCompartmentedInformation">
            <summary>
            Sensitive Compartmented Information (SCI).
            Director of Central Intelligence 
            Attn: Chairman, Information Handling Committee, Intelligence Community Staff Washington, D.C. 20505
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.Nsa">
            <summary>
            National Security Agency (NSA).
            9800 Savage Road Attn: T03 Ft. Meade, MD 20755-6000
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities.DepartmentOfEnergy">
            <summary>
            Department of Energy (DOE).
            Attn:  DP343.2 Washington, DC  20545
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionLooseSourceRouting">
            <summary>
            Loose Source and Record Route
            <pre>
            +--------+--------+--------+---------//--------+
            |10000011| length | pointer|     route data    |
            +--------+--------+--------+---------//--------+
             Type=131
            </pre>
            
            <para>
              The loose source and record route (LSRR) option provides a means for the source of an internet datagram 
              to supply routing information to be used by the gateways in forwarding the datagram to the destination, 
              and to record the route information.
            </para>
            
            <para>
              The option begins with the option type code.  
              The second octet is the option length which includes the option type code and the length octet, 
              the pointer octet, and length-3 octets of route data.  
              The third octet is the pointer into the route data indicating the octet which begins the next source address to be processed.  
              The pointer is relative to this option, and the smallest legal value for the pointer is 4.
            </para>
            
            <para>
              A route data is composed of a series of internet addresses.
              Each internet address is 32 bits or 4 octets.  
              If the pointer is greater than the length, the source route is empty (and the recorded route full) 
              and the routing is to be based on the destination address field.
              If the address in destination address field has been reached and the pointer is not greater than the length, 
              the next address in the source route replaces the address in the destination address field, 
              and the recorded route address replaces the source address just used, and pointer is increased by four.
            </para>
            
            <para>
              The recorded route address is the internet module's own internet address 
              as known in the environment into which this datagram is being forwarded.
            </para>
            
            <para>
              This procedure of replacing the source route with the recorded route 
              (though it is in the reverse of the order it must be in to be used as a source route) means the option (and the IP header as a whole) 
              remains a constant length as the datagram progresses through the internet.
            </para>
            
            <para>
              This option is a loose source route because the gateway or host IP 
              is allowed to use any route of any number of other intermediate gateways to reach the next address in the route.
            </para>
            
            <para>
              Must be copied on fragmentation.  
              Appears at most once in a datagram.
            </para>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionLooseSourceRouting.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Address},System.Byte)">
            <summary>
            Constructs the option from the given values.
            </summary>
            <param name="route">The route addresses values.</param>
            <param name="pointedAddressIndex">The pointed index in the route.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionLooseSourceRouting.#ctor">
            <summary>
            Empty loose source routing.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionLooseSourceRouting.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+------------+
            | Bit | 0-7  | 8-15 | 16-31      |
            +-----+------+------+------------+
            | 0   | Type | Code | Checksum   |
            +-----+------+------+------------+
            | 0   | Gateway Internet Address |
            +-----+--------------------------+
            | 32  | Internet Header          |
            |     | + 64 bits of             |
            |     | Original Data Datagram   |
            +-----+--------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram.GatewayInternetAddress">
            <summary>
            Address of the gateway to which traffic for the network specified in the internet destination network field of the original datagram's data should be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRedirectDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimestampReplyLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimestampReplyLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpParameterProblemLayer">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpParameterProblemLayer.Pointer">
            <summary>
            The pointer identifies the octet of the original datagram's header where the error was detected (it may be in the middle of an option).  
            For example, 1 indicates something is wrong with the Type of Service, and (if there are options present) 20 indicates something is wrong with the type code of the first option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpParameterProblemLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpParameterProblemLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreVersion">
            <summary>
            The GRE Version Number.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreVersion.Gre">
            <summary>
            RFC 1701, RFC 2784
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreVersion.EnhancedGre">
            <summary>
            RFC 2637
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp">
            <summary>
            RFC 1702.
            Represents a source route entry consisting of a list of IP addresses and indicates an IP source route.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{PcapDotNet.Packets.IpV4.IpV4Address},System.Int32)">
            <summary>
            Initializes using the given IP addresses and the next as number index.
            </summary>
            <param name="addresses">IP addresses of the source route.</param>
            <param name="nextAddressIndex">The next IP address index in the source route.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.EqualsPayloads(PcapDotNet.Packets.Gre.GreSourceRouteEntry)">
            <summary>
            True iff the IP addresses are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the payload to the given buffer in the given offset.
            </summary>
            <param name="buffer">The buffer to write the payload to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.AddressFamily">
            <summary>
            The Address Family field contains a two octet value which indicates the syntax and semantics of the Routing Information field.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.PayloadLength">
            <summary>
            The SRE Length field contains the number of octets in the SRE.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.PayloadOffset">
            <summary>
            The SRE Offset field indicates the octet offset from the start of the Routing Information field to the first octet of the active entry in Source Route Entry to be examined.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.PayloadHashCode">
            <summary>
            The xor of the hash code of the IP addresses.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.Addresses">
            <summary>
            IP addresses of the source route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.NextAddressIndex">
            <summary>
            The next IP address index in the source route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryIp.NextAddress">
            <summary>
            The next IP address.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreDatagram">
            <summary>
            RFC 1701, RFC 1702, RFC 2637, RFC 2784.
            <pre>
            +-----+---+---+---+---+---+-------+---+-------+---------+-------------------+
            | Bit | 0 | 1 | 2 | 3 | 4 | 5-7   | 8 | 9-12  | 13-15   | 16-31             |
            +-----+---+-----------+---+-------+---+-------+---------+-------------------+
            | 0   | C | R | K | S | s | Recur | A | Flags | Version | Protocol Type     |
            +-----+---+-----------+---+-------+---+-------+---------+-------------------+
            | 32  | Checksum (optional)                             | Offset (optional) |
            +-----+-------------------------------------------------+-------------------+
            | 32  | Key (optional)                                                      |
            +-----+---------------------------------------------------------------------+
            | 32  | Sequence Number (optional)                                          |
            +-----+---------------------------------------------------------------------+
            | 32  | Acknowledgment Number (optional)                                    |
            +-----+---------------------------------------------------------------------+
            | 32  | Routing (optional)                                                  |
            +-----+---------------------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Gre.GreDatagram.HeaderMinimumLength">
            <summary>
            The minimum number of bytes the GRE header can contain.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreDatagram.CalculateIsValid">
            <summary>
            A GRE Datagram is valid if its length is enough for the GRE header, its routing information is valid,
            the bits for future use are set to 0, it has acknowledgment sequence number only if it's Enhanced GRE,
            if it has checksum the checksum is correct and its payload is correct.
            </summary>
            <returns>true iff the datagram is valid.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.HeaderLength">
            <summary>
            The length of the full GRE header on bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.ChecksumPresent">
            <summary>
            If the Checksum Present bit is set to 1, then the Checksum field is present and contains valid information.
            If either the Checksum Present bit or the Routing Present bit are set, BOTH the Checksum and Offset fields are present in the GRE packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.RoutingPresent">
            <summary>
            If the Routing Present bit is set to 1, then it indicates that the Offset and Routing fields are present and contain valid information.
            If either the Checksum Present bit or the Routing Present bit are set, BOTH the Checksum and Offset fields are present in the GRE packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.KeyPresent">
            <summary>
            If the Key Present bit is set to 1, then it indicates that the Key field is present in the GRE header.  
            Otherwise, the Key field is not present in the GRE header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.SequenceNumberPresent">
            <summary>
            If the Sequence Number Present bit is set to 1, then it indicates that the Sequence Number field is present.  
            Otherwise, the Sequence Number field is not present in the GRE header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.StrictSourceRoute">
            <summary>
            If the source route is incomplete, then the Strict Source Route bit is checked.  
            If the source route is a strict source route and the next IP destination or autonomous system is NOT an adjacent system, the packet MUST be dropped.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.RecursionControl">
            <summary>
            Recursion control contains a three bit unsigned integer which contains the number of additional encapsulations which are permissible.  
            This SHOULD default to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.AcknowledgmentSequenceNumberPresent">
            <summary>
            Set to one (1) if packet contains Acknowledgment Number to be used for acknowledging previously transmitted data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.FutureUseBits">
            <summary>
            Must be set to zero (0).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.Version">
            <summary>
            The GRE Version Number.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.ProtocolType">
            <summary>
            The Protocol Type field contains the protocol type of the payload packet. 
            These Protocol Types are defined in [RFC1700] as "ETHER TYPES" and in [ETYPES]. 
            An implementation receiving a packet containing a Protocol Type which is not listed in [RFC1700] or [ETYPES] SHOULD discard the packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.Checksum">
            <summary>
            The Checksum field contains the IP (one's complement) checksum sum of the all the 16 bit words in the GRE header and the payload packet.
            For purposes of computing the checksum, the value of the checksum field is zero. 
            This field is present only if the Checksum Present bit is set to one.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.IsChecksumCorrect">
            <summary>
            True iff the checksum value is correct according to the datagram data.
            Valid only if the Checksum Present bit is set to one.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.RoutingOffset">
            <summary>
            The offset field indicates the octet offset from the start of the Routing field to the first octet of the active Source Route Entry to be examined.  
            This field is present if the Routing Present or the Checksum Present bit is set to 1, and contains valid information only if the Routing Present bit is set to 1.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.ActiveSourceRouteEntryIndex">
            <summary>
            The index in the Routing collection of the active source route entry.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.ActiveSourceRouteEntry">
            <summary>
            The active Source Route Entry to be examined.
            Contains valid information only if the Routing Present bit is set to 1.
            if the offset points to the end of the routing information, returns null.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.Key">
            <summary>
            The Key field contains a four octet number which was inserted by the encapsulator.  
            It may be used by the receiver to authenticate the source of the packet.  
            The Key field is only present if the Key Present field is set to 1.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.KeyPayloadLength">
            <summary>
            (High 2 octets of Key) Size of the payload, not including the GRE header
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.KeyCallId">
            <summary>
            (Low 2 octets of Key) Contains the Peer's Call ID for the session to which this packet belongs.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.SequenceNumber">
            <summary>
            The Sequence Number field contains an unsigned 32 bit integer which is inserted by the encapsulator.  
            It may be used by the receiver to establish the order in which packets have been transmitted from the encapsulator to the receiver.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.AcknowledgmentSequenceNumber">
            <summary>
            Contains the sequence number of the highest numbered GRE packet received by the sending peer for this user session.
            Present if A bit (Bit 8) is one (1).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.Routing">
            <summary>
            The Routing field is optional and is present only if the Routing Present bit is set to 1.
            The Routing field is a list of Source Route Entries (SREs). 
            Each SRE has the form:
            <pre>
            +-----+----------------+------------+------------+
            | Bit | 0-15           | 16-23      | 24-31      |
            +-----+----------------+------------+------------+
            | 0   | Address Family | SRE Offset | SRE Length |
            +-----+----------------+------------+------------+
            | 32  | Routing Information ...                  |
            +-----+------------------------------------------+
            </pre>
            The routing field is terminated with a "NULL" SRE containing an address family of type 0x0000 and a length of 0.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.Payload">
            <summary>
            The Ethernet payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.IpV4">
            <summary>
            The Ethernet payload as an IPv4 datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreDatagram.Arp">
            <summary>
            The Ethernet payload as an ARP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.EthernetType">
            <summary>
            EtherType is a two-octet field in an Ethernet frame, as defined by the Ethernet II framing networking standard. 
            It is used to indicate which protocol is encapsulated in the payload.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.None">
            <summary>
            No Ethernet type
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.IpV4">
            <summary>
            Internet Protocol, Version 4 (IPv4)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.Arp">
            <summary>
            Address Resolution Protocol (ARP)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.ReverseArp">
            <summary>
            Reverse Address Resolution Protocol (RARP)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.AppleTalk">
            <summary>
            AppleTalk (Ethertalk)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.AppleTalkArp">
            <summary>
            AppleTalk Address Resolution Protocol (AARP)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.VLanTaggedFrame">
            <summary>
            VLAN-tagged frame (IEEE 802.1Q)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.NovellInternetworkPacketExchange">
            <summary>
            Novell IPX (alt)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.Novell">
            <summary>
            Novell
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.IpV6">
            <summary>
            Internet Protocol, Version 6 (IPv6)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.MacControl">
            <summary>
            MAC Control
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.PointToPointProtocol">
            <summary>
            PPP, Point-to-Point Protocol
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.CobraNet">
            <summary>
            CobraNet
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.MultiprotocolLabelSwitchingUnicast">
            <summary>
            MPLS unicast
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.MultiprotocolLabelSwitchingMulticast">
            <summary>
            MPLS multicast
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.PointToPointProtocolOverEthernetDiscoveryStage">
            <summary>
            PPPoE Discovery Stage
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.PointToPointProtocolOverEthernetSessionStage">
            <summary>
            PPPoE Session Stage 
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.ExtensibleAuthenticationProtocolOverLan">
            <summary>
            EAP over LAN (IEEE 802.1X)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.HyperScsi">
            <summary>
            HyperSCSI (SCSI over Ethernet)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.AtaOverEthernet">
            <summary>
            ATA over Ethernet
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.EtherCatProtocol">
            <summary>
            EtherCAT Protocol
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.ProviderBridging">
            <summary>
            Provider Bridging (IEEE 802.1ad)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.AvbTransportProtocol">
            <summary>
            AVB Transport Protocol (AVBTP)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.SerialRealTimeCommunicationSystemIii">
            <summary>
            SERCOS III
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.CircuitEmulationServicesOverEthernet">
            <summary>
            Circuit Emulation Services over Ethernet (MEF-8)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.HomePlug">
            <summary>
            HomePlug
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.MacSecurity">
            <summary>
            MAC security (IEEE 802.1AE)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.PrecisionTimeProtocol">
            <summary>
            Precision Time Protocol (IEEE 1588)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.ConnectivityFaultManagementOrOperationsAdministrationManagement">
            <summary>
            IEEE 802.1ag Connectivity Fault Management (CFM) Protocol / ITU-T Recommendation Y.1731 (OAM)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.FibreChannelOverEthernet">
            <summary>
            Fibre Channel over Ethernet
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.FibreChannelOverEthernetInitializationProtocol">
            <summary>
            FCoE Initialization Protocol
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.QInQ">
            <summary>
            Q-in-Q
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetType.VeritasLowLatencyTransport">
            <summary>
            Veritas Low Latency Transport (LLT)
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetPayloadDatagrams.IpV4">
            <summary>
            The Ethernet payload as an IPv4 datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetPayloadDatagrams.Arp">
            <summary>
            The Ethernet payload as an ARP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetPayloadDatagrams.Payload">
            <summary>
            The Ethernet payload.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.EthernetDatagram">
            <summary>
            Represents an Ethernet datagram.
            
            <pre>
            +------+-----------------+------------+------------------+
            | Byte | 0-5             | 6-11       | 12-13            |
            +------+-----------------+------------+------------------+
            | 0    | MAC Destination | MAC Source | EtherType/Length |
            +------+-----------------+------------+------------------+
            | 14   | Data                                            |
            +------+-------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Ethernet.EthernetDatagram.HeaderLength">
            <summary>
            Ethernet header length in bytes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetDatagram.CalculateIsValid">
            <summary>
            An Ethernet datagram is valid iff its length is big enough for the header and its payload is valid.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.BroadcastAddress">
            <summary>
            The broadcast MAC address (FF:FF:FF:FF:FF:FF).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.PayloadLength">
            <summary>
            The Ethernet payload length in bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.Source">
            <summary>
            Ethernet source address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.Destination">
            <summary>
            Ethernet destination address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.EtherType">
            <summary>
            Ethernet type (next protocol).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.Payload">
            <summary>
            The Ethernet payload.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.Trailer">
            <summary>
            The bytes padding the Ethernet packet beyond the actual Ethernet payload.
            This assumes we know how to calculate the actual payload length (For example, by using the Total Length of the IPv4 payload).
            If we don't know how to calculate the actual payload length <see langword="null"/> will be returned.
            The trailer doesn't include the <see cref="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.FrameCheckSequence"/> if it exists.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.FrameCheckSequence">
            <summary>
            The 4 bytes of the France Check Sequence (FCS).
            Usually, these bytes won't be available because the device remvoed them after checking their validity.
            We assume they exist when we see that the Ethernet padding pads to 68 bytes or more.
            If the padding isn't that long or we don't know how to calculate the real payload length, <see langword="null"/> will be returned.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.IpV4">
            <summary>
            The Ethernet payload as an IPv4 datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetDatagram.Arp">
            <summary>
            The Ethernet payload as an ARP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.PacketBuilder">
             <summary>
             This class is used to build different packets.
             Packets are built from layers.
             This class can be used using static Build methods by giving the Packet's timestamp and layers.
             This class can be instantiated with different layers and then use the Build method by only giving the Packet's timestamp.
             If a layer that an instance of this class holds is modified, the PacketBuilder instance will create different packets.
             <example>This sample shows how to create ICMP Echo Request packets to different servers with different IP ID and ICMP sequence numbers and identifiers.
             <code>
               EthernetLayer ethernetLayer = new EthernetLayer
                                                 {
                                                     Source = new MacAddress("00:01:02:03:04:05"),
                                                     Destination = new MacAddress("A0:A1:A2:A3:A4:A5")
                                                 };
            
               IpV4Layer ipV4Layer = new IpV4Layer
                                         {
                                             Source = new IpV4Address("1.2.3.4"),
                                             Ttl = 128,
                                         };
            
               IcmpEchoLayer icmpLayer = new IcmpEchoLayer();
            
               PacketBuilder builder = new PacketBuilder(ethernetLayer, ipV4Layer, icmpLayer);
            
               List&lt;Packet&gt; packets = new List&lt;Packet&gt;();
            
               for (int i = 0; i != 100; ++i)
               {
                   ipV4Layer.Destination = new IpV4Address("2.3.4." + i);
                   ipV4Layer.Identification = (ushort)i;
                   icmpLayer.SequenceNumber = (ushort)i;
                   icmpLayer.Identifier = (ushort)i;
            
                   packets.Add(builder.Build(DateTime.Now));
               }
             </code>
             </example>
             </summary>
        </member>
        <member name="M:PcapDotNet.Packets.PacketBuilder.Build(System.DateTime,PcapDotNet.Packets.ILayer[])">
            <summary>
            Builds a single packet using the given layers with the given timestamp.
            </summary>
            <param name="timestamp">The packet's timestamp.</param>
            <param name="layers">The layers to build the packet accordingly and by their order.</param>
            <returns>A packet built from the given layers with the given timestamp.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.PacketBuilder.Build(System.DateTime,System.Collections.Generic.IEnumerable{PcapDotNet.Packets.ILayer})">
            <summary>
            Builds a single packet using the given layers with the given timestamp.
            </summary>
            <param name="timestamp">The packet's timestamp.</param>
            <param name="layers">The layers to build the packet accordingly and by their order.</param>
            <returns>A packet built from the given layers with the given timestamp.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.PacketBuilder.#ctor(PcapDotNet.Packets.ILayer[])">
            <summary>
            Creates a PacketBuilder that can build packets according to the given layers and with different timestamps.
            The layers' properties can be modified after the builder is built and this will affect the packets built.
            </summary>
            <param name="layers">The layers to build the packet accordingly and by their order.</param>
        </member>
        <member name="M:PcapDotNet.Packets.PacketBuilder.#ctor(System.Collections.Generic.IEnumerable{PcapDotNet.Packets.ILayer})">
            <summary>
            Creates a PacketBuilder that can build packets according to the given layers and with different timestamps.
            The layers' properties can be modified after the builder is built and this will affect the packets built.
            </summary>
            <param name="layers">The layers to build the packet accordingly and by their order.</param>
        </member>
        <member name="M:PcapDotNet.Packets.PacketBuilder.Build(System.DateTime)">
            <summary>
            Builds a single packet using the builder's layers with the given timestamp.
            </summary>
            <param name="timestamp">The packet's timestamp.</param>
            <returns>A packet built from the builder's layers with the given timestamp.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute">
            <summary>
            The presence of this option in an ICMP Echo (or any other) packet, hereinafter referred to as the Outbound Packet, 
            will cause a router to send the newly defined ICMP Traceroute message to the originator of the Outbound Packet.  
            In this way, the path of the Outbound Packet will be logged by the originator with only n+1 (instead of 2n) packets.  
            This algorithm does not suffer from a changing path and allows the response to the Outbound Packet, 
            hereinafter refered to as the Return Packet, to be traced 
            (provided the Outbound Packet's destination preserves the IP Traceroute option in the Return Packet).
            
            <para>
            IP Traceroute option format
            <pre>
             0               8              16              24
            +-+---+---------+---------------+-------------------------------+
            |F| C |  Number |    Length     |          ID Number            |
            +-+---+-------------------------+-------------------------------+
            |      Outbound Hop Count       |       Return Hop Count        |
            +-------------------------------+-------------------------------+
            |                     Originator IP Address                     |
            +---------------------------------------------------------------+
            </pre>
            </para>
            
            <para>
            F (copy to fragments): 0 (do not copy to fragments)
            C (class): 2 (Debugging and Measurement)
            Number: 18 (F+C+Number = 82)
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.OptionValueLength">
            <summary>
            The number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.#ctor(System.UInt16,System.UInt16,System.UInt16,PcapDotNet.Packets.IpV4.IpV4Address)">
            <summary>
            Create the trace route option from the trace route option values.
            </summary>
            <param name="identification">
            An arbitrary number used by the originator of the Outbound Packet to identify the ICMP Traceroute messages.  
            It is NOT related to the ID number in the IP header.
            </param>
            <param name="outboundHopCount">
            Outbound Hop Count (OHC)
            The number of routers through which the Outbound Packet has passed.  
            This field is not incremented by the Outbound Packet's destination.
            </param>
            <param name="returnHopCount"></param>
            Return Hop Count (RHC)
            The number of routers through which the Return Packet has passed.
            This field is not incremented by the Return Packet's destination.       
            <param name="originatorIpAddress">
            The IP address of the originator of the Outbound Packet.  
            This isneeded so the routers know where to send the ICMP Traceroute message for Return Packets.  
            It is also needed for Outbound Packets which have a Source Route option.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.#ctor">
            <summary>
            Creates empty trace route option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.Equals(PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute)">
            <summary>
            Two trace route options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two trace route options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.GetHashCode">
            <summary>
            The hash code is the xor of the base class hash code with the following values hash code:
            The identification, the combination of the outbound and return hop count, the originator address.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.Identification">
            <summary>
            An arbitrary number used by the originator of the Outbound Packet to identify the ICMP Traceroute messages.  
            It is NOT related to the ID number in the IP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.OriginatorIpAddress">
            <summary>
            The IP address of the originator of the Outbound Packet.  
            This isneeded so the routers know where to send the ICMP Traceroute message for Return Packets.  
            It is also needed for Outbound Packets which have a Source Route option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.OutboundHopCount">
            <summary>
            Outbound Hop Count (OHC)
            The number of routers through which the Outbound Packet has passed.  
            This field is not incremented by the Outbound Packet's destination.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.ReturnHopCount">
            <summary>
            Return Hop Count (RHC)
            The number of routers through which the Return Packet has passed.
            This field is not incremented by the Return Packet's destination.       
            /// </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTraceRoute.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpReportVersion1Layer">
            <summary>
            RFC 1112.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpReportVersion1Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpLeaveGroupVersion2Layer">
            <summary>
            RFC 2236.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpLeaveGroupVersion2Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.NetUnreachable">
            <summary>
            If, according to the information in the gateway's routing tables, 
            the network specified in the internet destination field of a datagram is unreachable, 
            e.g., the distance to the network is infinity, 
            the gateway may send a destination unreachable message to the internet source host of the datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.HostUnreachable">
            <summary>
            RFC 792.
            In some networks, the gateway may be able to determine if the internet destination host is unreachable.  
            Gateways in these networks may send destination unreachable messages to the source host when the destination host is unreachable.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.ProtocolUnreachable">
            <summary>
            RFC 792.
            If, in the destination host, the IP module cannot deliver the datagram because the indicated protocol module is not active, 
            the destination host may send a destination unreachable message to the source host.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.PortUnreachable">
            <summary>
            RFC 792.
            If, in the destination host, the IP module cannot deliver the datagram because the indicated process port is not active, 
            the destination host may send a destination unreachable message to the source host.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.FragmentationNeededAndDoNotFragmentSet">
            <summary>
            RFC 792.
            A datagram must be fragmented to be forwarded by a gateway yet the Don't Fragment flag is on.  
            In this case the gateway must discard the datagram and may return a destination unreachable message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeDestinationUnreachable.SourceRouteFailed">
            <summary>
            RFC 792.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpCodeTraceRoute">
            <summary>
            The ICMP code values for Traceroute ICMP type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeTraceRoute.OutboundPacketSuccessfullyForwarded">
            <summary>
            RFC 1393.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpCodeTraceRoute.NoRouteForOutboundPacketDiscarded">
            <summary>
            RFC 1393.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpFieldParameters">
            <summary>
            Represents a set of HTTP field parameters.
            Used for some of HTTP fields.
            All parameters must have different names.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.#ctor(System.Collections.Generic.KeyValuePair{System.String,System.String}[])">
            <summary>
            Creates the parameters from an array of parameters. Keys are the parameters names and values are the parameters values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Creates the parameters from an enumerable of parameters. Keys are the parameters names and values are the parameters values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.GetEnumerator">
            <summary>
            Enumerates over the parameters.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.Equals(PcapDotNet.Packets.Http.HttpFieldParameters)">
            <summary>
            Two HTTP field parameters are equal if all of their parameters are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.Equals(System.Object)">
            <summary>
            Two HTTP field parameters are equal if all of their parameters are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.GetHashCode">
            <summary>
            Xor of all of the hash codes of the parameters names and values.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpFieldParameters.ToString">
            <summary>
            Returns a string of parameters beginning and separated by semicolon and equal sign between keys and values.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpFieldParameters.Count">
            <summary>
            Number of parameters.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpFieldParameters.Item(System.String)">
            <summary>
            Returns the value of the given parameter name.
            </summary>
            <param name="name">The name of the parameter.</param>
            <returns>The value of the parameter.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.Arp.IArpPreviousLayer">
            <summary>
            A layer that contains an ARP layer.
            Must provide the ARP hardware type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.IArpPreviousLayer.PreviousLayerHardwareType">
            <summary>
            The ARP Hardware Type of the layer before the ARP layer.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest">
            <summary>
            TCP Alternate Checksum Request Option (RFC 1146).
            <pre>
            +----------+----------+----------+
            |  Kind=14 | Length=3 |  chksum  |
            +----------+----------+----------+
            </pre>
            
            <para>
            Here chksum is a number identifying the type of checksum to be used.
            </para>
            
            <para>
            The currently defined values of chksum are:
            <list>
              <item>0  - TCP checksum.</item>
              <item>1  - 8-bit  Fletcher's algorithm.</item>
              <item>2  - 16-bit Fletcher's algorithm.</item>
            </list>
            </para>
            
            <para>
            Note that the 8-bit Fletcher algorithm gives a 16-bit checksum and the 16-bit algorithm gives a 32-bit checksum.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.#ctor(PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumType)">
            <summary>
            Creates the option using the given checksum type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.#ctor">
            <summary>
            The default checksum type is the TCP checksum.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.Equals(PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest)">
            <summary>
            Two alternate checksum request options are equal if they have the same checksum type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two alternate checksum request options are equal if they have the same checksum type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.GetHashCode">
            <summary>
            The hash code of this option is the hash code of the option type xored with hash code of the checksum type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.ChecksumType">
            <summary>
            The type of the checksum.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumRequest.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTimestampType">
            <summary>
            The type of the timestamp ip option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestampType.TimestampOnly">
            <summary>
            Time stamps only, stored in consecutive 32-bit words.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestampType.AddressAndTimestamp">
            <summary>
            Each timestamp is preceded with internet address of the registering entity.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionTimestampType.AddressPrespecified">
            <summary>
            The internet address fields are prespecified.  
            An IP module only registers its timestamp if it matches its own address with the next specified internet address.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly">
            <summary>
            Represents a timestamp IPv4 option with only the timestamps.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.#ctor(System.Byte,System.Byte,System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4TimeOfDay})">
            <summary>
            Create the option by giving it all the data.
            </summary>
            <param name="overflow">The number of IP modules that cannot register timestamps due to lack of space. Maximum value is 15.</param>
            <param name="pointedIndex">The index in the timestamp that points to the for next timestamp.</param>
            <param name="timestamps">The timestamps as time passed since midnight UT.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.#ctor(System.Byte,System.Byte,PcapDotNet.Packets.IpV4.IpV4TimeOfDay[])">
            <summary>
            Create the option by giving it all the data.
            </summary>
            <param name="overflow">The number of IP modules that cannot register timestamps due to lack of space. Maximum value is 15.</param>
            <param name="pointedIndex">The index in the timestamp that points to the for next timestamp.</param>
            <param name="timestamps">The timestamps as time passed since midnight UT.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.GetHashCode">
            <summary>
            The hash code of this options is the hash code of the base class xored with the hash code of the timestamps.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.EqualValues(PcapDotNet.Packets.IpV4.IpV4OptionTimestamp)">
            <summary>
            Compares the values of the options.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.WriteValues(System.Byte[],System.Int32@)">
            <summary>
            Writes the value of the option to the buffer.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.CountTimestamps">
            <summary>
            The number of timestamps this option holds (or can hold).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.Timestamps">
            <summary>
            The timestamps as time passed since midnight UT.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimestampOnly.ValuesLength">
            <summary>
            The number of bytes the value of the option take.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpUnknownLayer">
            <summary>
            Represents an ICMP layer with an unknown message type.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpUnknownDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the ICMP payload to the buffer.
            Doesn't include payload in the next layers.
            </summary>
            <param name="buffer">The buffer to write the ICMP payload to.</param>
            <param name="offset">The offset in the buffer to start writing the payload at.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.LayerMessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.LayerCode">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.LayerVariable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.Payload">
            <summary>
            The payload of the ICMP.
            All the data without the ICMP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.PayloadLength">
            <summary>
            The number of bytes the ICMP payload takes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpUnknownLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram">
            <summary>
            RFC 1256.
            <pre>
            +-----+-----------+-----------------+----------+
            | Bit | 0-7       | 8-15            | 16-31    |
            +-----+-----------+-----------------+----------+
            | 0   | Type      | Code            | Checksum |
            +-----+-----------+-----------------+----------+
            | 32  | Num Addrs | Addr Entry Size | Lifetime |
            +-----+-----------+-----------------+----------+
            | 64  | Router Address[1]                      |
            +-----+----------------------------------------+
            | 96  | Preference Level[1]                    |
            +-----+----------------------------------------+
            | 128 | Router Address[2]                      |
            +-----+----------------------------------------+
            | 160 | Preference Level[2]                    |
            +-----+----------------------------------------+
            |  .  |                   .                    |
            |  .  |                   .                    |
            |  .  |                   .                    |
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.DefaultAddressEntrySize">
            <summary>
            The default number of 32-bit words of information per each router address.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct, the code is in the expected range
            and the address entry size is the default address entry size.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.NumberOfAddresses">
            <summary>
            The number of router addresses advertised in this message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.AddressEntrySize">
            <summary>
            The number of 32-bit words of information per each router address (2, in the version of the protocol described here).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.LifetimeSeconds">
            <summary>
            The maximum number of seconds that the router addresses may be considered valid.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.Lifetime">
            <summary>
            The maximum time that the router addresses may be considered valid.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementDatagram.Entries">
            <summary>
            The pairs of sending router's IP address(es) on the interface from which this message is sent
            and the preferability of each Router Address[i] as a default router address, relative to other router addresses on the same subnet.
            A signed, twos-complement value; higher values mean more preferable.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpVersion">
            <summary>
            Represents an HTTP version.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpVersion.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Creates a version from the major and minor version numbers.
            </summary>
            <param name="major">The major version number. 0 for 0.9, 1 for 1.0 or 1.1.</param>
            <param name="minor">The minor version number. 9 for 0.9, 0, for 1.0 and 1 for 1.1.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpVersion.ToString">
            <summary>
            A string represneting the version.
            Example: &quot;HTTP/1.1&quot;.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpVersion.Equals(PcapDotNet.Packets.Http.HttpVersion)">
            <summary>
            Two HTTP versions are equal iff they have the same major and minor versions.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpVersion.Equals(System.Object)">
            <summary>
            Two HTTP versions are equal iff they have the same major and minor versions.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpVersion.GetHashCode">
            <summary>
            The hash code of an http version is the xor of the hash codes of the minor version and the major version.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpVersion.Version10">
            <summary>
            A built version for HTTP/1.0.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpVersion.Version11">
            <summary>
            A built version for HTTP/1.1.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpVersion.Major">
            <summary>
            The major version number.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpVersion.Minor">
            <summary>
            The minor version number.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpVersion.Length">
            <summary>
            The number of bytes this version takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpResponseDatagram">
            <summary>
            RFC 2616.
            Represents an HTTP response.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpResponseDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseDatagram.IsRequest">
            <summary>
            False since this is message is a response.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseDatagram.StatusCode">
            <summary>
            The status code of the response.
            null if no status code exists.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpResponseDatagram.ReasonPhrase">
            <summary>
            The data of the reason phrase.
            Example: OK
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.UdpDatagram">
            <summary>
            RFC 768.
            This User Datagram Protocol (UDP) is defined to make available a datagram mode of packet-switched computer communication  
            in  the environment of an interconnected set of computer networks.   
            This protocol assumes that the Internet Protocol (IP) is used as the underlying protocol.
            
            <para>
            This protocol provides a procedure for application programs to send messages  to other programs 
            with a minimum of protocol mechanism. 
            The protocol is transaction oriented, and delivery and duplicate protection are not guaranteed.  
            Applications requiring ordered reliable delivery of streams of data should use the Transmission Control Protocol (TCP).
            </para>
            
            <para>
            Format
            <pre>
             0      7 8     15 16    23 24    31
            +--------+--------+--------+--------+
            |     Source      |   Destination   |
            |      Port       |      Port       |
            +--------+--------+--------+--------+
            |                 |                 |
            |     Length      |    Checksum     |
            +--------+--------+--------+--------+
            |
            |          data octets ...
            +---------------- ...
            </pre>
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.UdpDatagram.HeaderLength">
            <summary>
            The number of bytes the datagram header takes.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.UdpDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.UdpDatagram.CalculateIsValid">
            <summary>
            A udp datagram is valid if it has a full header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpDatagram.TotalLength">
            <summary>
            The length in octets of this user datagram including this header and the data.   
            (This  means  the minimum value of the length is eight.)
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpDatagram.Checksum">
            <summary>
            Checksum is the 16-bit one's complement of the one's complement sum of a pseudo header of information from the IP header, 
            the UDP header, and the data, padded  with zero octets at the end (if  necessary) to  make  a multiple of two octets.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpDatagram.IsChecksumOptional">
            <summary>
            True iff the checksum for the transport type is optional.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.UdpDatagram.Payload">
            <summary>
            The payload of the UDP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionConnectionCountNew">
            <summary>
            CC.NEW Option (RFC 1644).
            <pre>
            +--------+--------+--------+--------+--------+--------+
            |00001100|00000110|    Connection Count:  SEG.CC      |
            +--------+--------+--------+--------+--------+--------+
             Kind=12  Length=6
            </pre>
            
            <para>
            This option may be sent instead of a CC option in an initial &lt;SYN&gt; segment (i.e., SYN but not ACK bit), 
            to indicate that the SEG.CC value may not be larger than the previous value.  
            Its SEG.CC value is the TCB.CCsend value from the sender's TCB.
            </para>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountNew.#ctor(System.UInt32)">
            <summary>
            Creates the option using the given connection count value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountNew.#ctor">
            <summary>
            The default connection count value is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCountNew.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Protocol">
            <summary>
            Indicates the next level IPv4 protocol used in the pyaload of the IPv4 datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpV6HopByHopOption">
            <summary>
            IPv6 Hop-by-Hop Option RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetControlMessageProtocol">
            <summary>
            Internet Control Message Protocol RFC 792   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetGroupManagementProtocol">
            <summary>
            Internet Group Management Protocol RFC 1112   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.GatewayToGateway">
            <summary>
            Gateway-to-Gateway Protocol RFC 823   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Ip">
            <summary>
            IP in IP (encapsulation) RFC 2003   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Stream">
            <summary>
            Internet Stream Protocol RFC 1190, RFC 1819   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Tcp">
            <summary>
            Transmission Control Protocol RFC 793   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Cbt">
            <summary>
            CBT   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ExteriorGatewayProtocol">
            <summary>
            Exterior Gateway Protocol RFC 888   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InteriorGatewayProtocol">
            <summary>
            Interior Gateway Protocol (any private interior gateway (used by Cisco for their IGRP))   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.BbnRccMonitoring">
            <summary>
            BBN RCC Monitoring   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.NetworkVoice">
            <summary>
            Network Voice Protocol RFC 741   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Pup">
            <summary>
            Xerox PUP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Argus">
            <summary>
            ARGUS   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Emcon">
            <summary>
            EMCON   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.CrossNetDebugger">
            <summary>
            Cross Net Debugger IEN 158   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Chaos">
            <summary>
            Chaos   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Udp">
            <summary>
            User Datagram Protocol RFC 768   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Multiplexing">
            <summary>
            Multiplexing IEN 90   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.DcnMeasurement">
            <summary>
            DCN Measurement Subsystems   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.HostMonitoringProtocol">
            <summary>
            Host Monitoring Protocol RFC 869   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.PacketRadioMeasurement">
            <summary>
            Packet Radio Measurement   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.XeroxNsInternetDatagramProtocol">
            <summary>
            XEROX NS IDP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Trunk1">
            <summary>
            Trunk-1   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Trunk2">
            <summary>
            Trunk-2   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Leaf1">
            <summary>
            Leaf-1   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Leaf2">
            <summary>
            Leaf-2   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ReliableDatagramProtocol">
            <summary>
            Reliable Datagram Protocol RFC 908   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetReliableTransactionProtocol">
            <summary>
            Internet Reliable Transaction Protocol RFC 938   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IsoTransportProtocolClass4">
            <summary>
            ISO Transport Protocol Class 4 RFC 905   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.BulkDataTransferProtocol">
            <summary>
            Bulk Data Transfer Protocol RFC 998   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MagneticFusionEnergyNetworkServicesProtocol">
            <summary>
            MFE Network Services Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MeritInternodalProtocol">
            <summary>
            MERIT Internodal Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.DatagramCongestionControlProtocol">
            <summary>
            Datagram Congestion Control Protocol RFC 4340   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ThirdPartyConnect">
            <summary>
            Third Party Connect Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InterDomainPolicyRoutingProtocol">
            <summary>
            Inter-Domain Policy Routing Protocol RFC 1479   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.XpressTransportProtocol">
            <summary>
            Xpress Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.DatagramDeliveryProtocol">
            <summary>
            Datagram Delivery Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InterDomainPolicyRoutingProtocolControlMessageTransportProtocol">
            <summary>
            IDPR Control Message Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.TransportProtocolPlusPlus">
            <summary>
            TP++ Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Il">
            <summary>
            IL Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpV6">
            <summary>
            IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SourceDemandRoutingProtocol">
            <summary>
            Source Demand Routing Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpV6Route">
            <summary>
            Routing Header for IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.FragmentHeaderForIpV6">
            <summary>
            Fragment Header for IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InterDomainRoutingProtocol">
            <summary>
            Inter-Domain Routing Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Rsvp">
            <summary>
            Resource Reservation Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Gre">
            <summary>
            Generic Routing Encapsulation   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MobileHostRoutingProtocol">
            <summary>
            Mobile Host Routing Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Bna">
            <summary>
            BNA   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Esp">
            <summary>
            Encapsulating Security Payload RFC 2406   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.AuthenticationHeader">
            <summary>
            Authentication Header RFC 2402   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IntegratedNetLayerSecurityProtocol">
            <summary>
            Integrated Net Layer Security Protocol TUBA   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Swipe">
            <summary>
            IP with Encryption   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.NArp">
            <summary>
            NBMA Address Resolution Protocol RFC 1735   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Mobile">
            <summary>
            IP Mobility (Min Encap) RFC 2004   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.TransportLayerSecurityProtocol">
            <summary>
            Transport Layer Security Protocol (using Kryptonet key management)   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Skip">
            <summary>
            Simple Key-Management for Internet Protocol RFC 2356   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetControlMessageProtocolForIpV6">
            <summary>
            ICMP for IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.NoNextHeaderForIpV6">
            <summary>
            No Next Header for IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpV6Opts">
            <summary>
            Destination Options for IPv6 RFC 2460   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.AnyHostInternal">
            <summary>
            Any host internal protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Cftp">
            <summary>
            CFTP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.AnyLocalNetwork">
            <summary>
            Any local network   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SatnetAndBackroomExpak">
            <summary>
            SATNET and Backroom EXPAK   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Kryptolan">
            <summary>
            Kryptolan   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.RemoteVirtualDiskProtocol">
            <summary>
            MIT Remote Virtual Disk Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetPluribusPacketCore">
            <summary>
            Internet Pluribus Packet Core   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.AnyDistributedFileSystem">
            <summary>
            Any distributed file system   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SatMon">
            <summary>
            SATNET Monitoring   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Visa">
            <summary>
            VISA Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetPacketCoreUtility">
            <summary>
            Internet Packet Core Utility   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ComputerProtocolNetworkExecutive">
            <summary>
            Computer Protocol Network Executive   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ComputerProtocolHeartbeat">
            <summary>
            Computer Protocol Heart Beat   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.WangSpanNetwork">
            <summary>
            Wang Span Network   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.PacketVideoProtocol">
            <summary>
            Packet Video Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.BackroomSatMon">
            <summary>
            Backroom SATNET Monitoring   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SunNd">
            <summary>
            SUN ND PROTOCOL-Temporary   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.WidebandMonitoring">
            <summary>
            WIDEBAND Monitoring   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.WidebandExpak">
            <summary>
            WIDEBAND EXPAK   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IsoIp">
            <summary>
            International Organization for Standardization Internet Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.VersatileMessageTransactionProtocol">
            <summary>
            Versatile Message Transaction Protocol RFC 1045   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SecureVersatileMessageTransactionProtocol">
            <summary>
            Secure Versatile Message Transaction Protocol RFC 1045   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Vines">
            <summary>
            VINES   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Ttp">
            <summary>
            TTP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.NationalScienceFoundationNetworkInteriorGatewayProtocol">
            <summary>
            NSFNET-IGP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.DissimilarGatewayProtocol">
            <summary>
            Dissimilar Gateway Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Tcf">
            <summary>
            TCF   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.EnhancedInteriorGatewayRoutingProtocol">
            <summary>
            Enhanced Interior Gateway Routing Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.OpenShortestPathFirst">
            <summary>
            Open Shortest Path First RFC 1583   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SpriteRpc">
            <summary>
            Sprite RPC Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.LArp">
            <summary>
            Locus Address Resolution Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MulticastTransportProtocol">
            <summary>
            Multicast Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Ax25">
            <summary>
            AX.25   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpIp">
            <summary>
            IP-within-IP Encapsulation Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MobileInternetworkingControlProtocol">
            <summary>
            Mobile Internetworking Control Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SemaphoreCommunicationsSecondProtocol">
            <summary>
            Semaphore Communications Sec. Pro   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.EtherIp">
            <summary>
            Ethernet-within-IP Encapsulation RFC 3378   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.EncapsulationHeader">
            <summary>
            Encapsulation Header RFC 1241   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.AnyPrivateEncryptionScheme">
            <summary>
            Any private encryption scheme   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Gmtp">
            <summary>
            GMTP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpsilonFlowManagementProtocol">
            <summary>
            Ipsilon Flow Management Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.PrivateNetworkToNetworkInterface">
            <summary>
            PNNI over IP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Pin">
            <summary>
            Protocol Independent Multicast   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Aris">
            <summary>
            ARIS   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SpaceCommunicationsProtocolStandards">
            <summary>
            SCPS (Space Communications Protocol Standards)   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Qnx">
            <summary>
            QNX   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ActiveNetworks">
            <summary>
            Active Networks   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IpComp">
            <summary>
            IP Payload Compression Protocol RFC 3173   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SitaraNetworksProtocol">
            <summary>
            Sitara Networks Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.CompaqPeer">
            <summary>
            Compaq Peer Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InternetworkPacketExchangeInIp">
            <summary>
            IPX in IP   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.VirtualRouterRedundancyProtocol">
            <summary>
            Virtual Router Redundancy Protocol, Common Address Redundancy Protocol (not IANA assigned) VRRP:RFC 3768   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.PragmaticGeneralMulticastTransportProtocol">
            <summary>
            PGM Reliable Transport Protocol RFC 3208   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Any0HopProtocol">
            <summary>
            Any 0-hop protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.LayerTwoTunnelingProtocol">
            <summary>
            Layer Two Tunneling Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.DiiDataExchange">
            <summary>
            D-II Data Exchange (DDX)   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.InteractiveAgentTransferProtocol">
            <summary>
            Interactive Agent Transfer Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ScheduleTransferProtocol">
            <summary>
            Schedule Transfer Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SpectraLinkRadioProtocol">
            <summary>
            SpectraLink Radio Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Uti">
            <summary>
            UTI   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SimpleMessageProtocol">
            <summary>
            Simple Message Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Sm">
            <summary>
            SM   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.PerformanceTransparencyProtocol">
            <summary>
            Performance Transparency Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.IsIsOverIpV4">
            <summary>
            IS-IS over IPv4   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Fire">
            <summary>
              
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.CombatRadioTransportProtocol">
            <summary>
            Combat Radio Transport Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.CombatRadioUserDatagram">
            <summary>
            Combat Radio User Datagram   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.ServiceSpecificConnectionOrientedProtocolInAMultilinkAndConnectionlessEnvironment">
            <summary>
              
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Iplt">
            <summary>
              
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.SecurePacketShield">
            <summary>
            Secure Packet Shield   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Pipe">
            <summary>
            Private IP Encapsulation within IP Expired I-D draft-petri-mobileip-pipe-00.txt   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.StreamControlTransmissionProtocol">
            <summary>
            Stream Control Transmission Protocol   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.FibreChannel">
            <summary>
            Fibre Channel   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.RsvpE2EIgnore">
            <summary>
            RSVP-E2E-IGNORE RFC 3175   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MobilityHeader">
            <summary>
            Mobility Header RFC 3775   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.UdpLite">
            <summary>
            UDP Lite RFC 3828   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MultiprotocolLabelSwitchingInIp">
            <summary>
            MPLS-in-IP RFC 4023   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.MobileAdHocNetwork">
            <summary>
            MANET Protocols I-D draft-ietf-manet-iana-07.txt   
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Protocol.Hip">
            <summary>
            Host Identity Protocol RFC 5201   
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Datagram">
            <summary>
            Represents an IPv4 datagram.
            
            <pre>
            +-----+---------+-----+-----------------+-------+-----------------+
            | Bit | 0-3     | 4-7 | 8-15            | 16-18 | 19-31           |
            +-----+---------+-----+-----------------+-------+-----------------+
            | 0   | Version | IHL | Type of Service | Total Length            |
            +-----+---------+-----+-----------------+-------+-----------------+
            | 32  | Identification                  | Flags | Fragment Offset |
            +-----+---------------+-----------------+-------+-----------------+
            | 64  | Time to Live  | Protocol        | Header Checksum         |
            +-----+---------------+-----------------+-------------------------+
            | 96  | Source Address                                            |
            +-----+-----------------------------------------------------------+
            | 128 | Destination Address                                       |
            +-----+-----------------------------------------------------------+
            | 160 | Options with padding                                      |
            +-----+-----------------------------------------------------------+
            | 160 | Data                                                      |
            | to  |                                                           |
            | 360 |                                                           |
            +-----+-----------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Datagram.HeaderMinimumLength">
            <summary>
            The minimum length of the header in bytes.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Datagram.HeaderMaximumLength">
            <summary>
            The maximum length of the header in bytes.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4Datagram.DefaultVersion">
            <summary>
            The version (4).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Datagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Datagram.CalculateIsValid">
            <summary>
            An IPv4 datagram is valid if its length is big enough for the header, the header checksum is correct and the payload is valid.
            </summary>
            <returns></returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Version">
            <summary>
            The header length in bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.HeaderLength">
            <summary>
            The header length in bytes.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.RealHeaderLength">
            <summary>
            The real number of bytes in the header (different than HeaderLength when the datagram is too small).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.TypeOfService">
            <summary>
            Type of Service field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.TotalLength">
            <summary>
            The length of the entire datagram as stated in the total length field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Identification">
            <summary>
            The value of the IPv4 ID field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Fragmentation">
            <summary>
            The fragmentation information field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Ttl">
            <summary>
            The TTL field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Protocol">
            <summary>
            The IPv4 (next) protocol field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.HeaderChecksum">
            <summary>
            The header checksum value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.IsHeaderChecksumCorrect">
            <summary>
            True iff the header checksum value is correct according to the header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Source">
            <summary>
            The source address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Destination">
            <summary>
            The destination address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Options">
            <summary>
            The options field with all the parsed options if any exist.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.IsTransportChecksumCorrect">
            <summary>
            Returns whether the TCP or UDP checksum is correct.
            The protocol must be TCP or UDP.
            For UDP, the checksum is optional, so 0 checksum is still correct.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Payload">
            <summary>
            The payload of the datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.IpV4">
            <summary>
            The payload of the datagram as an IPv4 datagram (IP over IP).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Icmp">
            <summary>
            The payload of the datagram as an ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Igmp">
            <summary>
            The payload of the datagram as an IGMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Tcp">
            <summary>
            The payload of the datagram as a TCP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Gre">
            <summary>
            The payload of the datagram as a GRE datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Udp">
            <summary>
            The payload of the datagram as a UDP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Datagram.Transport">
            <summary>
            Returns the Tranposrt Datagram.
            This is either a TCP Datagram or a UDP Datagram (according to the protocol).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpQueryVersion">
            <summary>
            The version of the IGMP query message.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpQueryVersion.None">
            <summary>
            No query version - not a query.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpQueryVersion.Version1">
            <summary>
            Version 1 query - RFC1112.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpQueryVersion.Version2">
            <summary>
            Version 2 query - RFC2236.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpQueryVersion.Version3">
            <summary>
            Version 3 query - RFC3376.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpQueryVersion.Unknown">
            <summary>
            The version of the query could not be interpreted.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram">
            <summary>
            RFC 1475.
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | pointer to problem area |
            +-----+-------------------------+
            | 64  | copy of datagram that   |
            |     | could not be converted  |
            |     | ...                     |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.OriginalDatagramLengthForUnsupportedTransportProtocol">
            <summary>
            The number of bytes that should be taken from the original datagram for an unsupported transport protocol ICMP code.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct, the code is in the expected range
            and the IPv4 payload contains at least an IPv4 header and the transport header.
            If the code is for unsupported transport protocol, the IPv4 payload should contain 256 bytes of the original datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.Pointer">
            <summary>
            An offset from the start of the original datagram to the beginning of the offending field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTimeExceededDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | unused                  |
            +-----+-------------------------+
            | 64  | Internet Header         |
            |     | + 64 bits of            |
            |     | Original Data Datagram  |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTimeExceededDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimeExceededDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTimeExceededDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer">
            <summary>
            RFC 1475.
            Represents a Conversion Failed ICMP layer.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpConversionFailedDatagram"/>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer.Pointer">
            <summary>
            An offset from the start of the original datagram to the beginning of the offending field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpConversionFailedLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpField">
            <summary>
            An HTTP field with a name and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.CreateField(System.String,System.Byte[])">
            <summary>
            Creates a field according to the field name and value.
            </summary>
            <param name="fieldName">The name of the field to create.</param>
            <param name="fieldValue">The bytes value of the field to create.</param>
            <returns>The constructed HTTP field.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.CreateField(System.String,System.String,System.Text.Encoding)">
            <summary>
            Creates a field according to the field name and encoded string value.
            </summary>
            <param name="fieldName">The name of the field to create.</param>
            <param name="fieldValue">The value of the field to create encoded in the given encoding.</param>
            <param name="fieldValueEncoding">The encoding that encodes the given field value.</param>
            <returns>The constructed HTTP field.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.CreateField(System.String,System.String)">
            <summary>
            Creates a field according to the field name and encoded string value.
            </summary>
            <param name="fieldName">The name of the field to create.</param>
            <param name="fieldValue">The value of the field to create encoded in ISO-8859-1 encoding.</param>
            <returns>The constructed HTTP field.</returns>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.Equals(PcapDotNet.Packets.Http.HttpField)">
            <summary>
            True iff the two HTTP fields are of equal value.
            Two fields are equal iff they have the same name (case insensitive) and the same bytes value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.Equals(System.Object)">
            <summary>
            True iff the two HTTP fields are of equal value.
            Two fields are equal iff they have the same name (case insensitive) and the same bytes value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.GetHashCode">
            <summary>
            Returns a hash code of this field according to the name and value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpField.ToString">
            <summary>
            A string representing the field similar to how it would like in the HTTP protocol.
            </summary>
            <returns></returns>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpField.Name">
            <summary>
            The name of the field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpField.Value">
            <summary>
            The Value of the field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpField.ValueString">
            <summary>
            The Value of the field as a string using ISO-8859-1 encoding.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpField.Length">
            <summary>
            The number of bytes the field will take in the HTTP protocol.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpContentTypeField">
            <summary>
            RFC 2616.
            The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method,
            the media type that would have been sent had the request been a GET.
            
            <pre>
            Content-Type   = "Content-Type" ":" media-type
            </pre>
            
            An example of the field is
            <pre>
            Content-Type: text/html; charset=ISO-8859-4
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpContentTypeField.FieldName">
            <summary>
            The field name.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpContentTypeField.FieldNameUpper">
            <summary>
            The field name in uppercase.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpContentTypeField.#ctor(System.String,System.String,PcapDotNet.Packets.Http.HttpFieldParameters)">
            <summary>
            Creates a Content Type Field according to the given media type, media subtype and parameters.
            </summary>
            <param name="mediaType">The main type of the content of this HTTP message.</param>
            <param name="mediaSubtype">The subtype of the content of this HTTP message.</param>
            <param name="parameters">Parameters on the specific type.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpContentTypeField.Equals(PcapDotNet.Packets.Http.HttpContentTypeField)">
            <summary>
            True iff the two fields are equal.
            Two content type fields are equal if they have the same media type and subtype and same parameters.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpContentTypeField.Equals(PcapDotNet.Packets.Http.HttpField)">
            <summary>
            True iff the two fields are equal.
            Two content type fields are equal if they have the same media type and subtype and same parameters.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpContentTypeField.MediaType">
            <summary>
            The main type of the content of this HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpContentTypeField.MediaSubtype">
            <summary>
            The subtype of the content of this HTTP message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpContentTypeField.Parameters">
            <summary>
            Parameters on the specific type.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Arp.ArpOperation">
            <summary>
            Specifies the operation the ARP sender is performing.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.None">
            <summary>
            Invalid operation.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.Request">
            <summary>
            [RFC826][RFC5227]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.Reply">
            <summary>
            [RFC826][RFC5227]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.ReverseRequest">
            <summary>
            [RFC903]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.ReverseReply">
            <summary>
            [RFC903]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.DynamicReverseRequest">
            <summary>
            [RFC1931]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.DynamicReverseReply">
            <summary>
            [RFC1931]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.DynamicReverseError">
            <summary>
            [RFC1931]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.InverseRequest">
            <summary>
            [RFC1293]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.InverseReply">
            <summary>
            [RFC1293]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.NegativeAtmReply">
            <summary>
            [RFC1577]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.MultipleAccessOverSynchronousOpticalNetworkingOrSynchronousDigitalHierarchyUnsolicitedArp">
            <summary>
            [RFC2176]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.Experimental1">
            <summary>
            [RFC5494]
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpOperation.Experimental2">
            <summary>
            [RFC5494]
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionEchoReply">
            <summary>
            TCP Echo Reply Option:
            <pre>
            +--------+--------+--------+--------+--------+--------+
            | Kind=7 | Length |    4 bytes of echoed info         |
            +--------+--------+--------+--------+--------+--------+
            </pre>
            
            <para>
            A TCP that receives a TCP Echo option containing four information bytes will return these same bytes in a TCP Echo Reply option.
            </para>
            
            <para>
            This TCP Echo Reply option must be returned in the next segment (e.g., an ACK segment) that is sent.
            If more than one Echo option is received before a reply segment is sent, the TCP must choose only one of the options to echo, 
            ignoring the others; specifically, it must choose the newest segment with the oldest sequence number.
            </para>
            
            <para>
            To use the TCP Echo and Echo Reply options, a TCP must send a TCP Echo option in its own SYN segment 
            and receive a TCP Echo option in a SYN segment from the other TCP.  
            A TCP that does not implement the TCP Echo or Echo Reply options must simply ignore any TCP Echo options it receives.  
            However, a TCP should not receive one of these options in a non-SYN segment unless it included a TCP Echo option in its own SYN segment.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionEchoReply.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionEchoReply.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.#ctor(System.UInt32)">
            <summary>
            Creates the option using the given echo info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.#ctor">
            <summary>
            The default echo info is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.Equals(PcapDotNet.Packets.Transport.TcpOptionEchoReply)">
            <summary>
            Two echo reply options are equal if they have the same info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two echo reply options are equal if they have the same info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.GetHashCode">
            <summary>
            The hash code of the echo reply option is the hash code of the option type xored with the hash code of the info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEchoReply.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEchoReply.Info">
            <summary>
            The echoed info.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEchoReply.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEchoReply.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionEcho">
            <summary>
            TCP Echo Option:
            <pre>
            +--------+--------+--------+--------+--------+--------+
            | Kind=6 | Length |   4 bytes of info to be echoed    |
            +--------+--------+--------+--------+--------+--------+
            </pre>
            
            <para>
            This option carries four bytes of information that the receiving TCP may send back in a subsequent TCP Echo Reply option.  
            A TCP may send the TCP Echo option in any segment, but only if a TCP Echo option was received in a SYN segment for the connection.
            </para>
            
            <para>
            When the TCP echo option is used for RTT measurement, it will be included in data segments, 
            and the four information bytes will define the time at which the data segment was transmitted in any format convenient to the sender.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionEcho.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionEcho.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.#ctor(System.UInt32)">
            <summary>
            Creates the option using the given echo info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.#ctor">
            <summary>
            The default info is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.Equals(PcapDotNet.Packets.Transport.TcpOptionEcho)">
            <summary>
            Two echo options are equal if they have the same info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two echo options are equal if they have the same info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.GetHashCode">
            <summary>
            The hash code of the echo option is the hash code of the option type xored with the hash code info.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionEcho.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEcho.Info">
            <summary>
            The info value of the option to be echoed.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEcho.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionEcho.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData">
            <summary>
            TCP Alternate Checksum Data Option (RFC 1146).
            
            <para>
            The format of the TCP Alternate Checksum Data Option is:
            <pre>
            +---------+---------+---------+     +---------+
            | Kind=15 |Length=N |  data   | ... |  data   |
            +---------+---------+---------+     +---------+
            </pre>
            </para>
            
            <para>
            This field is used only when the alternate checksum that is negotiated is longer than 16 bits. 
            These checksums will not fit in the checksum field of the TCP header and thus at least part of them must be put in an option.  
            Whether the checksum is split between the checksum field in the TCP header and the option or the entire checksum is placed in the option 
            is determined on a checksum by checksum basis.
            </para>
            
            <para>
            The length of this option will depend on the choice of alternate checksum algorithm for this connection.
            </para>
            
            <para>
            While computing the alternate checksum, the TCP checksum field and the data portion TCP Alternate Checksum Data Option are replaced with zeros.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.#ctor(System.Collections.Generic.IList{System.Byte})">
            <summary>
            Creates the option using the given data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.#ctor">
            <summary>
            the default option data is no data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.Equals(PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData)">
            <summary>
            Two alternate checksum data options are equal if they have the same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two alternate checksum data options are equal if they have the same data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.GetHashCode">
            <summary>
            The hash code of this option is the hash code of the option type xored with the hash code of the data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.Data">
            <summary>
            The alternate checksum data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionAlternateChecksumData.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpControlBits">
            <summary>
            TCP control bits format
            <pre>
            +-----+-----+----+-----+-----+-----+-----+-----+-----+-----+-----+
            | Bit | 0-6 | 7  | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |
            +-----+-----+----+-----+-----+-----+-----+-----+-----+-----+-----+
            | 0   |     | NS | CWR | ECE | URG | ACK | PSH | RST | SYN | FIN |
            +-----+-----+----+-----+-----+-----+-----+-----+-----+-----+-----+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.None">
            <summary>
            No control bits are turned on.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Fin">
            <summary>
            No more data from sender.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Synchronize">
            <summary>
            Synchronize sequence numbers.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Reset">
            <summary>
            Reset the connection.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Push">
            <summary>
            Push Function.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Acknowledgment">
            <summary>
            Acknowledgment field significant.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.Urgent">
            <summary>
            Urgent Pointer field significant.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.ExplicitCongestionNotificationEcho">
            <summary>
            RFC 3168.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.CongestionWindowReduced">
            <summary>
            RFC 3168.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpControlBits.NonceSum">
            <summary>
            RFC 3540.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress">
            <summary>
            A pair of address and its time in the day.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.#ctor(PcapDotNet.Packets.IpV4.IpV4Address,PcapDotNet.Packets.IpV4.IpV4TimeOfDay)">
            <summary>
            Create a timed address accroding to the given values.
            </summary>
            <param name="address">The address in the pair.</param>
            <param name="timeOfDay">The time passed since midnight UT.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.Equals(PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress)">
            <summary>
            Two options are equal if they have the same address and time passed since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.Equals(System.Object)">
            <summary>
            Two options are equal if they have the same address and time passed since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.op_Equality(PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress,PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress)">
            <summary>
            Two options are equal if they have the same address and time passed since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.op_Inequality(PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress,PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress)">
            <summary>
            Two options are different if they have different addresses or time passed since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.GetHashCode">
            <summary>
            Returns the xor of the address hash code and the time in the day hash code.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.Address">
            <summary>
            The address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionTimedAddress.TimeOfDay">
            <summary>
            The time passed since midnight UT.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4Fragmentation">
            <summary>
            Represents IPv4 Fragmentation information.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.#ctor(PcapDotNet.Packets.IpV4.IpV4FragmentationOptions,System.UInt16)">
            <summary>
            Creates fragmentation field value according to the given information.
            </summary>
            <param name="options">Options for fragmentation (must be one of the values of the enum).</param>
            <param name="offset">This field indicates where in the complete datagram this fragment belongs. Measured in bytes but must divide by 8.</param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.Equals(PcapDotNet.Packets.IpV4.IpV4Fragmentation)">
            <summary>
            Two framentations are equal if they are exactly the same fragmentation (options and offset).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.Equals(System.Object)">
            <summary>
            Two framentations are equal if they are exactly the same fragmentation (options and offset).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.op_Equality(PcapDotNet.Packets.IpV4.IpV4Fragmentation,PcapDotNet.Packets.IpV4.IpV4Fragmentation)">
            <summary>
            Two framentations are equal if they are exactly the same fragmentation (options and offset).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.op_Inequality(PcapDotNet.Packets.IpV4.IpV4Fragmentation,PcapDotNet.Packets.IpV4.IpV4Fragmentation)">
            <summary>
            Two framentations are different if they are different fragmentation (options or offset).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4Fragmentation.GetHashCode">
            <summary>
            The hash code of the fragmentation is the hash code of its combined flags and offset 16 bit field.
            </summary>
            <returns></returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Fragmentation.None">
            <summary>
            No fragmentation.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Fragmentation.Options">
            <summary>
            Options for fragmentation.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4Fragmentation.Offset">
            <summary>
            This field indicates where in the complete datagram this fragment belongs. Measured in bytes but must divide by 8.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionUnknown">
            <summary>
            An unknown IPv4 option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionType,System.Collections.Generic.IList{System.Byte})">
            <summary>
            Creates an unknown IPv4 option by the given type and data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.#ctor">
            <summary>
            The default unknown option is with type 255 and no data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.Equals(PcapDotNet.Packets.IpV4.IpV4OptionUnknown)">
            <summary>
            Two unknown options are equal iff they are of equal type and equal data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two unknown options are equal iff they are of equal type and equal data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.GetHashCode">
            <summary>
            The hash code for an unknown option is the hash code for the option type xored with the hash code of the data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.CreateInstance(PcapDotNet.Packets.IpV4.IpV4OptionType,System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Creates an unknown option from its type and by reading a buffer for its value.
            </summary>
            <param name="optionType">The type of the unknown option.</param>
            <param name="buffer">The buffer of bytes to read the value of the unknown option.</param>
            <param name="offset">The offset in the buffer to start reading the bytes.</param>
            <param name="valueLength">The number of bytes to read from the buffer.</param>
            <returns>An option created from the given type and buffer.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.Data">
            <summary>
            Returns the Data of the option.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionUnknown.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpGroupRecord">
            <summary>
            Represents an IGMP group record with all the relevant fields.
            Used to build an IGMP report of version 3.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.#ctor(PcapDotNet.Packets.Igmp.IgmpRecordType,PcapDotNet.Packets.IpV4.IpV4Address,System.Collections.ObjectModel.ReadOnlyCollection{PcapDotNet.Packets.IpV4.IpV4Address},PcapDotNet.Packets.Datagram)">
            <summary>
            Create the record according to all the fields.
            </summary>
            <param name="recordType">The type of group record included in the report message.</param>
            <param name="multicastAddress">The Multicast Address field contains the IP multicast address to which this Group Record pertains.</param>
            <param name="sourceAddresses">
            The Source Address [i] fields are a vector of n IP unicast addresses, 
            where n is the value in this record's Number of Sources (N) field.
            </param>
            <param name="auxiliaryData">
            The Auxiliary Data field, if present, contains additional information pertaining to this Group Record.  
            The protocol specified in this document, IGMPv3, does not define any auxiliary data.  
            Therefore, implementations of IGMPv3 MUST NOT include any auxiliary data (i.e., MUST set the Aux Data Len field to zero) in any transmitted Group Record, 
            and MUST ignore any auxiliary data present in any received Group Record.  
            The semantics and internal encoding of the Auxiliary Data field are to be defined by any future version or extension of IGMP that uses this field.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.#ctor(PcapDotNet.Packets.Igmp.IgmpRecordType,PcapDotNet.Packets.IpV4.IpV4Address,System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Address},PcapDotNet.Packets.Datagram)">
            <summary>
            Create the record according to all the fields.
            </summary>
            <param name="recordType">The type of group record included in the report message.</param>
            <param name="multicastAddress">The Multicast Address field contains the IP multicast address to which this Group Record pertains.</param>
            <param name="sourceAddresses">
            The Source Address [i] fields are a vector of n IP unicast addresses, 
            where n is the value in this record's Number of Sources (N) field.
            </param>
            <param name="auxiliaryData">
            The Auxiliary Data field, if present, contains additional information pertaining to this Group Record.  
            The protocol specified in this document, IGMPv3, does not define any auxiliary data.  
            Therefore, implementations of IGMPv3 MUST NOT include any auxiliary data (i.e., MUST set the Aux Data Len field to zero) in any transmitted Group Record, 
            and MUST ignore any auxiliary data present in any received Group Record.  
            The semantics and internal encoding of the Auxiliary Data field are to be defined by any future version or extension of IGMP that uses this field.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.ToString">
            <summary>
            A string containing the record type, multicast address, source addresses and the number of bytes in teh auxiliary data.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.Equals(PcapDotNet.Packets.Igmp.IgmpGroupRecord)">
            <summary>
            Two records are equal if the record type, multicast address, source addresses and auxiliary data are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.Equals(System.Object)">
            <summary>
            Two records are equal if the record type, multicast address, source addresses and auxiliary data are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecord.GetHashCode">
            <summary>
            The hash code of a record is the xor of the hash code of the record type, multicast address, source addresses and auxiliary data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecord.RecordType">
            <summary>
            The type of group record included in the report message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecord.MulticastAddress">
            <summary>
            The Multicast Address field contains the IP multicast address to which this Group Record pertains.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecord.SourceAddresses">
            <summary>
            The Source Address [i] fields are a vector of n IP unicast addresses, 
            where n is the value in this record's Number of Sources (N) field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecord.AuxiliaryData">
            <summary>
            The Auxiliary Data field, if present, contains additional information pertaining to this Group Record.  
            The protocol specified in this document, IGMPv3, does not define any auxiliary data.  
            Therefore, implementations of IGMPv3 MUST NOT include any auxiliary data (i.e., MUST set the Aux Data Len field to zero) in any transmitted Group Record, 
            and MUST ignore any auxiliary data present in any received Group Record.  
            The semantics and internal encoding of the Auxiliary Data field are to be defined by any future version or extension of IGMP that uses this field.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreLayer">
            <summary>
            Represents a GRE layer.
            <seealso cref="T:PcapDotNet.Packets.Gre.GreDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreLayer.SetKey(System.UInt16,System.UInt16)">
            <summary>
            Sets the key according to the payload length and call id.
            </summary>
            <param name="keyPayloadLength">(High 2 octets of Key) Size of the payload, not including the GRE header.</param>
            <param name="keyCallId">(Low 2 octets of Key) Contains the Peer's Call ID for the session to which this packet belongs.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreLayer.Finalize(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer)">
            <summary>
            Finalizes the layer data in the buffer.
            Used for fields that must be calculated according to the layer's payload (like checksum).
            </summary>
            <param name="buffer">The buffer to finalize the layer in.</param>
            <param name="offset">The offset in the buffer the layer starts.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreLayer.Equals(PcapDotNet.Packets.Gre.GreLayer)">
            <summary>
            True iff the two objects are equal Layers.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            True iff the two objects are equal Layers.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.Version">
            <summary>
            The GRE Version Number.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.ProtocolType">
            <summary>
            The Protocol Type field contains the protocol type of the payload packet. 
            These Protocol Types are defined in [RFC1700] as "ETHER TYPES" and in [ETYPES]. 
            An implementation receiving a packet containing a Protocol Type which is not listed in [RFC1700] or [ETYPES] SHOULD discard the packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.RecursionControl">
            <summary>
            Recursion control contains a three bit unsigned integer which contains the number of additional encapsulations which are permissible.  
            This SHOULD default to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.FutureUseBits">
            <summary>
            Must be set to zero (0).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.ChecksumPresent">
            <summary>
            If the Checksum Present bit is set to 1, then the Checksum field is present and contains valid information.
            If either the Checksum Present bit or the Routing Present bit are set, BOTH the Checksum and Offset fields are present in the GRE packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.Checksum">
            <summary>
            The Checksum field contains the IP (one's complement) checksum sum of the all the 16 bit words in the GRE header and the payload packet.
            For purposes of computing the checksum, the value of the checksum field is zero. 
            This field is present only if the Checksum Present bit is set to one.
            In order to calculate the Checksum automatically, leave null in this field and set the ChecksumPresent field to true.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.Key">
            <summary>
            The Key field contains a four octet number which was inserted by the encapsulator.  
            It may be used by the receiver to authenticate the source of the packet.  
            The Key field is only present if the Key Present field is set to 1.
            null iff the Key isn't present.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.KeyPayloadLength">
            <summary>
            (High 2 octets of Key) Size of the payload, not including the GRE header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.KeyCallId">
            <summary>
            (Low 2 octets of Key) Contains the Peer's Call ID for the session to which this packet belongs.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.SequenceNumber">
            <summary>
            The Sequence Number field contains an unsigned 32 bit integer which is inserted by the encapsulator.  
            It may be used by the receiver to establish the order in which packets have been transmitted from the encapsulator to the receiver.  
            null off the sequence number present bit is 0.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.AcknowledgmentSequenceNumber">
            <summary>
            Contains the sequence number of the highest numbered GRE packet received by the sending peer for this user session.
            Present if A bit (Bit 8) is one (1).
            null iff not present.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.RoutingOffset">
            <summary>
            The offset field indicates the octet offset from the start of the Routing field to the first octet of the active Source Route Entry to be examined.  
            This field is present if the Routing Present or the Checksum Present bit is set to 1, and contains valid information only if the Routing Present bit is set to 1.
            Should be null iff the Routing is null (routing is not present).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.Routing">
            <summary>
            The Routing field is optional and is present only if the Routing Present bit is set to 1.
            The Routing field is a list of Source Route Entries (SREs). 
            null iff the routing isn't present.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.StrictSourceRoute">
            <summary>
            If the source route is incomplete, then the Strict Source Route bit is checked.  
            If the source route is a strict source route and the next IP destination or autonomous system is NOT an adjacent system, the packet MUST be dropped.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreLayer.PreviousLayerProtocol">
            <summary>
            The protocol that should be written in the previous (IPv4) layer.
            This is GRE.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Arp.ArpHardwareType">
            <summary>
            The data link layer protocol of the ARP protocol.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.None">
            <summary>
            Invalid hardware type
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Ethernet">
            <summary>
            Ethernet (10Mb)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.ExperimentalEthernet">
            <summary>
            Experimental Ethernet (3Mb)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AmateurRadioAx25">
            <summary>
            Amateur Radio AX.25
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.ProteonProNetTokenRing">
            <summary>
            Proteon ProNET Token Ring
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Chaos">
            <summary>
            Chaos
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Ieee802Networks">
            <summary>
            IEEE 802 Networks
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AttachedResourceComputerNetwork">
            <summary>
            ARCNET
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.HyperChannel">
            <summary>
            Hyperchannel
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.LanStar">
            <summary>
            Lanstar
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AutonetShortAddress">
            <summary>
            Autonet Short Address
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.LocalTalk">
            <summary>
            LocalTalk
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.LocalNet">
            <summary>
            LocalNet (IBM PCNet or SYTEK LocalNET)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.UltraLink">
            <summary>
            Ultra link
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.SwitchedMultimegabitDataService">
            <summary>
            SMDS
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.FrameRelay">
            <summary>
            Frame Relay
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AsynchronousTransmissionMode16">
            <summary>
            Asynchronous Transmission Mode (ATM)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.HighLevelDataLinkControl">
            <summary>
            HDLC
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.FibreChannel">
            <summary>
            Fibre Channel
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AsynchronousTransmissionMode19">
            <summary>
            Asynchronous Transmission Mode (ATM)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.SerialLine">
            <summary>
            Serial Line
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.AsynchronousTransmissionMode21">
            <summary>
            Asynchronous Transmission Mode (ATM)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.MilStd188Hyphen220">
            <summary>
            MIL-STD-188-220
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Metricom">
            <summary>
            Metricom
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Ieee1394Dot1995">
            <summary>
            IEEE 1394.1995
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.MultipleAccessOverSynchronousOpticalNetworkingOrSynchronousDigitalHierarchy">
            <summary>
            MAPOS
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Twinaxial">
            <summary>
            Twinaxial
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.ExtendedUniqueIdentifier64">
            <summary>
            EUI-64
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Hiparp">
            <summary>
            HIPARP
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.IpAndArpOverIso7816Hyphen3">
            <summary>
            IP and ARP over ISO 7816-3
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.ArpSec">
            <summary>
            ARPSec
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.IpSecTunnel">
            <summary>
            IPsec tunnel
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.InfiniBand">
            <summary>
            InfiniBand (TM)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Tia102Project25CommonAirInterface">
            <summary>
            TIA-102 Project 25 Common Air Interface (CAI)
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.WiegandInterface">
            <summary>
            Wiegand Interface
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.PureIp">
            <summary>
            Pure IP
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Experimental1">
            <summary>
            HW_EXP1
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpHardwareType.Experimental2">
            <summary>
            HW_EXP2
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize">
            <summary>
            Maximum Segment Size (RFC 793)
            <pre>
            +--------+--------+---------+--------+
            |00000010|00000100|   max seg size   |
            +--------+--------+---------+--------+
             Kind=2   Length=4
            </pre>
            
            <para>
            If this option is present, then it communicates the maximum receive segment size at the TCP which sends this segment.
            This field must only be sent in the initial connection request (i.e., in segments with the SYN control bit set).  
            If this option is not used, any segment size is allowed.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.#ctor(System.UInt16)">
            <summary>
            Creates the option using the given maximum segment size.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.#ctor">
            <summary>
            The default maximum segment size is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.Equals(PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize)">
            <summary>
            Two maximum segment size options are equal if they have the same maximum segment size.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two maximum segment size options are equal if they have the same maximum segment size.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.GetHashCode">
            <summary>
            The hash code of the option is the hash code of the option type xored with the hash code of the maximum segment size.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.MaximumSegmentSize">
            <summary>
            The maximum segment size value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionMaximumSegmentSize.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier">
            <summary>
            Stream Identifier option.
            <pre>
            +--------+--------+--------+--------+
            |10001000|00000010|    Stream ID    |
            +--------+--------+--------+--------+
             Type=136 Length=4
            </pre>
            
            This option provides a way for the 16-bit SATNET stream identifier to be carried through networks that do not support the stream concept.
            
            Must be copied on fragmentation.  
            Appears at most once in a datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.#ctor(System.UInt16)">
            <summary>
            Create the option according to the given identifier.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.#ctor">
            <summary>
            Creates a 0 stream identifier
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.Equals(PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier)">
            <summary>
            Two stream identifier options are equal if they have the same identifier.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two stream identifier options are equal if they have the same identifier.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.GetHashCode">
            <summary>
            The hash code value is the xor of the base class hash code and the identifier hash code.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.Identifier">
            <summary>
            The identifier of the stream.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionStreamIdentifier.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity">
             <summary>
             This option identifies the U.S. classification level at which the datagram is to be protected 
             and the authorities whose protection rules apply to each datagram.
             
             <para>
               This option is used by end systems and intermediate systems of an internet to:
               <list type="number">
                 <item>Transmit from source to destination in a network standard representation the common security labels required by computer security models.</item>
                 <item>Validate the datagram as appropriate for transmission from the source and delivery to the destination.</item>
                 <item>
                   Ensure that the route taken by the datagram is protected to the level required by all protection authorities indicated on the datagram.
                   In order to provide this facility in a general Internet environment, interior and exterior gateway protocols must be augmented 
                   to include security label information in support of routing control.
                 </item>
               </list>
             </para>
            
             <para>
               The DoD Basic Security option must be copied on fragmentation.  
               This option appears at most once in a datagram.  
               Some security systems require this to be the first option if more than one option is carried in the IP header, 
               but this is not a generic requirement levied by this specification.
             </para>
             
             <para>
               The format of the DoD Basic Security option is as follows:
               <pre>
             +------------+------------+------------+-------------//----------+
             |  10000010  |  XXXXXXXX  |  SSSSSSSS  |  AAAAAAA[1]    AAAAAAA0 |
             |            |            |            |         [0]             |
             +------------+------------+------------+-------------//----------+
               TYPE = 130     LENGTH   CLASSIFICATION         PROTECTION
                                            LEVEL              AUTHORITY
                                                                 FLAGS
               </pre>
             </para>
             </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.OptionMinimumLength">
            <summary>
            The minimum number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.OptionValueMinimumLength">
            <summary>
            The minimum number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel,PcapDotNet.Packets.IpV4.IpV4OptionSecurityProtectionAuthorities,System.Byte)">
            <summary>
            Create the security option from the different security field values.
            </summary>
            <param name="classificationLevel">
            This field specifies the (U.S.) classification level at which the datagram must be protected.  
            The information in the datagram must be protected at this level.  
            </param>
            <param name="protectionAuthorities">
            This field identifies the National Access Programs or Special Access Programs 
            which specify protection rules for transmission and processing of the information contained in the datagram. 
            </param>
            <param name="length">
            The number of bytes this option will take.
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.#ctor(PcapDotNet.Packets.IpV4.IpV4OptionSecurityClassificationLevel)">
            <summary>
            Create the security option with only classification level.
            </summary>
            <param name="classificationLevel">
            This field specifies the (U.S.) classification level at which the datagram must be protected.  
            The information in the datagram must be protected at this level.  
            </param>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.#ctor">
            <summary>
            Creates unclassified security option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.Equals(PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity)">
            <summary>
            Two security options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two security options are equal iff they have the exact same field values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.GetHashCode">
            <summary>
            The hash code is the xor of the base class hash code 
            with the hash code of the combination of the classification level, protection authority and length.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.ClassificationLevel">
            <summary>
            This field specifies the (U.S.) classification level at which the datagram must be protected.  
            The information in the datagram must be protected at this level.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.ProtectionAuthorities">
            <summary>
            This field identifies the National Access Programs or Special Access Programs 
            which specify protection rules for transmission and processing of the information contained in the datagram. 
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionBasicSecurity.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IDataLink">
            <summary>
            Represents a datalink.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IDataLink.Kind">
            <summary>
            The kind of the datalink.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpAddressMaskReplyDatagram">
            <summary>
            RFC 950.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 64  | Address Mask                  |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram">
            <summary>
            RFC 950.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            | 64  | Address Mask                  |
            +-----+-------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram.DatagramLength">
            <summary>
            The number of bytes this Datagram should take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram.PayloadLength">
            <summary>
            The number of bytes this ICMP payload should take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram.CalculateIsValid">
            <summary>
            ICMP is valid if the datagram's length is OK, the checksum is correct and the code is in the expected range.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpAddressMaskRequestDatagram.AddressMask">
            <summary>
            A 32-bit mask.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpAddressMaskReplyDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpRequestMethod">
            <summary>
            HTTP request method.
            Example: GET
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestMethod.#ctor(System.String)">
            <summary>
            Creates a method from a method string.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestMethod.#ctor(PcapDotNet.Packets.Http.HttpRequestKnownMethod)">
            <summary>
            Creates a method from a known method.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestMethod.Equals(PcapDotNet.Packets.Http.HttpRequestMethod)">
            <summary>
            Two methods are equal iff they have the same method string.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestMethod.Equals(System.Object)">
            <summary>
            Two methods are equal iff they have the same method string.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestMethod.GetHashCode">
            <summary>
            The hash code of the method string.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestMethod.Method">
            <summary>
            The method string.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestMethod.KnownMethod">
            <summary>
            Returns the known method that matches the method string.
            Returns HttpRequestKnownMethod.Unknown if no matching known method could be found.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestMethod.Length">
            <summary>
            The number of bytes this method takes.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpContentLengthField">
            <summary>
            RFC 2616.
            The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, 
            in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpContentLengthField.FieldName">
            <summary>
            The field name.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpContentLengthField.FieldNameUpper">
            <summary>
            The field name in uppercase.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpContentLengthField.#ctor(System.UInt32)">
            <summary>
            Creates a Content Length Field according to a given content length.
            </summary>
            <param name="contentLength">
            The size of the entity-body, in decimal number of OCTETs, sent to the recipient or, 
            in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.
            </param>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpContentLengthField.ContentLength">
            <summary>
            The size of the entity-body, in decimal number of OCTETs, sent to the recipient or, 
            in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Ethernet.EthernetLayer">
            <summary>
            Represents an Ethernet layer.
            <seealso cref="T:PcapDotNet.Packets.Ethernet.EthernetDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.#ctor">
            <summary>
            Creates an instance with zero values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.Write(System.Byte[],System.Int32,System.Int32,PcapDotNet.Packets.ILayer,PcapDotNet.Packets.ILayer)">
            <summary>
            Writes the layer to the buffer.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
            <param name="payloadLength">The length of the layer's payload (the number of bytes after the layer in the packet).</param>
            <param name="previousLayer">The layer that comes before this layer. null if this is the first layer.</param>
            <param name="nextLayer">The layer that comes after this layer. null if this is the last layer.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.Equals(PcapDotNet.Packets.Ethernet.EthernetLayer)">
            <summary>
            Two Ethernet layers are equal if they have the same source, destination and ethernet type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.Equals(PcapDotNet.Packets.Layer)">
            <summary>
            Two Ethernet layers are equal if they have the same source, destination and ethernet type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.GetHashCode">
            <summary>
            Returns a hash code for the layer.
            The hash code is a XOR of the hash codes of the layer length, data link, source and destination addresses and the ethernet type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Ethernet.EthernetLayer.ToString">
            <summary>
            Contains the source, destination and ether type.
            </summary>
            <returns></returns>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetLayer.Source">
            <summary>
            Ethernet source address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetLayer.Destination">
            <summary>
            Ethernet destination address.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetLayer.EtherType">
            <summary>
            Ethernet type (next protocol).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetLayer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetLayer.DataLink">
            <summary>
            The kind of the data link of the layer.
            Can be null if this is not the first layer in the packet.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Ethernet.EthernetLayer.PreviousLayerHardwareType">
            <summary>
            The ARP Hardware Type of the layer before the ARP layer.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer">
            <summary>
            RFC 3376.
            Represents an IGMP Query version 3 layer.
            <seealso cref="T:PcapDotNet.Packets.Igmp.IgmpDatagram"/>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.#ctor">
            <summary>
            Creates an instance of an IGMP Query Version 3 layer.
            Default SourceAddresses is no addresses.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.Write(System.Byte[],System.Int32)">
            <summary>
            Writes the layer to the buffer.
            This method ignores the payload length, and the previous and next layers.
            </summary>
            <param name="buffer">The buffer to write the layer to.</param>
            <param name="offset">The offset in the buffer to start writing the layer at.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.GetHashCode">
            <summary>
            Xor of the combination of the IsSuppressRouterSideProcessing and QueryRobustnessVariable fields with
            the hash codes of the layer length, datalink, message type, query version, group address and all the source addresses.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.EqualFields(PcapDotNet.Packets.Igmp.IgmpLayer)">
            <summary>
            true iff the GroupAddress, IsSuppressRouterSideProcessing, QueryRobustnessVariable and SourceAddresses fields are equal
            and the QueryInterval is similar.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.EqualFields(PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer)">
            <summary>
            true iff the GroupAddress, IsSuppressRouterSideProcessing, QueryRobustnessVariable and SourceAddresses fields are equal
            and the QueryInterval is similar.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.MaxResponseTime">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.GroupAddress">
            <summary>
            The Group Address field is set to zero when sending a General Query, 
            and set to the IP multicast address being queried when sending a Group-Specific Query or Group-and-Source-Specific Query.
            In a Membership Report of version 1 or 2 or Leave Group message, the group address field holds the IP multicast group address of the group being reported or left.
            In a Membership Report of version 3 this field is meaningless.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.IsSuppressRouterSideProcessing">
            <summary>
            When set to one, the S Flag indicates to any receiving multicast routers that they are to suppress the normal timer updates they perform upon hearing a Query.  
            It does not, however, suppress the querier election or the normal "host-side" processing of a Query 
            that a router may be required to perform as a consequence of itself being a group member.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.QueryRobustnessVariable">
            <summary>
            If non-zero, the QRV field contains the [Robustness Variable] value used by the querier, i.e., the sender of the Query.  
            If the querier's [Robustness Variable] exceeds 7, the maximum value of the QRV field, the QRV is set to zero.  
            Routers adopt the QRV value from the most recently received Query as their own [Robustness Variable] value, 
            unless that most recently received QRV was zero, in which case the receivers use the default [Robustness Variable] value or a statically configured value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.QueryInterval">
            <summary>
            The actual interval, called the Querier's Query Interval (QQI).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.SourceAddresses">
            <summary>
            The Source Address [i] fields are a vector of n IP unicast addresses,
            where n is the value in the Number of Sources (N) field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.Length">
            <summary>
            The number of bytes this layer will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.QueryVersion">
            <summary>
            The IGMP version of a Membership Query message.
            If the type is not a query, None will be returned.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion3Layer.MaxResponseTimeValue">
            <summary>
            The actual time allowed, called the Max Resp Time.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram">
            <summary>
            RFC 1393.
            <pre>
            +-----+------+-------------+------------------+
            | Bit | 0-7  | 8-15        | 16-31            |
            +-----+------+-------------+------------------+
            | 0   | Type | Code        | Checksum         |
            +-----+------+-------------+------------------+
            | 32  | ID Number          | unused           |
            +-----+--------------------+------------------+
            | 64  | Outbound Hop Count | Return Hop Count |
            +-----+--------------------+------------------+
            | 96  | Output Link Speed                     |
            +-----+---------------------------------------+
            | 128 | Output Link MTU                       |
            +-----+---------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.DatagramLength">
            <summary>
            The number of bytes this datagram should take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.PayloadLength">
            <summary>
            The number of bytes this ICMP payload should take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.OutboundReturnHopCountValue">
            <summary>
            The value the Return Hop Count should be for an outbound ICMP packet.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.CalculateIsValid">
            <summary>
            Valid if the datagram's length is OK, the checksum is correct and the code is in the expected range.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.Identification">
            <summary>
            The ID Number as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.  
            This is NOT related to the ID number in the IP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.OutboundHopCount">
            <summary>
            The Outbound Hop Count as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.ReturnHopCount">
            <summary>
            The Return Hop Count as copied from the IP Traceroute option of the packet which caused this Traceroute message to be sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.OutputLinkSpeed">
            <summary>
            The speed, in OCTETS per second, of the link over which the Outbound/Return Packet will be sent.  
            Since it will not be long before network speeds exceed 4.3Gb/s, and since some machines deal poorly with fields longer than 32 bits, octets per second was chosen over bits per second.  
            If this value cannot be determined, the field should be set to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.OutputLinkMaximumTransmissionUnit">
            <summary>
            The MTU, in bytes, of the link over which the Outbound/Return Packet will be sent.  
            MTU refers to the data portion (includes IP header; excludes datalink header/trailer) of the packet.  
            If this value cannot be determined, the field should be set to zero.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.IsOutbound">
            <summary>
            Is the packet an Outbound packet.
            This is indicated by a value of  0xFFFF in the ReturnHopCount field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.MinCodeValue">
            <summary>
            The minimum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpTraceRouteDatagram.MaxCodeValue">
            <summary>
            The maximum valid ICMP code for this type of ICMP datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRouterSolicitationDatagram">
            <summary>
            RFC 1256.
            <pre>
            +-----+------+------+-----------+
            | Bit | 0-7  | 8-15 | 16-31     |
            +-----+------+------+-----------+
            | 0   | Type | Code | Checksum  |
            +-----+------+------+-----------+
            | 32  | reserved                |
            +-----+-------------------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterSolicitationDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpTransferEncodingField">
            <summary>
            RFC 2616.
            The Transfer-Encoding general-header field indicates what (if any) type of transformation has been applied to the message body 
            in order to safely transfer it between the sender and the recipient. 
            This differs from the content-coding in that the transfer-coding is a property of the message, not of the entity.
            
            <pre>
            Transfer-Encoding       = "Transfer-Encoding" ":" 1#transfer-coding
            </pre>
            
            Example:
            
            <pre>
            Transfer-Encoding: chunked
            </pre>
            
            If multiple encodings have been applied to an entity, the transfer-codings MUST be listed in the order in which they were applied.
            Additional information about the encoding parameters MAY be provided by other entity-header fields not defined by this specification.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpTransferEncodingField.FieldName">
            <summary>
            The field name.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpTransferEncodingField.FieldNameUpper">
            <summary>
            The field name in uppercase.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpTransferEncodingField.#ctor(System.Collections.Generic.IList{System.String})">
            <summary>
            Creates an HTTP transfer encoding field from a set of transfer codings.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpTransferEncodingField.#ctor(System.String[])">
            <summary>
            Creates an HTTP transfer encoding field from a set of transfer codings.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpTransferEncodingField.Equals(PcapDotNet.Packets.Http.HttpTransferEncodingField)">
            <summary>
            True iff the two HTTP transfer encoding fields are of equal value.
            Two HTTP transfer encoding fields are equal iff they have the same transfer codings.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpTransferEncodingField.Equals(PcapDotNet.Packets.Http.HttpField)">
            <summary>
            True iff the two HTTP transfer encoding fields are of equal value.
            Two HTTP transfer encoding fields are equal iff they have the same transfer codings.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpTransferEncodingField.TransferCodings">
            <summary>
            Transfer-coding values are used to indicate an encoding transformation that has been, can be, 
            or may need to be applied to an entity-body in order to ensure "safe transport" through the network.
            This differs from a content coding in that the transfer-coding is a property of the message, not of the original entity.
            
            <pre>
            transfer-coding         = "chunked" | transfer-extension
            transfer-extension      = token *( ";" parameter )
            </pre>
            
            Parameters are in the form of attribute/value pairs.
            
            <pre>
            parameter               = attribute "=" value
            attribute               = token
            value                   = token | quoted-string
            </pre>
            
            All transfer-coding values are case-insensitive. 
            Whenever a transfer-coding is applied to a message-body, the set of transfer-codings MUST include "chunked", 
            unless the message is terminated by closing the connection. 
            When the "chunked" transfer-coding is used, it MUST be the last transfer-coding applied to the message-body. 
            The "chunked" transfer-coding MUST NOT be applied more than once to a message-body. 
            These rules allow the recipient to determine the transfer-length of the message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs">
            <summary>
            RFC 1702.
            Represents a source route entry consisting of a list of Autonomous System numbers and indicates an AS source route.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.#ctor(System.Collections.ObjectModel.ReadOnlyCollection{System.UInt16},System.Int32)">
            <summary>
            Initializes using the given AS numbers and the next as number index.
            </summary>
            <param name="asNumbers">Autonomous System numbers of the source route.</param>
            <param name="nextAsNumberIndex">The next AS number index in the source route.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.EqualsPayloads(PcapDotNet.Packets.Gre.GreSourceRouteEntry)">
            <summary>
            True iff the AS numbers are equal.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.WritePayload(System.Byte[],System.Int32)">
            <summary>
            Writes the payload to the given buffer in the given offset.
            </summary>
            <param name="buffer">The buffer to write the payload to.</param>
            <param name="offset">The offset in the buffer to start writing.</param>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.AddressFamily">
            <summary>
            The Address Family field contains a two octet value which indicates the syntax and semantics of the Routing Information field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.PayloadLength">
            <summary>
            The SRE Length field contains the number of octets in the SRE.  
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.PayloadOffset">
            <summary>
            The SRE Offset field indicates the octet offset from the start of the Routing Information field to the first octet of the active entry in Source Route Entry to be examined.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.PayloadHashCode">
            <summary>
            The xor of the hash code of the AS numbers.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.AsNumbers">
            <summary>
            Autonomous System numbers of the source route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.NextAsNumberIndex">
            <summary>
            The next AS number index in the source route.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Gre.GreSourceRouteEntryAs.NextAsNumber">
            <summary>
            The next AS number.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Arp.ArpDatagram">
            <summary>
            The following is the packet structure used for ARP requests and replies. 
            On Ethernet networks, these packets use an EtherType of 0x0806, and are sent to the broadcast MAC address of FF:FF:FF:FF:FF:FF. 
            Note that the EtherType (0x0806) is used in the Ethernet header, and should not be used as the PTYPE of the ARP packet. 
            The ARP type (0x0806) should never be used in the PTYPE field of an ARP packet, since a hardware protocol address should never be linked to the ARP protocol. 
            Note that the packet structure shown in the table has SHA and THA as 48-bit fields and SPA and TPA as 32-bit fields but this is just for convenience  
            their actual lengths are determined by the hardware &amp; protocol length fields.
            <pre>
            +-----+------------------------+------------------------+-----------------------------------------------+
            | bit | 0-7                    | 8-15                   | 16-31                                         |
            +-----+------------------------+------------------------+-----------------------------------------------+
            | 0   |	Hardware type (HTYPE)                           | Protocol type (PTYPE)                         |
            +-----+------------------------+------------------------+-----------------------------------------------+
            | 32  | Hardware length (HLEN) | Protocol length (PLEN) | Operation (OPER)                              |
            +-----+------------------------+------------------------+-----------------------------------------------+
            | 64  | Sender hardware address (SHA) (first 32 bits)                                                   |
            +-----+-------------------------------------------------+-----------------------------------------------+
            | 96  | Sender hardware address (SHA) (last 16 bits)    | Sender protocol address (SPA) (first 16 bits) |
            +-----+-------------------------------------------------+-----------------------------------------------+
            | 128 | Sender protocol address (SPA) (last 16 bits)    | Target hardware address (THA) (first 16 bits) |
            +-----+-------------------------------------------------+-----------------------------------------------+
            | 160 |	Target hardware address (THA) (last 32 bits)                                                    |
            +-----+-------------------------------------------------------------------------------------------------+
            | 192 | Target protocol address (TPA)                                                                   |
            +-----+-------------------------------------------------------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Arp.ArpDatagram.HeaderBaseLength">
            <summary>
            The number of bytes in the ARP header without the addresses (that vary in size).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Arp.ArpDatagram.CalculateIsValid">
            <summary>
            The datagram is valid if the length is correct according to the header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.HeaderLength">
            <summary>
            The number of bytes in the ARP header.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.HardwareType">
            <summary>
            Each data link layer protocol is assigned a number used in this field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.ProtocolType">
            <summary>
            Each protocol is assigned a number used in this field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.HardwareLength">
            <summary>
            Length in bytes of a hardware address. Ethernet addresses are 6 bytes long.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.ProtocolLength">
            <summary>
            Length in bytes of a logical address. IPv4 address are 4 bytes long.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.Operation">
            <summary>
            Specifies the operation the sender is performing.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.SenderHardwareAddress">
            <summary>
            Hardware address of the sender.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.SenderProtocolAddress">
            <summary>
            Protocol address of the sender.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.SenderProtocolIpV4Address">
            <summary>
            Protocol IPv4 address of the sender.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.TargetHardwareAddress">
            <summary>
            Hardware address of the intended receiver. 
            This field is ignored in requests.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.TargetProtocolAddress">
            <summary>
            Protocol address of the intended receiver.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Arp.ArpDatagram.TargetProtocolIpV4Address">
            <summary>
            Protocol IPv4 address of the intended receiver.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionConnectionCount">
            <summary>
            CC Option (RFC 1644).
            <pre>
            +--------+--------+--------+--------+--------+--------+
            |00001011|00000110|    Connection Count:  SEG.CC      |
            +--------+--------+--------+--------+--------+--------+
             Kind=11  Length=6
            </pre>
            
            <para>
            This option may be sent in an initial SYN segment, and it may be sent in other segments if a CC or CC.NEW option 
            has been received for this incarnation of the connection.  
            Its SEG.CC value is the TCB.CCsend value from the sender's TCB.
            </para>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCount.#ctor(System.UInt32)">
            <summary>
            Create a connection count tcp option by a given connection count.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCount.#ctor">
            <summary>
            The default connection count is 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionConnectionCount.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionQuickStartFunction">
            <summary>
            Defines the possible quick start functions.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionQuickStartFunction.RateRequest">
            <summary>
            Request for a specific rate.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionQuickStartFunction.RateReport">
            <summary>
            Reports on a specific rate that was agreed (or disagreed).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4FragmentationOptions">
            <summary>
            Fragmentation information flags for IPv4 datagram.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4FragmentationOptions.None">
            <summary>
            May Fragment, Last Fragment.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4FragmentationOptions.MoreFragments">
            <summary>
            More Fragments.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4FragmentationOptions.DoNotFragment">
            <summary>
            Don't Fragment.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer">
            <summary>
            RFC 792 and RFC 1191.
            <seealso cref="T:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableDatagram"/>
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer.Code">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer.MessageType">
            <summary>
            The value of this field determines the format of the remaining data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer.CodeValue">
            <summary>
            A sub-type of the message. Specific method of this message type.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer.NextHopMaximumTransmissionUnit">
            <summary>
            The size in octets of the largest datagram that could be forwarded, 
            along the path of the original datagram, without being fragmented at this router.  
            The size includes the IP header and IP data, and does not include any lower-level headers.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpDestinationUnreachableLayer.Variable">
            <summary>
            A value that should be interpreted according to the specific message.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionTimestamp">
            <summary>
            TCP Timestamps Option (TSopt):
            <pre>
            +-------+-------+---------------------+---------------------+
            |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|
            +-------+-------+---------------------+---------------------+
                1       1              4                     4
            </pre>
            
            <para>
            The Timestamps option carries two four-byte timestamp fields.
            The Timestamp Value field (TSval) contains the current value of the timestamp clock of the TCP sending the option.
            </para>
            
            <para>
            The Timestamp Echo Reply field (TSecr) is only valid if the ACK bit is set in the TCP header; 
            if it is valid, it echos a timestamp value that was sent by the remote TCP in the TSval field of a Timestamps option.  
            When TSecr is not valid, its value must be zero.  
            The TSecr value will generally be from the most recent Timestamp option that was received; however, there are exceptions that are explained below.
            </para>
            
            <para>
            A TCP may send the Timestamps option (TSopt) in an initial &lt;SYN&gt; segment (i.e., segment containing a SYN bit and no ACK bit), 
            and may send a TSopt in other segments only if it received a TSopt in the initial &lt;SYN&gt; segment for the connection.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionTimestamp.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionTimestamp.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Creates the option from the given timestamp value and echo reply.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.#ctor">
            <summary>
            The default values for the timestamp value and echo reply are 0.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.Equals(PcapDotNet.Packets.Transport.TcpOptionTimestamp)">
            <summary>
            Two timestamp options are equal if they have the same timestamp value and echo reply.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two timestamp options are equal if they have the same timestamp value and echo reply.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.GetHashCode">
            <summary>
            The hash code of the timestamp option is the hash code of the option type xored with the hash code of the timestamp echo reply.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionTimestamp.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionTimestamp.TimestampValue">
            <summary>
            The timestamp value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionTimestamp.TimestampEchoReply">
            <summary>
            The echo reply value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionTimestamp.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionTimestamp.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionSimple">
            <summary>
            A simple TCP option - holds only the type.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSimple.OptionLength">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSimple.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSimple.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4TimeOfDay">
            <summary>
            Represents the time passed since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.#ctor(System.UInt32)">
            <summary>
            Create the time from milliseconds since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.#ctor(System.TimeSpan)">
            <summary>
            Create the time from TimeSpan since midnight UT.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.Equals(PcapDotNet.Packets.IpV4.IpV4TimeOfDay)">
            <summary>
            Two times are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.Equals(System.Object)">
            <summary>
            Two times are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.op_Equality(PcapDotNet.Packets.IpV4.IpV4TimeOfDay,PcapDotNet.Packets.IpV4.IpV4TimeOfDay)">
            <summary>
            Two times are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.op_Inequality(PcapDotNet.Packets.IpV4.IpV4TimeOfDay,PcapDotNet.Packets.IpV4.IpV4TimeOfDay)">
            <summary>
            Two times are different if the have different values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.GetHashCode">
            <summary>
            The hash code of a time is the hash code of the milliseconds since midnight UT value.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.MillisecondsSinceMidnightUniversalTime">
            <summary>
            Number of milliseconds passed since midnight UT.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4TimeOfDay.TimeSinceMidnightUniversalTime">
            <summary>
            Time passed since midnight UT.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionStrictSourceRouting">
            <summary>
            Strict Source and Record Route
            <pre>
            +--------+--------+--------+---------//--------+
            |10001001| length | pointer|     route data    |
            +--------+--------+--------+---------//--------+
             Type=137
            </pre>
            
            <para>
            The strict source and record route (SSRR) option provides a means for the source of an internet datagram 
            to supply routing information to be used by the gateways in forwarding the datagram to the destination, 
            and to record the route information.
            </para>
            
            <para>
            The option begins with the option type code.  
            The second octet is the option length which includes the option type code and the length octet, 
            the pointer octet, and length-3 octets of route data.  
            The third octet is the pointer into the route data indicating the octet which begins the next source address to be processed.  
            The pointer is relative to this option, and the smallest legal value for the pointer is 4.
            </para>
            
            <para>
            A route data is composed of a series of internet addresses.
            Each internet address is 32 bits or 4 octets.  
            If the pointer is greater than the length, the source route is empty (and the recorded route full) 
            and the routing is to be based on the destination address field.
            </para>
            
            <para>
            If the address in destination address field has been reached and the pointer is not greater than the length, 
            the next address in the source route replaces the address in the destination address field, 
            and the recorded route address replaces the source address just used, and pointer is increased by four.
            </para>
            
            <para>
            The recorded route address is the internet module's own internet address as known in the environment 
            into which this datagram is being forwarded.
            </para>
            
            <para>
            This procedure of replacing the source route with the recorded route 
            (though it is in the reverse of the order it must be in to be used as a source route) 
            means the option (and the IP header as a whole) remains a constant length as the datagram progresses through the internet.
            </para>
            
            <para>
            This option is a strict source route because the gateway or host IP 
            must send the datagram directly to the next address in the source route through only the directly connected network 
            indicated in the next address to reach the next gateway or host specified in the route.
            </para>
            
            <para>
            Must be copied on fragmentation.  
            Appears at most once in a datagram.
            </para>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStrictSourceRouting.#ctor(System.Collections.Generic.IList{PcapDotNet.Packets.IpV4.IpV4Address},System.Byte)">
            <summary>
            Create the option according to the given values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStrictSourceRouting.#ctor">
            <summary>
            Creates an empty strict source routing option.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionStrictSourceRouting.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="T:PcapDotNet.Packets.IpV6.IpV6Address">
            <summary>
            Represents an IPv6 address.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV6.IpV6Address.SizeOf">
            <summary>
            The number of bytes the address take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.#ctor(PcapDotNet.Base.UInt128)">
            <summary>
            Create an address from a 128 bit integer.
            0 -> ::
            1 -> ::1
            256 -> ::100
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.#ctor(System.String)">
            <summary>
            Creates an address from an address string ("2001:0db8:0::22:1.2.3.4").
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.ToValue">
            <summary>
            Gets the address value as a 128 bit integer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.Equals(PcapDotNet.Packets.IpV6.IpV6Address)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.Equals(System.Object)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.op_Equality(PcapDotNet.Packets.IpV6.IpV6Address,PcapDotNet.Packets.IpV6.IpV6Address)">
            <summary>
            Two addresses are equal if the have the exact same value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.op_Inequality(PcapDotNet.Packets.IpV6.IpV6Address,PcapDotNet.Packets.IpV6.IpV6Address)">
            <summary>
            Two addresses are different if the have different values.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.GetHashCode">
            <summary>
            The hash code of an address is the hash code of its 128 bit integer value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV6.IpV6Address.ToString">
            <summary>
            Translates the address to a string (0ABC:1234:5678:0443:0ABC:1234:5678:0443).
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV6.IpV6Address.Zero">
            <summary>
            The zero address (::).
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram">
            <summary>
            Each Group Record is a block of fields containing information pertaining 
            to the sender's membership in a single multicast group on the interface from which the Report is sent.
            A Group Record has the following internal format:
            <pre>
            +-----+-------------+--------------+--------+--------------+
            | Bit | 0-7         | 8-15         | 16-31  |              |
            +-----+-------------+--------------+--------+--------------+
            | 0   | Record Type | Aux Data Len | Number of Sources (N) |
            +-----+-------------+--------------+--------+--------------+
            | 32  | Multicast Address                                  |
            +-----+----------------------------------------------------+
            | 64  | Source Address [1]                                 |
            +-----+----------------------------------------------------+
            | 96  | Source Address [2]                                 |
            +-----+----------------------------------------------------+
            .     .                         .                          .
            .     .                         .                          .
            +-----+----------------------------------------------------+
            | 32  | Source Address [N]                                 |
            | +   |                                                    |
            | 32N |                                                    |
            +-----+----------------------------------------------------+
            | 64  | Auxiliary Data                                     |
            . +   .                                                    .
            . 32N .                                                    .
            .     .                                                    .
            |     |                                                    |
            +-----+----------------------------------------------------+
            </pre>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.HeaderLength">
            <summary>
            The number of bytes the group record header takes (without the source addresses and auxiliary data).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.ToGroupRecord">
            <summary>
            Creates an IGMP group record from the given datagram.
            Useful to create a new IGMP packet with group records.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.CalculateIsValid">
            <summary>
            The record is valid if the length is correct according to the header fields.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.RecordType">
            <summary>
            The type of group record included in the report message.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.AuxiliaryDataLength">
            <summary>
            The Aux Data Len field contains the length of the Auxiliary Data field in this Group Record, in bytes (after a translation from 32 bit words length).  
            It may contain zero, to indicate the absence of any auxiliary data.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.NumberOfSources">
            <summary>
            The Number of Sources (N) field specifies how many source addresses are present in this Group Record.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.MulticastAddress">
            <summary>
            The Multicast Address field contains the IP multicast address to which this Group Record pertains.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.SourceAddresses">
            <summary>
            The Source Address [i] fields are a vector of n IP unicast addresses, 
            where n is the value in this record's Number of Sources (N) field.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpGroupRecordDatagram.AuxiliaryData">
            <summary>
            The Auxiliary Data field, if present, contains additional information pertaining to this Group Record.  
            The protocol specified in this document, IGMPv3, does not define any auxiliary data.  
            Therefore, implementations of IGMPv3 MUST NOT include any auxiliary data (i.e., MUST set the Aux Data Len field to zero) in any transmitted Group Record, 
            and MUST ignore any auxiliary data present in any received Group Record.  
            The semantics and internal encoding of the Auxiliary Data field are to be defined by any future version or extension of IGMP that uses this field.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry">
            <summary>
            RFC 1256.
            Represents an entry in Router Advertisement ICMP message.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.#ctor(PcapDotNet.Packets.IpV4.IpV4Address,System.Int32)">
            <summary>
            Creates an instance using the given router address and preference.
            </summary>
            <param name="routerAddress">The sending router's IP address(es) on the interface from which this message is sent.</param>
            <param name="routerAddressPreference">The preferability of each Router Address[i] as a default router address, relative to other router addresses on the same subnet. A signed, twos-complement value; higher values mean more preferable.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.Equals(PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry)">
            <summary>
            Two entries are equal if they have the same router address and preference.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.Equals(System.Object)">
            <summary>
            Two entries are equal if they have the same router address and preference.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.GetHashCode">
            <summary>
            A xor of the hash codes of the router address and preference.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.RouterAddress">
            <summary>
            The sending router's IP address(es) on the interface from which this message is sent.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Icmp.IcmpRouterAdvertisementEntry.RouterAddressPreference">
            <summary>
            The preferability of each Router Address[i] as a default router address, relative to other router addresses on the same subnet. A signed, twos-complement value; higher values mean more preferable.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpRequestLayer">
            <summary>
            RFC 2616.
            Represents an HTTP request layer.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestLayer.Equals(PcapDotNet.Packets.Http.HttpLayer)">
            <summary>
            Two HTTP Request layers are equal iff they have the same version, header, body, method and uri.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Http.HttpRequestLayer.Equals(PcapDotNet.Packets.Http.HttpRequestLayer)">
            <summary>
            Two HTTP Request layers are equal iff they have the same version, header, body, method and uri.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestLayer.IsRequest">
            <summary>
            True since the message is a request.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestLayer.Method">
            <summary>
            The HTTP Request Method.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Http.HttpRequestLayer.Uri">
            <summary>
            The HTTP Request URI.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.DataLink">
            <summary>
            Represents the DataLink type.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.#ctor(PcapDotNet.Packets.DataLinkKind)">
            <summary>
            Create the DataLink from a kind.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.Equals(PcapDotNet.Packets.DataLink)">
            <summary>
            Two DataLinks are equal if they are of the same kind.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.Equals(System.Object)">
            <summary>
            Two DataLinks are equal if they are of the same type and the same kind.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.op_Equality(PcapDotNet.Packets.DataLink,PcapDotNet.Packets.DataLink)">
            <summary>
            Two DataLinks are equal if they are of the same kind.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.op_Inequality(PcapDotNet.Packets.DataLink,PcapDotNet.Packets.DataLink)">
            <summary>
            Two DataLinks are different if they have different kinds.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.GetHashCode">
            <summary>
            The hash code of the datalink is the hash code of its kind.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.DataLink.ToString">
            <summary>
            The string is the kind's string.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.DataLink.Ethernet">
            <summary>
            Etherent DataLink.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.DataLink.Kind">
            <summary>
            The kind of the DataLink.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionWindowScale">
            <summary>
            Window Scale Option (RFC 1323)
            The three-byte Window Scale option may be sent in a SYN segment by a TCP.  
            It has two purposes: (1) indicate that the TCP is prepared to do both send and receive window scaling, 
            and (2) communicate a scale factor to be applied to its receive window.  
            Thus, a TCP that is prepared to scale windows should send the option, even if its own scale factor is 1.  
            The scale factor is limited to a power of two and encoded logarithmically, so it may be implemented by binary shift operations.
            
            <pre>
            +---------+---------+---------+
            | Kind=3  |Length=3 |shift.cnt|
            +---------+---------+---------+
            </pre>
            
            <para>
            This option is an offer, not a promise; both sides must send Window Scale options in their SYN segments to enable window scaling in either direction.
            If window scaling is enabled, then the TCP that sent this option will right-shift its true receive-window values by 'shift.cnt' bits 
            for transmission in SEG.WND.  
            The value 'shift.cnt' may be zero (offering to scale, while applying a scale factor of 1 to the receive window).
            </para>
            
            <para>
            This option may be sent in an initial SYN segment (i.e., a segment with the SYN bit on and the ACK bit off).  
            It may also be sent in a SYN,ACK segment, but only if a Window Scale option was received in the initial SYN segment.  
            A Window Scale option in a segment without a SYN bit should be ignored.
            </para>
            
            <para>
            The Window field in a SYN (i.e., a SYN or SYN,ACK) segment itself is never scaled.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionWindowScale.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionWindowScale.OptionValueLength">
            <summary>
            The number of bytes this option value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.#ctor(System.Byte)">
            <summary>
            Create a scale factor option using the given scale factor log.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.#ctor">
            <summary>
            The default scale factor log is 0 (scale factor is 1).
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.Equals(PcapDotNet.Packets.Transport.TcpOptionWindowScale)">
            <summary>
            Two window scale options are equal if they have the same scale factor.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.Equals(PcapDotNet.Packets.Transport.TcpOption)">
            <summary>
            Two window scale options are equal if they have the same scale factor.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.GetHashCode">
            <summary>
            The hash code of the window scale option is the hash code of the option type xored with the hash code of the scale factor log.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionWindowScale.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionWindowScale.ScaleFactorLog">
            <summary>
            The log of the window scale factor.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionWindowScale.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionWindowScale.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock">
            <summary>
            Represents a block to ack when using the selective ack option.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.SizeOf">
            <summary>
            The number of bytes this struct take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Creates a selective ack block.
            </summary>
            <param name="leftEdge">The sequence number of the first byte to ack.</param>
            <param name="rightEdge">The sequence number of the byte after the last byte to ack.</param>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.ToString">
            <summary>
            Creates a string that represents the selective block.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.Equals(PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock)">
            <summary>
            Two blocks are equal if the have the same left and right edges.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.Equals(System.Object)">
            <summary>
            Two blocks are equal if the have the same left and right edges.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.op_Equality(PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock,PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock)">
            <summary>
            Two blocks are equal if the have the same left and right edges.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.op_Inequality(PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock,PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock)">
            <summary>
            Two blocks are different if the have the different left or right edge.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.GetHashCode">
            <summary>
            The hash code of a block is the xor between the hash code of left and right edges.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.LeftEdge">
            <summary>
            The sequence number of the first byte to ack.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Transport.TcpOptionSelectiveAcknowledgmentBlock.RightEdge">
            <summary>
            The sequence number of the byte after the last byte to ack.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert">
            <summary>
            The Router Alert option has the semantic "routers should examine this packet more closely".  
            By including the Router Alert option in the IP header of its protocol message, 
            RSVP can cause the message to be intercepted while causing little or no performance 
            penalty on the forwarding of normal data packets.
            
            <para>
            Routers that support option processing in the fast path already demultiplex processing based on the option type field.  
            If all option types are supported in the fast path, then the addition of another option type to process is unlikely to impact performance.  
            If some option types are not supported in the fast path, 
            this new option type will be unrecognized and cause packets carrying it to be kicked out into the slow path, 
            so no change to the fast path is necessary, and no performance penalty will be incurred for regular data packets.
            </para>
            
            <para>
            Routers that do not support option processing in the fast path will cause packets carrying this new option 
            to be forwarded through the slow path, so no change to the fast path is necessary and no performance penalty 
            will be incurred for regular data packets.
            </para>
            
            <para>
            The Router Alert option has the following format:
            <pre>
            +--------+--------+--------+--------+
            |10010100|00000100|  2 octet value  |
            +--------+--------+--------+--------+
            </pre>
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.OptionLength">
            <summary>
            The number of bytes this option take.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.OptionValueLength">
            <summary>
            The number of bytes this option's value take.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.#ctor(System.UInt16)">
            <summary>
            Create the option according to the given value.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.#ctor">
            <summary>
            Creates a 0 value router alert option
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.Equals(PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert)">
            <summary>
            Two stream identifier options are equal if they have the same identifier.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.Equals(PcapDotNet.Packets.IpV4.IpV4Option)">
            <summary>
            Two stream identifier options are equal if they have the same identifier.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.GetHashCode">
            <summary>
            The hash code value is the xor of the base class hash code and the value hash code.
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.PcapDotNet#Packets#IOptionComplexFactory#CreateInstance(System.Byte[],System.Int32@,System.Byte)">
            <summary>
            Tries to read the option from a buffer starting from the option value (after the type and length).
            </summary>
            <param name="buffer">The buffer to read the option from.</param>
            <param name="offset">The offset to the first byte to read the buffer. Will be incremented by the number of bytes read.</param>
            <param name="valueLength">The number of bytes the option value should take according to the length field that was already read.</param>
            <returns>On success - the complex option read. On failure - null.</returns>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.Value">
            <summary>
            The value of the alert.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.Length">
            <summary>
            The number of bytes this option will take.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.IpV4.IpV4OptionRouterAlert.IsAppearsAtMostOnce">
            <summary>
            True iff this option may appear at most once in a datagram.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Igmp.IgmpQueryVersion2Layer">
            <summary>
            RFC 2236.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion2Layer.MessageType">
            <summary>
            The type of the IGMP message of concern to the host-router interaction.
            </summary>
        </member>
        <member name="P:PcapDotNet.Packets.Igmp.IgmpQueryVersion2Layer.QueryVersion">
            <summary>
            The IGMP version of a Membership Query message.
            If the type is not a query, None will be returned.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpMessageType">
            <summary>
            The different ICMP message types.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.EchoReply">
            <summary>
            RFC 792.
            <para>
            The data received in the echo message must be returned in the echo reply message.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the echo requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each echo request sent.  
            The echoer returns these same values in the echo reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.DestinationUnreachable">
            <summary>
            RFC 792
            
            <para>
            If, according to the information in the gateway's routing tables, 
            the network specified in the internet destination field of a datagram is unreachable, e.g., the distance to the network is infinity, 
            the gateway may send a destination unreachable message to the internet source host of the datagram.  
            In addition, in some networks, the gateway may be able to determine if the internet destination host is unreachable.  
            Gateways in these networks may send destination unreachable messages to the source host when the destination host is unreachable.
            </para>
            
            <para>
            If, in the destination host, the IP module cannot deliver the datagram  because the indicated protocol module or process port is not active, 
            the destination host may send a destination unreachable message to the source host.
            </para>
            
            <para>
            Another case is when a datagram must be fragmented to be forwarded by a gateway yet the Don't Fragment flag is on. 
            In this case the gateway must discard the datagram and may return a destination unreachable message.
            </para>
            
            <para>
            Codes 0, 1, 4, and 5 may be received from a gateway.  
            Codes 2 and 3 may be received from a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.SourceQuench">
            <summary>
            RFC 792.
            
            <para>
            A gateway may discard internet datagrams if it does not have the buffer space needed to queue the datagrams for output to the next network on the route to the destination network.  
            If a gateway discards a datagram, it may send a source quench message to the internet source host of the datagram.  
            A destination host may also send a source quench message if datagrams arrive too fast to be processed.  
            The source quench message is a request to the host to cut back the rate at which it is sending traffic to the internet destination.  
            The gateway may send a source quench message for every message that it discards.  
            On receipt of a source quench message, the source host should cut back the rate at which it is sending traffic to the specified destination 
            until it no longer receives source quench messages from the gateway.  
            The source host can then gradually increase the rate at which it sends traffic to the destination until it again receives source quench messages.
            </para>
            
            <para>
            The gateway or host may send the source quench message when it approaches its capacity limit rather than waiting until the capacity is exceeded.  
            This means that the data datagram which triggered the source quench message may be delivered.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.Redirect">
            <summary>
            RFC 792.
            
            <para>
            The gateway sends a redirect message to a host in the following situation.  
            A gateway, G1, receives an internet datagram from a host on a network to which the gateway is attached.  
            The gateway, G1, checks its routing table and obtains the address of the next gateway, G2, on the route to the datagram's internet destination network, X.  
            If G2 and the host identified by the internet source address of the datagram are on the same network, a redirect message is sent to the host.  
            The redirect message advises the host to send its traffic for network X directly to gateway G2 as this is a shorter path to the destination.  
            The gateway forwards the original datagram's data to its internet destination.
            </para>
            
            <para>
            For datagrams with the IP source route options and the gateway address in the destination address field, 
            a redirect message is not sent even if there is a better route to the ultimate destination than the next address in the source route.
            </para>
            
            <para>
            Codes 0, 1, 2, and 3 may be received from a gateway.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.Echo">
            <summary>
            RFC 792.
            <para>
            The data received in the echo message must be returned in the echo reply message.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the echo requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each echo request sent.  
            The echoer returns these same values in the echo reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.RouterAdvertisement">
            <summary>
            RFC 1256.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.RouterSolicitation">
            <summary>
            RFC 1256.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.TimeExceeded">
            <summary>
            RFC 792.
            
            <para>
            If the gateway processing a datagram finds the time to live field is zero it must discard the datagram.  
            The gateway may also notify the source host via the time exceeded message.
            </para>
            
            <para>
            If a host reassembling a fragmented datagram cannot complete the reassembly due to missing fragments within its time limit it discards the datagram, 
            and it may send a time exceeded message.
            If fragment zero is not available then no time exceeded need be sent at all.
            </para>
            
            <para>
            Code 0 may be received from a gateway.  
            Code 1 may be received from a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.ParameterProblem">
            <summary>
            RFC 792.
            
            <para>
            If the gateway or host processing a datagram finds a problem with the header parameters such that it cannot complete processing the datagram it must discard the datagram.  
            One potential source of such a problem is with incorrect arguments in an option.  
            The gateway or host may also notify the source host via the parameter problem message. 
            This message is only sent if the error caused the datagram to be discarded.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.Timestamp">
            <summary>
            RFC 792
            <para>
            The data received (a timestamp) in the message is returned in the reply together with an additional timestamp.  
            The timestamp is 32 bits of milliseconds since midnight UT.  
            </para>
            
            <para>
            If the time is not available in miliseconds or cannot be provided with respect to midnight UT 
            then any time can be inserted in a timestamp provided the high order bit of the timestamp is also set to indicate this non-standard value.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.TimestampReply">
            <summary>
            RFC 792
            <para>
            The data received (a timestamp) in the message is returned in the reply together with an additional timestamp.  
            The timestamp is 32 bits of milliseconds since midnight UT.  
            </para>
            
            <para>
            If the time is not available in miliseconds or cannot be provided with respect to midnight UT 
            then any time can be inserted in a timestamp provided the high order bit of the timestamp is also set to indicate this non-standard value.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.InformationRequest">
            <summary>
            RFC 792.
            <para>
            This message may be sent with the source network in the IP header source and destination address fields zero (which means "this" network).  
            The replying IP module should send the reply with the addresses fully specified.  
            This message is a way for a host to find out the number of the network it is on.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.InformationReply">
            <summary>
            RFC 792.
            <para>
            This message may be sent with the source network in the IP header source and destination address fields zero (which means "this" network).  
            The replying IP module should send the reply with the addresses fully specified.  
            This message is a way for a host to find out the number of the network it is on.
            </para>
            
            <para>
            The identifier and sequence number may be used by the echo sender to aid in matching the replies with the requests.  
            For example, the identifier might be used like a port in TCP or UDP to identify a session, and the sequence number might be incremented on each request sent.  
            The destination returns these same values in the reply.
            </para>
            
            <para>
            Code 0 may be received from a gateway or a host.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.AddressMaskRequest">
            <summary>
            RFC 950.
            
            <para>
            A gateway receiving an address mask request should return it with the address mask field set to the 32-bit mask of the bits identifying the subnet and network, 
            for the subnet on which the request was received.
            </para>
            
            <para>
            If the requesting host does not know its own IP address, it may leave the source field zero; the reply should then be broadcast.  
            However, this approach should be avoided if at all possible, since it increases the superfluous broadcast load on the network.  
            Even when the replies are broadcast, since there is only one possible address mask for a subnet, there is no need to match requests with replies.  
            The "Identifier" and "Sequence Number" fields can be ignored.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.AddressMaskReply">
            <summary>
            RFC 950.
            
            <para>
            A gateway receiving an address mask request should return it with the address mask field set to the 32-bit mask of the bits identifying the subnet and network, 
            for the subnet on which the request was received.
            </para>
            
            <para>
            If the requesting host does not know its own IP address, it may leave the source field zero; the reply should then be broadcast.  
            However, this approach should be avoided if at all possible, since it increases the superfluous broadcast load on the network.  
            Even when the replies are broadcast, since there is only one possible address mask for a subnet, there is no need to match requests with replies.  
            The "Identifier" and "Sequence Number" fields can be ignored.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.TraceRoute">
            <summary>
            RFC 1393.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.ConversionFailed">
            <summary>
            RFC 1475.
            The introduction of network layer conversion requires a new message type, to report conversion errors.  
            Note that an invalid datagram should result in the sending of some other ICMP message (e.g., parameter problem) or the silent discarding of the datagram.  
            This message is only sent when a valid datagram cannot be converted.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.DomainNameRequest">
            <summary>
            RFC 1788.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.DomainNameReply">
            <summary>
            RFC 1788.
            Parsing of this datagram isn't supported because its parsing is not clear from the RFC.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Icmp.IcmpMessageType.SecurityFailures">
            <summary>
            RFC 2521.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Icmp.IcmpInformationReplyDatagram">
            <summary>
            RFC 792.
            <pre>
            +-----+------+------+-----------------+
            | Bit | 0-7  | 8-15 | 16-31           |
            +-----+------+------+-----------------+
            | 0   | Type | Code | Checksum        |
            +-----+------+------+-----------------+
            | 32  | Identifier  | Sequence Number |
            +-----+-------------+-----------------+
            </pre>
            </summary>
        </member>
        <member name="M:PcapDotNet.Packets.Icmp.IcmpInformationReplyDatagram.ExtractLayer">
            <summary>
            Creates a Layer that represents the datagram to be used with PacketBuilder.
            </summary>
        </member>
        <member name="T:PcapDotNet.Packets.Http.HttpRequestKnownMethod">
            <summary>
            Known HTTP request method.
            RFC 2616.
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Options">
            <summary>
            RFC 2616.
            <para>
            The OPTIONS method represents a request for information about the communication options available on the request/response chain identified by the Request-URI. 
            This method allows the client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action or initiating a resource retrieval.
            </para>
            <para>
            Responses to this method are not cacheable.
            </para>
            <para>
            If the OPTIONS request includes an entity-body (as indicated by the presence of Content-Length or Transfer-Encoding), 
            then the media type MUST be indicated by a Content-Type field. 
            Although this specification does not define any use for such a body, future extensions to HTTP might use the OPTIONS body to make more detailed queries on the server. 
            A server that does not support such an extension MAY discard the request body. 
            </para>
            <para>
            If the Request-URI is an asterisk ("*"), the OPTIONS request is intended to apply to the server in general rather than to a specific resource. 
            Since a server's communication options typically depend on the resource, the "*" request is only useful as a "ping" or "no-op" type of method; 
            it does nothing beyond allowing the client to test the capabilities of the server. 
            For example, this can be used to test a proxy for HTTP/1.1 compliance (or lack thereof).
            </para>
            <para>
            If the Request-URI is not an asterisk, the OPTIONS request applies only to the options that are available when communicating with that resource.
            </para>
            <para>
            A 200 response SHOULD include any header fields that indicate optional features implemented by the server and applicable to that resource (e.g., Allow), 
            possibly including extensions not defined by this specification. 
            The response body, if any, SHOULD also include information about the communication options. 
            The format for such a body is not defined by this specification, but might be defined by future extensions to HTTP. 
            Content negotiation MAY be used to select the appropriate response format. If no response body is included, the response MUST include a Content-Length field with a field-value of "0".
            </para>
            <para>
            The Max-Forwards request-header field MAY be used to target a specific proxy in the request chain. 
            When a proxy receives an OPTIONS request on an absoluteURI for which request forwarding is permitted, the proxy MUST check for a Max-Forwards field. 
            If the Max-Forwards field-value is zero ("0"), the proxy MUST NOT forward the message; instead, the proxy SHOULD respond with its own communication options.
            If the Max-Forwards field-value is an integer greater than zero, the proxy MUST decrement the field-value when it forwards the request. 
            If no Max-Forwards field is present in the request, then the forwarded request MUST NOT include a Max-Forwards field.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Get">
            <summary>
            RFC 2616.
            <para>
            The GET method means retrieve whatever information (in the form of an entity) is identified by the Request-URI. 
            If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process,
            unless that text happens to be the output of the process.
            </para>
            <para>
            The semantics of the GET method change to a "conditional GET" if the request message includes an If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range header field. 
            A conditional GET method requests that the entity be transferred only under the circumstances described by the conditional header field(s). 
            The conditional GET method is intended to reduce unnecessary network usage by allowing cached entities to be refreshed without requiring multiple requests or transferring data already held by the client.
            </para>
            <para>
            The semantics of the GET method change to a "partial GET" if the request message includes a Range header field. 
            A partial GET requests that only part of the entity be transferred.
            The partial GET method is intended to reduce unnecessary network usage by allowing partially-retrieved entities to be completed without transferring data already held by the client.
            </para>
            <para>
            The response to a GET request is cacheable if and only if it meets the requirements for HTTP caching.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Head">
            <summary>
            RFC 2616.
            <para>
            The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.
            The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request. 
            This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself. 
            This method is often used for testing hypertext links for validity, accessibility, and recent modification.
            </para>
            <para>
            The response to a HEAD request MAY be cacheable in the sense that the information contained in the response MAY be used to update a previously cached entity from that resource. 
            If the new field values indicate that the cached entity differs from the current entity (as would be indicated by a change in Content-Length, Content-MD5, ETag or Last-Modified), 
            then the cache MUST treat the cache entry as stale.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Post">
            <summary>
            RFC 2616.
            <para>
            The POST method is used to request that the origin server accept the entity enclosed in the request as a new subordinate of the resource identified by the Request-URI in the Request-Line. 
            POST is designed to allow a uniform method to cover the following functions: 
            <list type="bullet">
              <item>Annotation of existing resources;</item>
              <item>Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;</item>
              <item>Providing a block of data, such as the result of submitting a form, to a data-handling process;</item>
              <item>Extending a database through an append operation.</item>
            </list>
            </para>
            <para>
            The actual function performed by the POST method is determined by the server and is usually dependent on the Request-URI. 
            The posted entity is subordinate to that URI in the same way that a file is subordinate to a directory containing it, 
            a news article is subordinate to a newsgroup to which it is posted, or a record is subordinate to a database.
            </para>
            <para>
            The action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either 200 (OK) or 204 (No Content) is the appropriate response status,
            depending on whether or not the response includes an entity that describes the result.
            </para>
            <para>
            If a resource has been created on the origin server, 
            the response SHOULD be 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header.
            </para>
            <para>
            Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields. 
            However, the 303 (See Other) response can be used to direct the user agent to retrieve a cacheable resource.
            </para>
            <para>
            POST requests MUST obey the message transmission requirements.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Put">
            <summary>
            RFC 2616.
            <para>
            The PUT method requests that the enclosed entity be stored under the supplied Request-URI. 
            If the Request-URI refers to an already existing resource, the enclosed entity SHOULD be considered as a modified version of the one residing on the origin server. 
            If the Request-URI does not point to an existing resource, and that URI is capable of being defined as a new resource by the requesting user agent, the origin server can create the resource with that URI. 
            If a new resource is created, the origin server MUST inform the user agent via the 201 (Created) response. 
            If an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request. 
            If the resource could not be created or modified with the Request-URI, an appropriate error response SHOULD be given that reflects the nature of the problem. 
            The recipient of the entity MUST NOT ignore any Content-* (e.g. Content-Range) headers that it does not understand or implement and MUST return a 501 (Not Implemented) response in such cases.
            </para>
            <para>
            If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. 
            Responses to this method are not cacheable.
            </para>
            <para>
            The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. 
            The URI in a POST request identifies the resource that will handle the enclosed entity. 
            That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. 
             In contrast, the URI in a PUT request identifies the entity enclosed with the request -- the user agent knows what URI is intended and the server MUST NOT attempt to apply the request to some other resource.
            If the server desires that the request be applied to a different URI, it MUST send a 301 (Moved Permanently) response; 
            the user agent MAY then make its own decision regarding whether or not to redirect the request.
            </para>
            <para>
            A single resource MAY be identified by many different URIs. 
            For example, an article might have a URI for identifying "the current version" which is separate from the URI identifying each particular version. 
            In this case, a PUT request on a general URI might result in several other URIs being defined by the origin server.
            </para>
            <para>
            HTTP/1.1 does not define how a PUT method affects the state of an origin server.
            </para>
            <para>
            PUT requests MUST obey the message transmission requirements.
            </para>
            <para>
            Unless otherwise specified for a particular entity-header, the entity-headers in the PUT request SHOULD be applied to the resource created or modified by the PUT.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Delete">
            <summary>
            RFC 2616.
            <para>
            The DELETE method requests that the origin server delete the resource identified by the Request-URI. 
            This method MAY be overridden by human intervention (or other means) on the origin server. 
            The client cannot be guaranteed that the operation has been carried out, even if the status code returned from the origin server indicates that the action has been completed successfully. 
            However, the server SHOULD NOT indicate success unless, at the time the response is given, it intends to delete the resource or move it to an inaccessible location.
            </para>
            <para>
            A successful response SHOULD be 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has not yet been enacted, 
            or 204 (No Content) if the action has been enacted but the response does not include an entity.
            </para>
            <para>
            If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. 
            Responses to this method are not cacheable.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Trace">
            <summary>
            RFC 2616.
            <para>
            The TRACE method is used to invoke a remote, application-layer loop-back of the request message. 
            The final recipient of the request SHOULD reflect the message received back to the client as the entity-body of a 200 (OK) response. 
            The final recipient is either the origin server or the first proxy or gateway to receive a Max-Forwards value of zero (0) in the request (see section 14.31). 
            A TRACE request MUST NOT include an entity.
            </para>
            <para>
            TRACE allows the client to see what is being received at the other end of the request chain and use that data for testing or diagnostic information. 
            The value of the Via header field is of particular interest, since it acts as a trace of the request chain.
            Use of the Max-Forwards header field allows the client to limit the length of the request chain, which is useful for testing a chain of proxies forwarding messages in an infinite loop.
            </para>
            <para>
            If the request is valid, the response SHOULD contain the entire request message in the entity-body, with a Content-Type of "message/http". 
            Responses to this method MUST NOT be cached.
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Connect">
            <summary>
            RFC 2616.
            <para>
            This specification reserves the method name CONNECT for use with a proxy that can dynamically switch to being a tunnel (e.g. SSL tunneling).
            </para>
            </summary>
        </member>
        <member name="F:PcapDotNet.Packets.Http.HttpRequestKnownMethod.Unknown">
            <summary>
            Unknown request method.
            </summary>
        </member>
    </members>
</doc>
